warning: CUDA version 12.1 is only partially supported
warning: CUDA version 12.1 is only partially supported
[ict-debug] driver.cc: After return 5, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z30__device_stub__rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    call @_Z15rms_norm_kernelPKfPfiiiif(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6) : (memref<?xf32>, memref<?xf32>, i32, i32, i32, i32, f32) -> ()
    return
  }
  func.func private @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c32 = arith.constant 32 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2_i32 = arith.constant 2 : i32
    %c0_i32 = arith.constant 0 : i32
    %true = arith.constant true
    %0 = arith.index_cast %arg5 : i32 to index
    %1 = arith.index_cast %arg5 : i32 to index
    %alloca = memref.alloca() : memref<1xf32, 5>
    %2 = gpu.block_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.divsi %3, %arg5 : i32
    %5 = arith.remsi %4, %arg4 : i32
    %6 = arith.divsi %4, %arg4 : i32
    %7 = arith.muli %6, %arg3 : i32
    %8 = gpu.thread_id  x
    %9 = arith.index_cast %8 : index to i32
    %10 = arith.addi %7, %9 : i32
    %11 = arith.muli %10, %arg4 : i32
    %12 = arith.addi %11, %5 : i32
    %13 = arith.muli %12, %arg5 : i32
    %14 = arith.index_cast %13 : i32 to index
    %15 = arith.index_cast %13 : i32 to index
    %16 = arith.cmpi eq, %9, %c0_i32 : i32
    %17 = arith.muli %arg2, %arg4 : i32
    %18 = arith.muli %17, %arg5 : i32
    %19 = arith.cmpi sge, %3, %18 : i32
    %20 = scf.if %19 -> (i1) {
      scf.yield %true : i1
    } else {
      %22 = arith.cmpi sge, %9, %arg3 : i32
      scf.yield %22 : i1
    }
    %21 = arith.xori %20, %true : i1
    scf.if %21 {
      %22 = affine.load %arg0[symbol(%14) + symbol(%2) mod symbol(%0)] : memref<?xf32>
      %23 = arith.mulf %22, %22 : f32
      affine.store %23, %alloca[symbol(%8)] : memref<1xf32, 5>
      nvvm.barrier0
      %24 = arith.divsi %arg3, %c2_i32 : i32
      %25 = math.ctlz %24 : i32
      %26 = arith.index_cast %25 : i32 to index
      %27 = arith.subi %c32, %26 : index
      %28 = arith.divsi %arg3, %c2_i32 : i32
      scf.for %arg7 = %c0 to %27 step %c1 {
        %31 = arith.index_cast %arg7 : index to i32
        %32 = arith.shrui %28, %31 : i32
        %33 = arith.cmpi ult, %9, %32 : i32
        scf.if %33 {
          %34 = arith.addi %9, %32 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = memref.load %alloca[%35] : memref<1xf32, 5>
          %37 = affine.load %alloca[symbol(%8)] : memref<1xf32, 5>
          %38 = arith.addf %37, %36 : f32
          affine.store %38, %alloca[symbol(%8)] : memref<1xf32, 5>
        }
        nvvm.barrier0
      }
      scf.if %16 {
        %31 = affine.load %alloca[0] : memref<1xf32, 5>
        %32 = arith.sitofp %arg3 : i32 to f32
        %33 = arith.divf %31, %32 : f32
        %34 = arith.addf %33, %arg6 : f32
        %35 = math.sqrt %34 : f32
        affine.store %35, %alloca[0] : memref<1xf32, 5>
      }
      nvvm.barrier0
      %29 = affine.load %alloca[0] : memref<1xf32, 5>
      %30 = arith.divf %22, %29 : f32
      affine.store %30, %arg1[symbol(%15) + symbol(%2) mod symbol(%1)] : memref<?xf32>
    }
    return
  }
}
[ict-debug] driver.cc: After return 5, module: end

[ict-debug] driver.cc: After return 6, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c32 = arith.constant 32 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2_i32 = arith.constant 2 : i32
    %c0_i32 = arith.constant 0 : i32
    %true = arith.constant true
    %0 = arith.index_cast %arg5 : i32 to index
    %alloca = memref.alloca() : memref<1xf32, 5>
    %1 = gpu.block_id  x
    %2 = arith.remsi %1, %0 : index
    %3 = arith.addi %2, %0 : index
    %4 = arith.cmpi slt, %2, %c0 : index
    %5 = arith.select %4, %3, %2 : index
    %6 = arith.index_cast %1 : index to i32
    %7 = arith.divsi %6, %arg5 : i32
    %8 = arith.remsi %7, %arg4 : i32
    %9 = arith.divsi %7, %arg4 : i32
    %10 = arith.muli %9, %arg3 : i32
    %11 = gpu.thread_id  x
    %12 = arith.index_cast %11 : index to i32
    %13 = arith.addi %10, %12 : i32
    %14 = arith.muli %13, %arg4 : i32
    %15 = arith.addi %14, %8 : i32
    %16 = arith.muli %15, %arg5 : i32
    %17 = arith.index_cast %16 : i32 to index
    %18 = arith.cmpi eq, %12, %c0_i32 : i32
    %19 = arith.muli %arg2, %arg4 : i32
    %20 = arith.muli %19, %arg5 : i32
    %21 = arith.cmpi sge, %6, %20 : i32
    %22 = scf.if %21 -> (i1) {
      scf.yield %true : i1
    } else {
      %24 = arith.cmpi sge, %12, %arg3 : i32
      scf.yield %24 : i1
    }
    %23 = arith.xori %22, %true : i1
    scf.if %23 {
      %24 = affine.load %arg0[symbol(%17) + symbol(%5)] : memref<?xf32>
      %25 = arith.mulf %24, %24 : f32
      affine.store %25, %alloca[symbol(%11)] : memref<1xf32, 5>
      nvvm.barrier0
      %26 = arith.divsi %arg3, %c2_i32 : i32
      %27 = math.ctlz %26 : i32
      %28 = arith.index_cast %27 : i32 to index
      %29 = arith.subi %c32, %28 : index
      scf.for %arg7 = %c0 to %29 step %c1 {
        %32 = arith.index_cast %arg7 : index to i32
        %33 = arith.shrui %26, %32 : i32
        %34 = arith.cmpi ult, %12, %33 : i32
        scf.if %34 {
          %35 = arith.addi %12, %33 : i32
          %36 = arith.index_cast %35 : i32 to index
          %37 = memref.load %alloca[%36] : memref<1xf32, 5>
          %38 = affine.load %alloca[symbol(%11)] : memref<1xf32, 5>
          %39 = arith.addf %38, %37 : f32
          affine.store %39, %alloca[symbol(%11)] : memref<1xf32, 5>
        }
        nvvm.barrier0
      }
      scf.if %18 {
        %32 = affine.load %alloca[0] : memref<1xf32, 5>
        %33 = arith.sitofp %arg3 : i32 to f32
        %34 = arith.divf %32, %33 : f32
        %35 = arith.addf %34, %arg6 : f32
        %36 = math.sqrt %35 : f32
        affine.store %36, %alloca[0] : memref<1xf32, 5>
      }
      nvvm.barrier0
      %30 = affine.load %alloca[0] : memref<1xf32, 5>
      %31 = arith.divf %24, %30 : f32
      affine.store %31, %arg1[symbol(%17) + symbol(%5)] : memref<?xf32>
    }
    return
  }
}
[ict-debug] driver.cc: After return 6, module: end

WrapAndReplaceBarrierPass::runOnOperation(): before execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c32 = arith.constant 32 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c2_i32 = arith.constant 2 : i32
    %c0_i32 = arith.constant 0 : i32
    %true = arith.constant true
    %0 = arith.index_cast %arg5 : i32 to index
    %alloca = memref.alloca() : memref<1xf32, 5>
    %1 = gpu.block_id  x
    %2 = arith.remsi %1, %0 : index
    %3 = arith.addi %2, %0 : index
    %4 = arith.cmpi slt, %2, %c0 : index
    %5 = arith.select %4, %3, %2 : index
    %6 = arith.index_cast %1 : index to i32
    %7 = arith.divsi %6, %arg5 : i32
    %8 = arith.remsi %7, %arg4 : i32
    %9 = arith.divsi %7, %arg4 : i32
    %10 = arith.muli %9, %arg3 : i32
    %11 = gpu.thread_id  x
    %12 = arith.index_cast %11 : index to i32
    %13 = arith.addi %10, %12 : i32
    %14 = arith.muli %13, %arg4 : i32
    %15 = arith.addi %14, %8 : i32
    %16 = arith.muli %15, %arg5 : i32
    %17 = arith.index_cast %16 : i32 to index
    %18 = arith.cmpi eq, %12, %c0_i32 : i32
    %19 = arith.muli %arg2, %arg4 : i32
    %20 = arith.muli %19, %arg5 : i32
    %21 = arith.cmpi sge, %6, %20 : i32
    %22 = scf.if %21 -> (i1) {
      scf.yield %true : i1
    } else {
      %24 = arith.cmpi sge, %12, %arg3 : i32
      scf.yield %24 : i1
    }
    %23 = arith.xori %22, %true : i1
    scf.if %23 {
      %24 = arith.addi %17, %5 : index
      %25 = memref.load %arg0[%24] : memref<?xf32>
      %26 = arith.mulf %25, %25 : f32
      memref.store %26, %alloca[%11] : memref<1xf32, 5>
      nvvm.barrier0
      %27 = arith.divsi %arg3, %c2_i32 : i32
      %28 = math.ctlz %27 : i32
      %29 = arith.index_cast %28 : i32 to index
      %30 = arith.subi %c32, %29 : index
      scf.for %arg7 = %c0 to %30 step %c1 {
        %33 = arith.index_cast %arg7 : index to i32
        %34 = arith.shrui %27, %33 : i32
        %35 = arith.cmpi ult, %12, %34 : i32
        scf.if %35 {
          %36 = arith.addi %12, %34 : i32
          %37 = arith.index_cast %36 : i32 to index
          %38 = memref.load %alloca[%37] : memref<1xf32, 5>
          %39 = memref.load %alloca[%11] : memref<1xf32, 5>
          %40 = arith.addf %39, %38 : f32
          memref.store %40, %alloca[%11] : memref<1xf32, 5>
        }
        nvvm.barrier0
      }
      scf.if %18 {
        %33 = memref.load %alloca[%c0] : memref<1xf32, 5>
        %34 = arith.sitofp %arg3 : i32 to f32
        %35 = arith.divf %33, %34 : f32
        %36 = arith.addf %35, %arg6 : f32
        %37 = math.sqrt %36 : f32
        memref.store %37, %alloca[%c0] : memref<1xf32, 5>
      }
      nvvm.barrier0
      %31 = memref.load %alloca[%c0] : memref<1xf32, 5>
      %32 = arith.divf %25, %31 : f32
      memref.store %32, %arg1[%24] : memref<?xf32>
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): before execute: end
WrapAndReplaceBarrierPass::runOnOperation(): after execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    scf.parallel (%arg7) = (%c0) to (%c32) step (%c1) {
      %c32_0 = arith.constant 32 : index
      %c0_1 = arith.constant 0 : index
      %c1_2 = arith.constant 1 : index
      %c2_i32 = arith.constant 2 : i32
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %0 = arith.index_cast %arg5 : i32 to index
      %1 = gpu.block_id  x
      %2 = arith.remsi %1, %0 : index
      %3 = arith.addi %2, %0 : index
      %4 = arith.cmpi slt, %2, %c0_1 : index
      %5 = arith.select %4, %3, %2 : index
      %6 = arith.index_cast %1 : index to i32
      %7 = arith.divsi %6, %arg5 : i32
      %8 = arith.remsi %7, %arg4 : i32
      %9 = arith.divsi %7, %arg4 : i32
      %10 = arith.muli %9, %arg3 : i32
      %11 = arith.index_cast %arg7 : index to i32
      %12 = arith.addi %10, %11 : i32
      %13 = arith.muli %12, %arg4 : i32
      %14 = arith.addi %13, %8 : i32
      %15 = arith.muli %14, %arg5 : i32
      %16 = arith.index_cast %15 : i32 to index
      %17 = arith.cmpi eq, %11, %c0_i32 : i32
      %18 = arith.muli %arg2, %arg4 : i32
      %19 = arith.muli %18, %arg5 : i32
      %20 = arith.cmpi sge, %6, %19 : i32
      %21 = scf.if %20 -> (i1) {
        scf.yield %true : i1
      } else {
        %23 = arith.cmpi sge, %11, %arg3 : i32
        scf.yield %23 : i1
      }
      %22 = arith.xori %21, %true : i1
      scf.if %22 {
        %23 = arith.addi %16, %5 : index
        %24 = memref.load %arg0[%23] : memref<?xf32>
        %25 = arith.mulf %24, %24 : f32
        memref.store %25, %alloca[%arg7] : memref<1xf32, 5>
        "polygeist.barrier"(%arg7) : (index) -> ()
        %26 = arith.divsi %arg3, %c2_i32 : i32
        %27 = math.ctlz %26 : i32
        %28 = arith.index_cast %27 : i32 to index
        %29 = arith.subi %c32_0, %28 : index
        scf.for %arg8 = %c0_1 to %29 step %c1_2 {
          %32 = arith.index_cast %arg8 : index to i32
          %33 = arith.shrui %26, %32 : i32
          %34 = arith.cmpi ult, %11, %33 : i32
          scf.if %34 {
            %35 = arith.addi %11, %33 : i32
            %36 = arith.index_cast %35 : i32 to index
            %37 = memref.load %alloca[%36] : memref<1xf32, 5>
            %38 = memref.load %alloca[%arg7] : memref<1xf32, 5>
            %39 = arith.addf %38, %37 : f32
            memref.store %39, %alloca[%arg7] : memref<1xf32, 5>
          }
          "polygeist.barrier"(%arg7) : (index) -> ()
        }
        scf.if %17 {
          %32 = memref.load %alloca[%c0_1] : memref<1xf32, 5>
          %33 = arith.sitofp %arg3 : i32 to f32
          %34 = arith.divf %32, %33 : f32
          %35 = arith.addf %34, %arg6 : f32
          %36 = math.sqrt %35 : f32
          memref.store %36, %alloca[%c0_1] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg7) : (index) -> ()
        %30 = memref.load %alloca[%c0_1] : memref<1xf32, 5>
        %31 = arith.divf %24, %30 : f32
        memref.store %31, %arg1[%23] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): after execute: end
[ict-debug] driver.cc: After return 7, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    scf.parallel (%arg7) = (%c0) to (%c32) step (%c1) {
      %c32_0 = arith.constant 32 : index
      %c0_1 = arith.constant 0 : index
      %c1_2 = arith.constant 1 : index
      %c2_i32 = arith.constant 2 : i32
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %0 = arith.index_cast %arg5 : i32 to index
      %1 = gpu.block_id  x
      %2 = arith.remsi %1, %0 : index
      %3 = arith.addi %2, %0 : index
      %4 = arith.cmpi slt, %2, %c0_1 : index
      %5 = arith.select %4, %3, %2 : index
      %6 = arith.index_cast %1 : index to i32
      %7 = arith.divsi %6, %arg5 : i32
      %8 = arith.remsi %7, %arg4 : i32
      %9 = arith.divsi %7, %arg4 : i32
      %10 = arith.muli %9, %arg3 : i32
      %11 = arith.index_cast %arg7 : index to i32
      %12 = arith.addi %10, %11 : i32
      %13 = arith.muli %12, %arg4 : i32
      %14 = arith.addi %13, %8 : i32
      %15 = arith.muli %14, %arg5 : i32
      %16 = arith.index_cast %15 : i32 to index
      %17 = arith.cmpi eq, %11, %c0_i32 : i32
      %18 = arith.muli %arg2, %arg4 : i32
      %19 = arith.muli %18, %arg5 : i32
      %20 = arith.cmpi sge, %6, %19 : i32
      %21 = scf.if %20 -> (i1) {
        scf.yield %true : i1
      } else {
        %23 = arith.cmpi sge, %11, %arg3 : i32
        scf.yield %23 : i1
      }
      %22 = arith.xori %21, %true : i1
      scf.if %22 {
        %23 = arith.addi %16, %5 : index
        %24 = memref.load %arg0[%23] : memref<?xf32>
        %25 = arith.mulf %24, %24 : f32
        memref.store %25, %alloca[%arg7] : memref<1xf32, 5>
        "polygeist.barrier"(%arg7) : (index) -> ()
        %26 = arith.divsi %arg3, %c2_i32 : i32
        %27 = math.ctlz %26 : i32
        %28 = arith.index_cast %27 : i32 to index
        %29 = arith.subi %c32_0, %28 : index
        scf.for %arg8 = %c0_1 to %29 step %c1_2 {
          %32 = arith.index_cast %arg8 : index to i32
          %33 = arith.shrui %26, %32 : i32
          %34 = arith.cmpi ult, %11, %33 : i32
          scf.if %34 {
            %35 = arith.addi %11, %33 : i32
            %36 = arith.index_cast %35 : i32 to index
            %37 = memref.load %alloca[%36] : memref<1xf32, 5>
            %38 = memref.load %alloca[%arg7] : memref<1xf32, 5>
            %39 = arith.addf %38, %37 : f32
            memref.store %39, %alloca[%arg7] : memref<1xf32, 5>
          }
          "polygeist.barrier"(%arg7) : (index) -> ()
        }
        scf.if %17 {
          %32 = memref.load %alloca[%c0_1] : memref<1xf32, 5>
          %33 = arith.sitofp %arg3 : i32 to f32
          %34 = arith.divf %32, %33 : f32
          %35 = arith.addf %34, %arg6 : f32
          %36 = math.sqrt %35 : f32
          memref.store %36, %alloca[%c0_1] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg7) : (index) -> ()
        %30 = memref.load %alloca[%c0_1] : memref<1xf32, 5>
        %31 = arith.divf %24, %30 : f32
        memref.store %31, %arg1[%23] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
}
[ict-debug] driver.cc: After return 7, module: end

[ict-debug] driver.cc: Before my pass process:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0_i32 = arith.constant 0 : i32
    %true = arith.constant true
    %c2_i32 = arith.constant 2 : i32
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.muli %arg2, %arg4 : i32
    %3 = arith.muli %2, %arg5 : i32
    %4 = arith.cmpi sge, %1, %3 : i32
    %5 = scf.if %4 -> (i1) {
      scf.yield %true : i1
    } else {
      %6 = arith.cmpi sle, %arg3, %c0_i32 : i32
      scf.yield %6 : i1
    }
    scf.if %5 {
    } else {
      %alloca_0 = memref.alloca() : memref<32xf32>
      %6 = arith.index_cast %arg5 : i32 to index
      %7 = arith.remsi %0, %6 : index
      %8 = arith.addi %7, %6 : index
      %9 = arith.cmpi slt, %7, %c0 : index
      %10 = arith.select %9, %8, %7 : index
      %11 = arith.divsi %1, %arg5 : i32
      %12 = arith.remsi %11, %arg4 : i32
      %13 = arith.divsi %11, %arg4 : i32
      %14 = arith.muli %13, %arg3 : i32
      scf.parallel (%arg7) = (%c0) to (%c32) step (%c1) {
        %43 = arith.index_cast %arg7 : index to i32
        %44 = arith.addi %14, %43 : i32
        %45 = arith.muli %44, %arg4 : i32
        %46 = arith.addi %45, %12 : i32
        %47 = arith.muli %46, %arg5 : i32
        %48 = arith.index_cast %47 : i32 to index
        %49 = arith.addi %48, %10 : index
        %50 = memref.load %arg0[%49] : memref<?xf32>
        %51 = arith.mulf %50, %50 : f32
        memref.store %51, %alloca[%arg7] : memref<1xf32, 5>
        scf.yield
      }
      %15 = arith.divsi %arg3, %c2_i32 : i32
      %16 = math.ctlz %15 : i32
      %17 = arith.index_cast %16 : i32 to index
      %18 = arith.subi %c32, %17 : index
      scf.for %arg7 = %c0 to %18 step %c1 {
        %43 = arith.index_cast %arg7 : index to i32
        %44 = arith.shrui %15, %43 : i32
        scf.parallel (%arg8) = (%c0) to (%c32) step (%c1) {
          %45 = arith.index_cast %arg8 : index to i32
          %46 = arith.cmpi ult, %45, %44 : i32
          scf.if %46 {
            %47 = arith.addi %45, %44 : i32
            %48 = arith.index_cast %47 : i32 to index
            %49 = memref.load %alloca[%48] : memref<1xf32, 5>
            %50 = memref.load %alloca[%arg8] : memref<1xf32, 5>
            %51 = arith.addf %50, %49 : f32
            memref.store %51, %alloca[%arg8] : memref<1xf32, 5>
          }
          scf.yield
        }
      }
      %19 = arith.index_cast %arg5 : i32 to index
      %20 = arith.remsi %0, %19 : index
      %21 = arith.cmpi slt, %20, %c0 : index
      %22 = arith.addi %20, %19 : index
      %23 = arith.select %21, %22, %20 : index
      %24 = arith.divsi %1, %arg5 : i32
      %25 = arith.divsi %24, %arg4 : i32
      %26 = arith.muli %25, %arg3 : i32
      %27 = arith.remsi %24, %arg4 : i32
      %28 = memref.load %alloca[%c0] : memref<1xf32, 5>
      %29 = arith.sitofp %arg3 : i32 to f32
      %30 = arith.divf %28, %29 : f32
      %31 = arith.addf %30, %arg6 : f32
      %32 = math.sqrt %31 : f32
      scf.parallel (%arg7) = (%c0) to (%c32) step (%c1) {
        %43 = arith.index_cast %arg7 : index to i32
        %44 = arith.cmpi eq, %43, %c0_i32 : i32
        %45 = arith.addi %26, %43 : i32
        %46 = arith.muli %45, %arg4 : i32
        %47 = arith.addi %46, %27 : i32
        %48 = arith.muli %47, %arg5 : i32
        %49 = arith.index_cast %48 : i32 to index
        %50 = arith.addi %49, %23 : index
        %51 = memref.load %arg0[%50] : memref<?xf32>
        memref.store %51, %alloca_0[%arg7] : memref<32xf32>
        scf.if %44 {
          memref.store %32, %alloca[%c0] : memref<1xf32, 5>
        }
        scf.yield
      }
      %33 = arith.index_cast %arg5 : i32 to index
      %34 = arith.remsi %0, %33 : index
      %35 = arith.cmpi slt, %34, %c0 : index
      %36 = arith.addi %34, %33 : index
      %37 = arith.select %35, %36, %34 : index
      %38 = arith.divsi %1, %arg5 : i32
      %39 = arith.divsi %38, %arg4 : i32
      %40 = arith.muli %39, %arg3 : i32
      %41 = arith.remsi %38, %arg4 : i32
      %42 = memref.load %alloca[%c0] : memref<1xf32, 5>
      scf.parallel (%arg7) = (%c0) to (%c32) step (%c1) {
        %43 = memref.load %alloca_0[%arg7] : memref<32xf32>
        %44 = arith.index_cast %arg7 : index to i32
        %45 = arith.addi %40, %44 : i32
        %46 = arith.muli %45, %arg4 : i32
        %47 = arith.addi %46, %41 : i32
        %48 = arith.muli %47, %arg5 : i32
        %49 = arith.index_cast %48 : i32 to index
        %50 = arith.addi %49, %37 : index
        %51 = arith.divf %43, %42 : f32
        memref.store %51, %arg1[%50] : memref<?xf32>
        scf.yield
      }
    }
    return
  }
}
[ict-debug] driver.cc: Before my pass process: end

[ict-debug] driver.cc: vectorizeSize = 1

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z15rms_norm_kernelPKfPfiiiif_0 {
    gpu.func @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) {
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %c2_i32 = arith.constant 2 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %alloca = memref.alloca() : memref<1xf32, 5>
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.muli %arg2, %arg4 : i32
      %3 = arith.muli %2, %arg5 : i32
      %4 = arith.cmpi sge, %1, %3 : i32
      %5 = scf.if %4 -> (i1) {
        scf.yield %true : i1
      } else {
        %6 = arith.cmpi sle, %arg3, %c0_i32 : i32
        scf.yield %6 : i1
      }
      scf.if %5 {
      } else {
        %alloca_0 = memref.alloca() : memref<32xf32>
        %6 = arith.index_cast %arg5 : i32 to index
        %7 = arith.remsi %0, %6 : index
        %8 = arith.addi %7, %6 : index
        %9 = arith.cmpi slt, %7, %c0 : index
        %10 = arith.select %9, %8, %7 : index
        %11 = arith.divsi %1, %arg5 : i32
        %12 = arith.remsi %11, %arg4 : i32
        %13 = arith.divsi %11, %arg4 : i32
        %14 = arith.muli %13, %arg3 : i32
        scf.parallel (%arg7) = (%c0) to (%c32) step (%c1) {
          %25 = arith.index_cast %arg7 : index to i32
          %26 = arith.addi %14, %25 : i32
          %27 = arith.muli %26, %arg4 : i32
          %28 = arith.addi %27, %12 : i32
          %29 = arith.muli %28, %arg5 : i32
          %30 = arith.index_cast %29 : i32 to index
          %31 = arith.addi %30, %10 : index
          %32 = memref.load %arg0[%31] : memref<?xf32>
          %33 = arith.mulf %32, %32 : f32
          memref.store %33, %alloca[%arg7] : memref<1xf32, 5>
          scf.yield
        }
        %15 = arith.divsi %arg3, %c2_i32 : i32
        %16 = math.ctlz %15 : i32
        %17 = arith.index_cast %16 : i32 to index
        %18 = arith.subi %c32, %17 : index
        scf.for %arg7 = %c0 to %18 step %c1 {
          %25 = arith.index_cast %arg7 : index to i32
          %26 = arith.shrui %15, %25 : i32
          scf.parallel (%arg8) = (%c0) to (%c32) step (%c1) {
            %27 = arith.index_cast %arg8 : index to i32
            %28 = arith.cmpi ult, %27, %26 : i32
            scf.if %28 {
              %29 = arith.addi %27, %26 : i32
              %30 = arith.index_cast %29 : i32 to index
              %31 = memref.load %alloca[%30] : memref<1xf32, 5>
              %32 = memref.load %alloca[%arg8] : memref<1xf32, 5>
              %33 = arith.addf %32, %31 : f32
              memref.store %33, %alloca[%arg8] : memref<1xf32, 5>
            }
            scf.yield
          }
        }
        %19 = memref.load %alloca[%c0] : memref<1xf32, 5>
        %20 = arith.sitofp %arg3 : i32 to f32
        %21 = arith.divf %19, %20 : f32
        %22 = arith.addf %21, %arg6 : f32
        %23 = math.sqrt %22 : f32
        scf.parallel (%arg7) = (%c0) to (%c32) step (%c1) {
          %25 = arith.index_cast %arg7 : index to i32
          %26 = arith.cmpi eq, %25, %c0_i32 : i32
          %27 = arith.addi %14, %25 : i32
          %28 = arith.muli %27, %arg4 : i32
          %29 = arith.addi %28, %12 : i32
          %30 = arith.muli %29, %arg5 : i32
          %31 = arith.index_cast %30 : i32 to index
          %32 = arith.addi %31, %10 : index
          %33 = memref.load %arg0[%32] : memref<?xf32>
          memref.store %33, %alloca_0[%arg7] : memref<32xf32>
          scf.if %26 {
            memref.store %23, %alloca[%c0] : memref<1xf32, 5>
          }
          scf.yield
        }
        %24 = memref.load %alloca[%c0] : memref<1xf32, 5>
        scf.parallel (%arg7) = (%c0) to (%c32) step (%c1) {
          %25 = memref.load %alloca_0[%arg7] : memref<32xf32>
          %26 = arith.index_cast %arg7 : index to i32
          %27 = arith.addi %14, %26 : i32
          %28 = arith.muli %27, %arg4 : i32
          %29 = arith.addi %28, %12 : i32
          %30 = arith.muli %29, %arg5 : i32
          %31 = arith.index_cast %30 : i32 to index
          %32 = arith.addi %31, %10 : index
          %33 = arith.divf %25, %24 : f32
          memref.store %33, %arg1[%32] : memref<?xf32>
          scf.yield
        }
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute: end

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z15rms_norm_kernelPKfPfiiiif_0 {
    gpu.func @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) {
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %c2_i32 = arith.constant 2 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %alloca = memref.alloca() : memref<1xf32, 5>
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.muli %arg2, %arg4 : i32
      %3 = arith.muli %2, %arg5 : i32
      %4 = arith.cmpi sge, %1, %3 : i32
      %5 = scf.if %4 -> (i1) {
        scf.yield %true : i1
      } else {
        %6 = arith.cmpi sle, %arg3, %c0_i32 : i32
        scf.yield %6 : i1
      }
      scf.if %5 {
      } else {
        %alloca_0 = memref.alloca() : memref<32xf32>
        %6 = arith.index_cast %arg5 : i32 to index
        %7 = arith.remsi %0, %6 : index
        %8 = arith.addi %7, %6 : index
        %9 = arith.cmpi slt, %7, %c0 : index
        %10 = arith.select %9, %8, %7 : index
        %11 = arith.divsi %1, %arg5 : i32
        %12 = arith.remsi %11, %arg4 : i32
        %13 = arith.divsi %11, %arg4 : i32
        %14 = arith.muli %13, %arg3 : i32
        %c1_1 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_1 {
          %25 = arith.index_cast %arg7 : index to i32
          %26 = arith.addi %14, %25 : i32
          %27 = arith.muli %26, %arg4 : i32
          %28 = arith.addi %27, %12 : i32
          %29 = arith.muli %28, %arg5 : i32
          %30 = arith.index_cast %29 : i32 to index
          %31 = arith.addi %30, %10 : index
          %32 = memref.load %arg0[%31] : memref<?xf32>
          %33 = arith.mulf %32, %32 : f32
          memref.store %33, %alloca[%arg7] : memref<1xf32, 5>
        }
        %15 = arith.divsi %arg3, %c2_i32 : i32
        %16 = math.ctlz %15 : i32
        %17 = arith.index_cast %16 : i32 to index
        %18 = arith.subi %c32, %17 : index
        scf.for %arg7 = %c0 to %18 step %c1 {
          %25 = arith.index_cast %arg7 : index to i32
          %26 = arith.shrui %15, %25 : i32
          %c1_4 = arith.constant 1 : index
          scf.for %arg8 = %c0 to %c32 step %c1_4 {
            %27 = arith.index_cast %arg8 : index to i32
            %28 = arith.cmpi ult, %27, %26 : i32
            scf.if %28 {
              %29 = arith.addi %27, %26 : i32
              %30 = arith.index_cast %29 : i32 to index
              %31 = memref.load %alloca[%30] : memref<1xf32, 5>
              %32 = memref.load %alloca[%arg8] : memref<1xf32, 5>
              %33 = arith.addf %32, %31 : f32
              memref.store %33, %alloca[%arg8] : memref<1xf32, 5>
            }
          }
        }
        %19 = memref.load %alloca[%c0] : memref<1xf32, 5>
        %20 = arith.sitofp %arg3 : i32 to f32
        %21 = arith.divf %19, %20 : f32
        %22 = arith.addf %21, %arg6 : f32
        %23 = math.sqrt %22 : f32
        %c1_2 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_2 {
          %25 = arith.index_cast %arg7 : index to i32
          %26 = arith.cmpi eq, %25, %c0_i32 : i32
          %27 = arith.addi %14, %25 : i32
          %28 = arith.muli %27, %arg4 : i32
          %29 = arith.addi %28, %12 : i32
          %30 = arith.muli %29, %arg5 : i32
          %31 = arith.index_cast %30 : i32 to index
          %32 = arith.addi %31, %10 : index
          %33 = memref.load %arg0[%32] : memref<?xf32>
          memref.store %33, %alloca_0[%arg7] : memref<32xf32>
          scf.if %26 {
            memref.store %23, %alloca[%c0] : memref<1xf32, 5>
          }
        }
        %24 = memref.load %alloca[%c0] : memref<1xf32, 5>
        %c1_3 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_3 {
          %25 = memref.load %alloca_0[%arg7] : memref<32xf32>
          %26 = arith.index_cast %arg7 : index to i32
          %27 = arith.addi %14, %26 : i32
          %28 = arith.muli %27, %arg4 : i32
          %29 = arith.addi %28, %12 : i32
          %30 = arith.muli %29, %arg5 : i32
          %31 = arith.index_cast %30 : i32 to index
          %32 = arith.addi %31, %10 : index
          %33 = arith.divf %25, %24 : f32
          memref.store %33, %arg1[%32] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize: end

[ict-debug] MemRefAllocaToNPULowering: process op: 

%alloca = memref.alloca() : memref<1xf32, 5>
[ict-debug] MemRefAllocaToNPULowering: memory space is 5

MemRefAllocaToNPULowering: newAllocaOp: 
%0 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
MemRefAllocaToNPULowering: old allocaOp: 
%alloca = memref.alloca() : memref<1xf32, 5>
MemRefAllocaToNPULowering: module: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z15rms_norm_kernelPKfPfiiiif_0 {
    gpu.func @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) {
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %c2_i32 = arith.constant 2 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %alloca = memref.alloca() : memref<1xf32, 5>
      %1 = gpu.block_id  x
      %2 = arith.index_cast %1 : index to i32
      %3 = arith.muli %arg2, %arg4 : i32
      %4 = arith.muli %3, %arg5 : i32
      %5 = arith.cmpi sge, %2, %4 : i32
      %6 = scf.if %5 -> (i1) {
        scf.yield %true : i1
      } else {
        %7 = arith.cmpi sle, %arg3, %c0_i32 : i32
        scf.yield %7 : i1
      }
      scf.if %6 {
      } else {
        %alloca_0 = memref.alloca() : memref<32xf32, 5>
        %7 = arith.index_cast %arg5 : i32 to index
        %8 = arith.remsi %1, %7 : index
        %9 = arith.addi %8, %7 : index
        %10 = arith.cmpi slt, %8, %c0 : index
        %11 = arith.select %10, %9, %8 : index
        %12 = arith.divsi %2, %arg5 : i32
        %13 = arith.remsi %12, %arg4 : i32
        %14 = arith.divsi %12, %arg4 : i32
        %15 = arith.muli %14, %arg3 : i32
        %c1_1 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_1 {
          %26 = arith.index_cast %arg7 : index to i32
          %27 = arith.addi %15, %26 : i32
          %28 = arith.muli %27, %arg4 : i32
          %29 = arith.addi %28, %13 : i32
          %30 = arith.muli %29, %arg5 : i32
          %31 = arith.index_cast %30 : i32 to index
          %32 = arith.addi %31, %11 : index
          %33 = memref.load %arg0[%32] : memref<?xf32>
          %34 = arith.mulf %33, %33 : f32
          memref.store %34, %alloca[%arg7] : memref<1xf32, 5>
        }
        %16 = arith.divsi %arg3, %c2_i32 : i32
        %17 = math.ctlz %16 : i32
        %18 = arith.index_cast %17 : i32 to index
        %19 = arith.subi %c32, %18 : index
        scf.for %arg7 = %c0 to %19 step %c1 {
          %26 = arith.index_cast %arg7 : index to i32
          %27 = arith.shrui %16, %26 : i32
          %c1_4 = arith.constant 1 : index
          scf.for %arg8 = %c0 to %c32 step %c1_4 {
            %28 = arith.index_cast %arg8 : index to i32
            %29 = arith.cmpi ult, %28, %27 : i32
            scf.if %29 {
              %30 = arith.addi %28, %27 : i32
              %31 = arith.index_cast %30 : i32 to index
              %32 = memref.load %alloca[%31] : memref<1xf32, 5>
              %33 = memref.load %alloca[%arg8] : memref<1xf32, 5>
              %34 = arith.addf %33, %32 : f32
              memref.store %34, %alloca[%arg8] : memref<1xf32, 5>
            }
          }
        }
        %20 = memref.load %alloca[%c0] : memref<1xf32, 5>
        %21 = arith.sitofp %arg3 : i32 to f32
        %22 = arith.divf %20, %21 : f32
        %23 = arith.addf %22, %arg6 : f32
        %24 = math.sqrt %23 : f32
        %c1_2 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_2 {
          %26 = arith.index_cast %arg7 : index to i32
          %27 = arith.cmpi eq, %26, %c0_i32 : i32
          %28 = arith.addi %15, %26 : i32
          %29 = arith.muli %28, %arg4 : i32
          %30 = arith.addi %29, %13 : i32
          %31 = arith.muli %30, %arg5 : i32
          %32 = arith.index_cast %31 : i32 to index
          %33 = arith.addi %32, %11 : index
          %34 = memref.load %arg0[%33] : memref<?xf32>
          memref.store %34, %alloca_0[%arg7] : memref<32xf32, 5>
          scf.if %27 {
            memref.store %24, %alloca[%c0] : memref<1xf32, 5>
          }
        }
        %25 = memref.load %alloca[%c0] : memref<1xf32, 5>
        %c1_3 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_3 {
          %26 = memref.load %alloca_0[%arg7] : memref<32xf32, 5>
          %27 = arith.index_cast %arg7 : index to i32
          %28 = arith.addi %15, %27 : i32
          %29 = arith.muli %28, %arg4 : i32
          %30 = arith.addi %29, %13 : i32
          %31 = arith.muli %30, %arg5 : i32
          %32 = arith.index_cast %31 : i32 to index
          %33 = arith.addi %32, %11 : index
          %34 = arith.divf %26, %25 : f32
          memref.store %34, %arg1[%33] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
MemRefAllocaToNPULowering: module: end
[ict-debug] GPUBlockIdToNPULowering: process op: 

%1 = gpu.block_id  x
[ict-debug] MemRefAllocaToNPULowering: process op: 

%alloca_0 = memref.alloca() : memref<32xf32, 5>
[ict-debug] MemRefAllocaToNPULowering: memory space is 5

MemRefAllocaToNPULowering: newAllocaOp: 
%8 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
MemRefAllocaToNPULowering: old allocaOp: 
%alloca_0 = memref.alloca() : memref<32xf32, 5>
MemRefAllocaToNPULowering: module: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z15rms_norm_kernelPKfPfiiiif_0 {
    gpu.func @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) {
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %c2_i32 = arith.constant 2 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %alloca = memref.alloca() : memref<1xf32, 5>
      %1 = "npu.block_id"() <{dimension = "X"}> : () -> i64
      %2 = gpu.block_id  x
      %3 = arith.index_cast %2 : index to i32
      %4 = arith.muli %arg2, %arg4 : i32
      %5 = arith.muli %4, %arg5 : i32
      %6 = arith.cmpi sge, %3, %5 : i32
      %7 = scf.if %6 -> (i1) {
        scf.yield %true : i1
      } else {
        %8 = arith.cmpi sle, %arg3, %c0_i32 : i32
        scf.yield %8 : i1
      }
      scf.if %7 {
      } else {
        %8 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
        %alloca_0 = memref.alloca() : memref<32xf32, 5>
        %9 = arith.index_cast %arg5 : i32 to index
        %10 = arith.remsi %2, %9 : index
        %11 = arith.addi %10, %9 : index
        %12 = arith.cmpi slt, %10, %c0 : index
        %13 = arith.select %12, %11, %10 : index
        %14 = arith.divsi %3, %arg5 : i32
        %15 = arith.remsi %14, %arg4 : i32
        %16 = arith.divsi %14, %arg4 : i32
        %17 = arith.muli %16, %arg3 : i32
        %c1_1 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_1 {
          %28 = arith.index_cast %arg7 : index to i32
          %29 = arith.addi %17, %28 : i32
          %30 = arith.muli %29, %arg4 : i32
          %31 = arith.addi %30, %15 : i32
          %32 = arith.muli %31, %arg5 : i32
          %33 = arith.index_cast %32 : i32 to index
          %34 = arith.addi %33, %13 : index
          %35 = memref.load %arg0[%34] : memref<?xf32>
          %36 = arith.mulf %35, %35 : f32
          memref.store %36, %alloca[%arg7] : memref<1xf32, 5>
        }
        %18 = arith.divsi %arg3, %c2_i32 : i32
        %19 = math.ctlz %18 : i32
        %20 = arith.index_cast %19 : i32 to index
        %21 = arith.subi %c32, %20 : index
        scf.for %arg7 = %c0 to %21 step %c1 {
          %28 = arith.index_cast %arg7 : index to i32
          %29 = arith.shrui %18, %28 : i32
          %c1_4 = arith.constant 1 : index
          scf.for %arg8 = %c0 to %c32 step %c1_4 {
            %30 = arith.index_cast %arg8 : index to i32
            %31 = arith.cmpi ult, %30, %29 : i32
            scf.if %31 {
              %32 = arith.addi %30, %29 : i32
              %33 = arith.index_cast %32 : i32 to index
              %34 = memref.load %alloca[%33] : memref<1xf32, 5>
              %35 = memref.load %alloca[%arg8] : memref<1xf32, 5>
              %36 = arith.addf %35, %34 : f32
              memref.store %36, %alloca[%arg8] : memref<1xf32, 5>
            }
          }
        }
        %22 = memref.load %alloca[%c0] : memref<1xf32, 5>
        %23 = arith.sitofp %arg3 : i32 to f32
        %24 = arith.divf %22, %23 : f32
        %25 = arith.addf %24, %arg6 : f32
        %26 = math.sqrt %25 : f32
        %c1_2 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_2 {
          %28 = arith.index_cast %arg7 : index to i32
          %29 = arith.cmpi eq, %28, %c0_i32 : i32
          %30 = arith.addi %17, %28 : i32
          %31 = arith.muli %30, %arg4 : i32
          %32 = arith.addi %31, %15 : i32
          %33 = arith.muli %32, %arg5 : i32
          %34 = arith.index_cast %33 : i32 to index
          %35 = arith.addi %34, %13 : index
          %36 = memref.load %arg0[%35] : memref<?xf32>
          memref.store %36, %alloca_0[%arg7] : memref<32xf32, 5>
          scf.if %29 {
            memref.store %26, %alloca[%c0] : memref<1xf32, 5>
          }
        }
        %27 = memref.load %alloca[%c0] : memref<1xf32, 5>
        %c1_3 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_3 {
          %28 = memref.load %alloca_0[%arg7] : memref<32xf32, 5>
          %29 = arith.index_cast %arg7 : index to i32
          %30 = arith.addi %17, %29 : i32
          %31 = arith.muli %30, %arg4 : i32
          %32 = arith.addi %31, %15 : i32
          %33 = arith.muli %32, %arg5 : i32
          %34 = arith.index_cast %33 : i32 to index
          %35 = arith.addi %34, %13 : index
          %36 = arith.divf %28, %27 : f32
          memref.store %36, %arg1[%35] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
MemRefAllocaToNPULowering: module: end
[ict-debug] ArithUnaryOpToNPULowering: process op: 

%28 = math.sqrt %27 : f32
[ict-debug] ArithUnaryOpToNPULowering: met scalar unary op, need vector help process.

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z15rms_norm_kernelPKfPfiiiif_0 {
    gpu.func @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) {
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %c2_i32 = arith.constant 2 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %1 = builtin.unrealized_conversion_cast %0 : !llvm.ptr<6> to memref<1xf32, 5>
      %2 = "npu.block_id"() <{dimension = "X"}> : () -> i64
      %3 = arith.index_cast %2 : i64 to index
      %4 = builtin.unrealized_conversion_cast %2 : i64 to index
      %5 = arith.index_cast %3 : index to i32
      %6 = arith.muli %arg2, %arg4 : i32
      %7 = arith.muli %6, %arg5 : i32
      %8 = arith.cmpi sge, %5, %7 : i32
      %9 = scf.if %8 -> (i1) {
        scf.yield %true : i1
      } else {
        %10 = arith.cmpi sle, %arg3, %c0_i32 : i32
        scf.yield %10 : i1
      }
      scf.if %9 {
      } else {
        %10 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
        %11 = builtin.unrealized_conversion_cast %10 : !llvm.ptr<6> to memref<32xf32, 5>
        %12 = arith.index_cast %arg5 : i32 to index
        %13 = arith.remsi %3, %12 : index
        %14 = arith.addi %13, %12 : index
        %15 = arith.cmpi slt, %13, %c0 : index
        %16 = arith.select %15, %14, %13 : index
        %17 = arith.divsi %5, %arg5 : i32
        %18 = arith.remsi %17, %arg4 : i32
        %19 = arith.divsi %17, %arg4 : i32
        %20 = arith.muli %19, %arg3 : i32
        %c1_0 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_0 {
          %31 = arith.index_cast %arg7 : index to i32
          %32 = arith.addi %20, %31 : i32
          %33 = arith.muli %32, %arg4 : i32
          %34 = arith.addi %33, %18 : i32
          %35 = arith.muli %34, %arg5 : i32
          %36 = arith.index_cast %35 : i32 to index
          %37 = arith.addi %36, %16 : index
          %38 = memref.load %arg0[%37] : memref<?xf32>
          %39 = emitc.mul %38, %38 : (f32, f32) -> f32
          memref.store %39, %1[%arg7] : memref<1xf32, 5>
        }
        %21 = arith.divsi %arg3, %c2_i32 : i32
        %22 = math.ctlz %21 : i32
        %23 = arith.index_cast %22 : i32 to index
        %24 = arith.subi %c32, %23 : index
        scf.for %arg7 = %c0 to %24 step %c1 {
          %31 = arith.index_cast %arg7 : index to i32
          %32 = arith.shrui %21, %31 : i32
          %c1_3 = arith.constant 1 : index
          scf.for %arg8 = %c0 to %c32 step %c1_3 {
            %33 = arith.index_cast %arg8 : index to i32
            %34 = arith.cmpi ult, %33, %32 : i32
            scf.if %34 {
              %35 = arith.addi %33, %32 : i32
              %36 = arith.index_cast %35 : i32 to index
              %37 = memref.load %1[%36] : memref<1xf32, 5>
              %38 = memref.load %1[%arg8] : memref<1xf32, 5>
              %39 = emitc.add %38, %37 : (f32, f32) -> f32
              memref.store %39, %1[%arg8] : memref<1xf32, 5>
            }
          }
        }
        %25 = memref.load %1[%c0] : memref<1xf32, 5>
        %26 = arith.sitofp %arg3 : i32 to f32
        %27 = emitc.div %25, %26 : (f32, f32) -> f32
        %28 = emitc.add %27, %arg6 : (f32, f32) -> f32
        %29 = emitc.call "sqrtf"(%28) : (f32) -> f32
        %c1_1 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_1 {
          %31 = arith.index_cast %arg7 : index to i32
          %32 = arith.cmpi eq, %31, %c0_i32 : i32
          %33 = arith.addi %20, %31 : i32
          %34 = arith.muli %33, %arg4 : i32
          %35 = arith.addi %34, %18 : i32
          %36 = arith.muli %35, %arg5 : i32
          %37 = arith.index_cast %36 : i32 to index
          %38 = arith.addi %37, %16 : index
          %39 = memref.load %arg0[%38] : memref<?xf32>
          memref.store %39, %11[%arg7] : memref<32xf32, 5>
          scf.if %32 {
            memref.store %29, %1[%c0] : memref<1xf32, 5>
          }
        }
        %30 = memref.load %1[%c0] : memref<1xf32, 5>
        %c1_2 = arith.constant 1 : index
        scf.for %arg7 = %c0 to %c32 step %c1_2 {
          %31 = memref.load %11[%arg7] : memref<32xf32, 5>
          %32 = arith.index_cast %arg7 : index to i32
          %33 = arith.addi %20, %32 : i32
          %34 = arith.muli %33, %arg4 : i32
          %35 = arith.addi %34, %18 : i32
          %36 = arith.muli %35, %arg5 : i32
          %37 = arith.index_cast %36 : i32 to index
          %38 = arith.addi %37, %16 : index
          %39 = emitc.div %31, %30 : (f32, f32) -> f32
          memref.store %39, %arg1[%38] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU: end

[ict-debug] driver.cc: Before convert to EmitC dialect:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z15rms_norm_kernelPKfPfiiiif_0 {
    gpu.func @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) {
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %c2_i32 = arith.constant 2 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %1 = builtin.unrealized_conversion_cast %0 : !llvm.ptr<6> to memref<1xf32, 5>
      %2 = "npu.block_id"() <{dimension = "X"}> : () -> i64
      %3 = arith.index_cast %2 : i64 to index
      %4 = arith.index_cast %3 : index to i32
      %5 = arith.muli %arg2, %arg4 : i32
      %6 = arith.muli %5, %arg5 : i32
      %7 = arith.cmpi sge, %4, %6 : i32
      %8 = scf.if %7 -> (i1) {
        scf.yield %true : i1
      } else {
        %9 = arith.cmpi sle, %arg3, %c0_i32 : i32
        scf.yield %9 : i1
      }
      scf.if %8 {
      } else {
        %9 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
        %10 = builtin.unrealized_conversion_cast %9 : !llvm.ptr<6> to memref<32xf32, 5>
        %11 = arith.index_cast %arg5 : i32 to index
        %12 = arith.remsi %3, %11 : index
        %13 = arith.addi %12, %11 : index
        %14 = arith.cmpi slt, %12, %c0 : index
        %15 = arith.select %14, %13, %12 : index
        %16 = arith.divsi %4, %arg5 : i32
        %17 = arith.remsi %16, %arg4 : i32
        %18 = arith.divsi %16, %arg4 : i32
        %19 = arith.muli %18, %arg3 : i32
        scf.for %arg7 = %c0 to %c32 step %c1 {
          %30 = arith.index_cast %arg7 : index to i32
          %31 = arith.addi %19, %30 : i32
          %32 = arith.muli %31, %arg4 : i32
          %33 = arith.addi %32, %17 : i32
          %34 = arith.muli %33, %arg5 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.addi %35, %15 : index
          %37 = memref.load %arg0[%36] : memref<?xf32>
          %38 = emitc.mul %37, %37 : (f32, f32) -> f32
          memref.store %38, %1[%arg7] : memref<1xf32, 5>
        }
        %20 = arith.divsi %arg3, %c2_i32 : i32
        %21 = math.ctlz %20 : i32
        %22 = arith.index_cast %21 : i32 to index
        %23 = arith.subi %c32, %22 : index
        scf.for %arg7 = %c0 to %23 step %c1 {
          %30 = arith.index_cast %arg7 : index to i32
          %31 = arith.shrui %20, %30 : i32
          scf.for %arg8 = %c0 to %c32 step %c1 {
            %32 = arith.index_cast %arg8 : index to i32
            %33 = arith.cmpi ult, %32, %31 : i32
            scf.if %33 {
              %34 = arith.addi %32, %31 : i32
              %35 = arith.index_cast %34 : i32 to index
              %36 = memref.load %1[%35] : memref<1xf32, 5>
              %37 = memref.load %1[%arg8] : memref<1xf32, 5>
              %38 = emitc.add %37, %36 : (f32, f32) -> f32
              memref.store %38, %1[%arg8] : memref<1xf32, 5>
            }
          }
        }
        %24 = memref.load %1[%c0] : memref<1xf32, 5>
        %25 = arith.sitofp %arg3 : i32 to f32
        %26 = emitc.div %24, %25 : (f32, f32) -> f32
        %27 = emitc.add %26, %arg6 : (f32, f32) -> f32
        %28 = emitc.call "sqrtf"(%27) : (f32) -> f32
        scf.for %arg7 = %c0 to %c32 step %c1 {
          %30 = arith.index_cast %arg7 : index to i32
          %31 = arith.cmpi eq, %30, %c0_i32 : i32
          %32 = arith.addi %19, %30 : i32
          %33 = arith.muli %32, %arg4 : i32
          %34 = arith.addi %33, %17 : i32
          %35 = arith.muli %34, %arg5 : i32
          %36 = arith.index_cast %35 : i32 to index
          %37 = arith.addi %36, %15 : index
          %38 = memref.load %arg0[%37] : memref<?xf32>
          memref.store %38, %10[%arg7] : memref<32xf32, 5>
          scf.if %31 {
            memref.store %28, %1[%c0] : memref<1xf32, 5>
          }
        }
        %29 = memref.load %1[%c0] : memref<1xf32, 5>
        scf.for %arg7 = %c0 to %c32 step %c1 {
          %30 = memref.load %10[%arg7] : memref<32xf32, 5>
          %31 = arith.index_cast %arg7 : index to i32
          %32 = arith.addi %19, %31 : i32
          %33 = arith.muli %32, %arg4 : i32
          %34 = arith.addi %33, %17 : i32
          %35 = arith.muli %34, %arg5 : i32
          %36 = arith.index_cast %35 : i32 to index
          %37 = arith.addi %36, %15 : index
          %38 = emitc.div %30, %29 : (f32, f32) -> f32
          memref.store %38, %arg1[%37] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: Before convert to EmitC dialect: end

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z15rms_norm_kernelPKfPfiiiif_0 {
    gpu.func @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) {
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %c2_i32 = arith.constant 2 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %1 = builtin.unrealized_conversion_cast %0 : !llvm.ptr<6> to memref<1xf32, 5>
      %2 = "npu.block_id"() <{dimension = "X"}> : () -> i64
      %3 = arith.index_cast %2 : i64 to index
      %4 = arith.index_cast %3 : index to i32
      %5 = arith.muli %arg2, %arg4 : i32
      %6 = arith.muli %5, %arg5 : i32
      %7 = arith.cmpi sge, %4, %6 : i32
      %8 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> i1
      emitc.if %7 {
        emitc.assign %true : i1 to %8 : i1
      } else {
        %9 = arith.cmpi sle, %arg3, %c0_i32 : i32
        emitc.assign %9 : i1 to %8 : i1
      }
      emitc.if %8 {
      } else {
        %9 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
        %10 = builtin.unrealized_conversion_cast %9 : !llvm.ptr<6> to memref<32xf32, 5>
        %11 = arith.index_cast %arg5 : i32 to index
        %12 = arith.remsi %3, %11 : index
        %13 = arith.addi %12, %11 : index
        %14 = arith.cmpi slt, %12, %c0 : index
        %15 = arith.select %14, %13, %12 : index
        %16 = arith.divsi %4, %arg5 : i32
        %17 = arith.remsi %16, %arg4 : i32
        %18 = arith.divsi %16, %arg4 : i32
        %19 = arith.muli %18, %arg3 : i32
        scf.for %arg7 = %c0 to %c32 step %c1 {
          %30 = arith.index_cast %arg7 : index to i32
          %31 = arith.addi %19, %30 : i32
          %32 = arith.muli %31, %arg4 : i32
          %33 = arith.addi %32, %17 : i32
          %34 = arith.muli %33, %arg5 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.addi %35, %15 : index
          %37 = memref.load %arg0[%36] : memref<?xf32>
          %38 = emitc.mul %37, %37 : (f32, f32) -> f32
          memref.store %38, %1[%arg7] : memref<1xf32, 5>
        }
        %20 = arith.divsi %arg3, %c2_i32 : i32
        %21 = math.ctlz %20 : i32
        %22 = arith.index_cast %21 : i32 to index
        %23 = arith.subi %c32, %22 : index
        scf.for %arg7 = %c0 to %23 step %c1 {
          %30 = arith.index_cast %arg7 : index to i32
          %31 = arith.shrui %20, %30 : i32
          scf.for %arg8 = %c0 to %c32 step %c1 {
            %32 = arith.index_cast %arg8 : index to i32
            %33 = arith.cmpi ult, %32, %31 : i32
            emitc.if %33 {
              %34 = arith.addi %32, %31 : i32
              %35 = arith.index_cast %34 : i32 to index
              %36 = memref.load %1[%35] : memref<1xf32, 5>
              %37 = memref.load %1[%arg8] : memref<1xf32, 5>
              %38 = emitc.add %37, %36 : (f32, f32) -> f32
              memref.store %38, %1[%arg8] : memref<1xf32, 5>
            }
          }
        }
        %24 = memref.load %1[%c0] : memref<1xf32, 5>
        %25 = arith.sitofp %arg3 : i32 to f32
        %26 = emitc.div %24, %25 : (f32, f32) -> f32
        %27 = emitc.add %26, %arg6 : (f32, f32) -> f32
        %28 = emitc.call "sqrtf"(%27) : (f32) -> f32
        scf.for %arg7 = %c0 to %c32 step %c1 {
          %30 = arith.index_cast %arg7 : index to i32
          %31 = arith.cmpi eq, %30, %c0_i32 : i32
          %32 = arith.addi %19, %30 : i32
          %33 = arith.muli %32, %arg4 : i32
          %34 = arith.addi %33, %17 : i32
          %35 = arith.muli %34, %arg5 : i32
          %36 = arith.index_cast %35 : i32 to index
          %37 = arith.addi %36, %15 : index
          %38 = memref.load %arg0[%37] : memref<?xf32>
          memref.store %38, %10[%arg7] : memref<32xf32, 5>
          emitc.if %31 {
            memref.store %28, %1[%c0] : memref<1xf32, 5>
          }
        }
        %29 = memref.load %1[%c0] : memref<1xf32, 5>
        scf.for %arg7 = %c0 to %c32 step %c1 {
          %30 = memref.load %10[%arg7] : memref<32xf32, 5>
          %31 = arith.index_cast %arg7 : index to i32
          %32 = arith.addi %19, %31 : i32
          %33 = arith.muli %32, %arg4 : i32
          %34 = arith.addi %33, %17 : i32
          %35 = arith.muli %34, %arg5 : i32
          %36 = arith.index_cast %35 : i32 to index
          %37 = arith.addi %36, %15 : index
          %38 = emitc.div %30, %29 : (f32, f32) -> f32
          memref.store %38, %arg1[%37] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: After convert to EmitC dialect:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z15rms_norm_kernelPKfPfiiiif_0 {
    gpu.func @_Z15rms_norm_kernelPKfPfiiiif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: f32) {
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %c2_i32 = arith.constant 2 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %1 = builtin.unrealized_conversion_cast %0 : !llvm.ptr<6> to memref<1xf32, 5>
      %2 = "npu.block_id"() <{dimension = "X"}> : () -> i64
      %3 = arith.index_cast %2 : i64 to index
      %4 = arith.index_cast %3 : index to i32
      %5 = arith.muli %arg2, %arg4 : i32
      %6 = arith.muli %5, %arg5 : i32
      %7 = arith.cmpi sge, %4, %6 : i32
      %8 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> i1
      emitc.if %7 {
        emitc.assign %true : i1 to %8 : i1
      } else {
        %9 = arith.cmpi sle, %arg3, %c0_i32 : i32
        emitc.assign %9 : i1 to %8 : i1
      }
      emitc.if %8 {
      } else {
        %9 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
        %10 = builtin.unrealized_conversion_cast %9 : !llvm.ptr<6> to memref<32xf32, 5>
        %11 = arith.index_cast %arg5 : i32 to index
        %12 = arith.remsi %3, %11 : index
        %13 = arith.addi %12, %11 : index
        %14 = arith.cmpi slt, %12, %c0 : index
        %15 = arith.select %14, %13, %12 : index
        %16 = arith.divsi %4, %arg5 : i32
        %17 = arith.remsi %16, %arg4 : i32
        %18 = arith.divsi %16, %arg4 : i32
        %19 = arith.muli %18, %arg3 : i32
        scf.for %arg7 = %c0 to %c32 step %c1 {
          %30 = arith.index_cast %arg7 : index to i32
          %31 = arith.addi %19, %30 : i32
          %32 = arith.muli %31, %arg4 : i32
          %33 = arith.addi %32, %17 : i32
          %34 = arith.muli %33, %arg5 : i32
          %35 = arith.index_cast %34 : i32 to index
          %36 = arith.addi %35, %15 : index
          %37 = memref.load %arg0[%36] : memref<?xf32>
          %38 = emitc.mul %37, %37 : (f32, f32) -> f32
          memref.store %38, %1[%arg7] : memref<1xf32, 5>
        }
        %20 = arith.divsi %arg3, %c2_i32 : i32
        %21 = math.ctlz %20 : i32
        %22 = arith.index_cast %21 : i32 to index
        %23 = arith.subi %c32, %22 : index
        scf.for %arg7 = %c0 to %23 step %c1 {
          %30 = arith.index_cast %arg7 : index to i32
          %31 = arith.shrui %20, %30 : i32
          scf.for %arg8 = %c0 to %c32 step %c1 {
            %32 = arith.index_cast %arg8 : index to i32
            %33 = arith.cmpi ult, %32, %31 : i32
            emitc.if %33 {
              %34 = arith.addi %32, %31 : i32
              %35 = arith.index_cast %34 : i32 to index
              %36 = memref.load %1[%35] : memref<1xf32, 5>
              %37 = memref.load %1[%arg8] : memref<1xf32, 5>
              %38 = emitc.add %37, %36 : (f32, f32) -> f32
              memref.store %38, %1[%arg8] : memref<1xf32, 5>
            }
          }
        }
        %24 = memref.load %1[%c0] : memref<1xf32, 5>
        %25 = arith.sitofp %arg3 : i32 to f32
        %26 = emitc.div %24, %25 : (f32, f32) -> f32
        %27 = emitc.add %26, %arg6 : (f32, f32) -> f32
        %28 = emitc.call "sqrtf"(%27) : (f32) -> f32
        scf.for %arg7 = %c0 to %c32 step %c1 {
          %30 = arith.index_cast %arg7 : index to i32
          %31 = arith.cmpi eq, %30, %c0_i32 : i32
          %32 = arith.addi %19, %30 : i32
          %33 = arith.muli %32, %arg4 : i32
          %34 = arith.addi %33, %17 : i32
          %35 = arith.muli %34, %arg5 : i32
          %36 = arith.index_cast %35 : i32 to index
          %37 = arith.addi %36, %15 : index
          %38 = memref.load %arg0[%37] : memref<?xf32>
          memref.store %38, %10[%arg7] : memref<32xf32, 5>
          emitc.if %31 {
            memref.store %28, %1[%c0] : memref<1xf32, 5>
          }
        }
        %29 = memref.load %1[%c0] : memref<1xf32, 5>
        scf.for %arg7 = %c0 to %c32 step %c1 {
          %30 = memref.load %10[%arg7] : memref<32xf32, 5>
          %31 = arith.index_cast %arg7 : index to i32
          %32 = arith.addi %19, %31 : i32
          %33 = arith.muli %32, %arg4 : i32
          %34 = arith.addi %33, %17 : i32
          %35 = arith.muli %34, %arg5 : i32
          %36 = arith.index_cast %35 : i32 to index
          %37 = arith.addi %36, %15 : index
          %38 = emitc.div %30, %29 : (f32, f32) -> f32
          memref.store %38, %arg1[%37] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: After convert to EmitC dialect: end

loc("/CUDA2BANG/Cambricon_NaiveProfiling/cuda_ops_test/Ascend_kernels/gen_cuda_kernels/level_1_prlblem_36_sample_0_RMSNorm_.cu":34:47): error: 'math.ctlz' op unable to find printer for op
[ict-debug] driver.cc: After emitc::translateToCpp:

