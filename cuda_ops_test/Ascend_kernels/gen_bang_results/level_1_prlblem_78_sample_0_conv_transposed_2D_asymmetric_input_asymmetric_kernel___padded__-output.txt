warning: CUDA version 12.1 is only partially supported
warning: CUDA version 12.1 is only partially supported
[ict-debug] driver.cc: After return 5, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z38__device_stub__conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    call @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12, %arg13, %arg14, %arg15) : (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32) -> ()
    return
  }
  func.func private @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %c0_i32 = arith.constant 0 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %0 = llvm.mlir.undef : i32
    %1 = gpu.block_id  x
    %2 = arith.index_cast %1 : index to i32
    %3 = gpu.block_dim  x
    %4 = arith.index_cast %3 : index to i32
    %5 = arith.muli %2, %4 : i32
    %6 = gpu.thread_id  x
    %7 = arith.index_cast %6 : index to i32
    %8 = arith.addi %5, %7 : i32
    %9 = gpu.grid_dim  x
    %10 = arith.index_cast %9 : index to i32
    %11 = gpu.block_dim  x
    %12 = arith.index_cast %11 : index to i32
    %13 = arith.muli %10, %12 : i32
    %14 = arith.muli %arg3, %arg5 : i32
    %15 = arith.muli %14, %arg14 : i32
    %16 = arith.muli %15, %arg15 : i32
    %17 = arith.index_cast %16 : i32 to index
    %18 = arith.index_cast %8 : i32 to index
    %19 = arith.index_cast %13 : i32 to index
    %20 = arith.index_cast %13 : i32 to index
    %21 = arith.index_cast %8 : i32 to index
    %22 = arith.muli %arg15, %arg14 : i32
    %23 = arith.muli %arg15, %arg14 : i32
    %24 = arith.muli %23, %arg5 : i32
    %25 = arith.index_cast %arg4 : i32 to index
    %26 = arith.index_cast %arg8 : i32 to index
    %27 = arith.index_cast %arg9 : i32 to index
    %28 = arith.subi %17, %18 : index
    %29 = arith.subi %19, %c1 : index
    %30 = arith.addi %29, %28 : index
    %31 = arith.divui %30, %19 : index
    %32:2 = affine.for %arg16 = 0 to %31 iter_args(%arg17 = %0, %arg18 = %0) -> (i32, i32) {
      %33 = arith.muli %arg16, %19 : index
      %34 = arith.divui %33, %19 : index
      %35 = arith.muli %34, %20 : index
      %36 = arith.addi %21, %35 : index
      %37 = arith.index_cast %36 : index to i32
      %38 = arith.remsi %37, %arg15 : i32
      %39 = arith.divsi %37, %arg15 : i32
      %40 = arith.remsi %39, %arg14 : i32
      %41 = arith.divsi %37, %22 : i32
      %42 = arith.remsi %41, %arg5 : i32
      %43 = arith.divsi %37, %24 : i32
      %44 = arith.addi %40, %arg12 : i32
      %45 = arith.addi %38, %arg13 : i32
      %46 = arith.addi %40, %arg12 : i32
      %47 = arith.addi %38, %arg13 : i32
      %48 = arith.muli %43, %arg4 : i32
      %49:3 = affine.for %arg19 = 0 to %25 iter_args(%arg20 = %arg17, %arg21 = %arg18, %arg22 = %cst) -> (i32, i32, f32) {
        %50 = arith.index_cast %arg19 : index to i32
        %51 = arith.addi %48, %50 : i32
        %52 = arith.muli %51, %arg6 : i32
        %53 = arith.muli %50, %arg5 : i32
        %54 = arith.addi %53, %42 : i32
        %55 = arith.muli %54, %arg8 : i32
        %56:3 = affine.for %arg23 = 0 to %26 iter_args(%arg24 = %arg20, %arg25 = %arg21, %arg26 = %arg22) -> (i32, i32, f32) {
          %57 = arith.index_cast %arg23 : index to i32
          %58 = arith.subi %44, %57 : i32
          %59 = arith.subi %46, %57 : i32
          %60 = arith.remsi %59, %arg10 : i32
          %61 = arith.cmpi eq, %60, %c0_i32 : i32
          %62 = arith.divsi %58, %arg10 : i32
          %63 = arith.cmpi sge, %62, %c0_i32 : i32
          %64 = arith.cmpi slt, %62, %arg6 : i32
          %65 = arith.addi %52, %62 : i32
          %66 = arith.muli %65, %arg7 : i32
          %67 = arith.addi %55, %57 : i32
          %68 = arith.muli %67, %arg9 : i32
          %69:3 = affine.for %arg27 = 0 to %27 iter_args(%arg28 = %arg24, %arg29 = %arg25, %arg30 = %arg26) -> (i32, i32, f32) {
            %70 = arith.index_cast %arg27 : index to i32
            %71 = arith.subi %45, %70 : i32
            %72 = arith.divsi %71, %arg11 : i32
            %73 = arith.cmpi sge, %72, %c0_i32 : i32
            %74 = arith.cmpi slt, %72, %arg7 : i32
            %75 = arith.subi %47, %70 : i32
            %76 = arith.remsi %75, %arg11 : i32
            %77 = arith.cmpi eq, %76, %c0_i32 : i32
            %78 = arith.andi %61, %77 : i1
            %79 = arith.andi %74, %78 : i1
            %80 = arith.andi %73, %79 : i1
            %81 = arith.andi %64, %80 : i1
            %82 = arith.andi %63, %81 : i1
            %83:3 = scf.if %82 -> (i32, i32, f32) {
              %84 = arith.addi %66, %72 : i32
              %85 = arith.addi %68, %70 : i32
              %86 = arith.index_cast %84 : i32 to index
              %87 = memref.load %arg0[%86] : memref<?xf32>
              %88 = arith.index_cast %85 : i32 to index
              %89 = memref.load %arg1[%88] : memref<?xf32>
              %90 = arith.mulf %87, %89 : f32
              %91 = arith.addf %arg30, %90 : f32
              scf.yield %85, %84, %91 : i32, i32, f32
            } else {
              scf.yield %arg28, %arg29, %arg30 : i32, i32, f32
            }
            affine.yield %83#0, %83#1, %83#2 : i32, i32, f32
          }
          affine.yield %69#0, %69#1, %69#2 : i32, i32, f32
        }
        affine.yield %56#0, %56#1, %56#2 : i32, i32, f32
      }
      affine.store %49#2, %arg2[%arg16 * symbol(%20) + symbol(%21)] : memref<?xf32>
      affine.yield %49#0, %49#1 : i32, i32
    }
    return
  }
}
[ict-debug] driver.cc: After return 5, module: end

[ict-debug] driver.cc: After return 6, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %c0_i32 = arith.constant 0 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %0 = llvm.mlir.undef : i32
    %1 = gpu.block_id  x
    %2 = arith.index_cast %1 : index to i32
    %3 = gpu.block_dim  x
    %4 = arith.index_cast %3 : index to i32
    %5 = arith.muli %2, %4 : i32
    %6 = gpu.thread_id  x
    %7 = arith.index_cast %6 : index to i32
    %8 = arith.addi %5, %7 : i32
    %9 = gpu.grid_dim  x
    %10 = arith.index_cast %9 : index to i32
    %11 = arith.muli %10, %4 : i32
    %12 = arith.muli %arg3, %arg5 : i32
    %13 = arith.muli %12, %arg14 : i32
    %14 = arith.muli %13, %arg15 : i32
    %15 = arith.index_cast %14 : i32 to index
    %16 = arith.index_cast %8 : i32 to index
    %17 = arith.index_cast %11 : i32 to index
    %18 = arith.muli %arg15, %arg14 : i32
    %19 = arith.muli %18, %arg5 : i32
    %20 = arith.index_cast %arg4 : i32 to index
    %21 = arith.index_cast %arg8 : i32 to index
    %22 = arith.index_cast %arg9 : i32 to index
    %23 = arith.subi %15, %16 : index
    %24 = arith.subi %17, %c1 : index
    %25 = arith.addi %24, %23 : index
    %26 = arith.divui %25, %17 : index
    %27:2 = affine.for %arg16 = 0 to %26 iter_args(%arg17 = %0, %arg18 = %0) -> (i32, i32) {
      %28 = arith.muli %arg16, %17 : index
      %29 = arith.addi %16, %28 : index
      %30 = arith.index_cast %29 : index to i32
      %31 = arith.remsi %30, %arg15 : i32
      %32 = arith.divsi %30, %arg15 : i32
      %33 = arith.remsi %32, %arg14 : i32
      %34 = arith.divsi %30, %18 : i32
      %35 = arith.remsi %34, %arg5 : i32
      %36 = arith.divsi %30, %19 : i32
      %37 = arith.addi %33, %arg12 : i32
      %38 = arith.addi %31, %arg13 : i32
      %39 = arith.muli %36, %arg4 : i32
      %40:3 = affine.for %arg19 = 0 to %20 iter_args(%arg20 = %arg17, %arg21 = %arg18, %arg22 = %cst) -> (i32, i32, f32) {
        %41 = arith.index_cast %arg19 : index to i32
        %42 = arith.addi %39, %41 : i32
        %43 = arith.muli %42, %arg6 : i32
        %44 = arith.muli %41, %arg5 : i32
        %45 = arith.addi %44, %35 : i32
        %46 = arith.muli %45, %arg8 : i32
        %47:3 = affine.for %arg23 = 0 to %21 iter_args(%arg24 = %arg20, %arg25 = %arg21, %arg26 = %arg22) -> (i32, i32, f32) {
          %48 = arith.index_cast %arg23 : index to i32
          %49 = arith.subi %37, %48 : i32
          %50 = arith.remsi %49, %arg10 : i32
          %51 = arith.cmpi eq, %50, %c0_i32 : i32
          %52 = arith.divsi %49, %arg10 : i32
          %53 = arith.cmpi sge, %52, %c0_i32 : i32
          %54 = arith.cmpi slt, %52, %arg6 : i32
          %55 = arith.addi %43, %52 : i32
          %56 = arith.muli %55, %arg7 : i32
          %57 = arith.addi %46, %48 : i32
          %58 = arith.muli %57, %arg9 : i32
          %59:3 = affine.for %arg27 = 0 to %22 iter_args(%arg28 = %arg24, %arg29 = %arg25, %arg30 = %arg26) -> (i32, i32, f32) {
            %60 = arith.index_cast %arg27 : index to i32
            %61 = arith.subi %38, %60 : i32
            %62 = arith.divsi %61, %arg11 : i32
            %63 = arith.cmpi sge, %62, %c0_i32 : i32
            %64 = arith.cmpi slt, %62, %arg7 : i32
            %65 = arith.remsi %61, %arg11 : i32
            %66 = arith.cmpi eq, %65, %c0_i32 : i32
            %67 = arith.andi %51, %66 : i1
            %68 = arith.andi %64, %67 : i1
            %69 = arith.andi %63, %68 : i1
            %70 = arith.andi %54, %69 : i1
            %71 = arith.andi %53, %70 : i1
            %72:3 = scf.if %71 -> (i32, i32, f32) {
              %73 = arith.addi %56, %62 : i32
              %74 = arith.addi %58, %60 : i32
              %75 = arith.index_cast %73 : i32 to index
              %76 = memref.load %arg0[%75] : memref<?xf32>
              %77 = arith.index_cast %74 : i32 to index
              %78 = memref.load %arg1[%77] : memref<?xf32>
              %79 = arith.mulf %76, %78 : f32
              %80 = arith.addf %arg30, %79 : f32
              scf.yield %74, %73, %80 : i32, i32, f32
            } else {
              scf.yield %arg28, %arg29, %arg30 : i32, i32, f32
            }
            affine.yield %72#0, %72#1, %72#2 : i32, i32, f32
          }
          affine.yield %59#0, %59#1, %59#2 : i32, i32, f32
        }
        affine.yield %47#0, %47#1, %47#2 : i32, i32, f32
      }
      affine.store %40#2, %arg2[%arg16 * symbol(%17) + symbol(%16)] : memref<?xf32>
      affine.yield %40#0, %40#1 : i32, i32
    }
    return
  }
}
[ict-debug] driver.cc: After return 6, module: end

WrapAndReplaceBarrierPass::runOnOperation(): before execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c0_i32 = arith.constant 0 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %0 = llvm.mlir.undef : i32
    %1 = gpu.block_id  x
    %2 = arith.index_cast %1 : index to i32
    %3 = gpu.block_dim  x
    %4 = arith.index_cast %3 : index to i32
    %5 = arith.muli %2, %4 : i32
    %6 = gpu.thread_id  x
    %7 = arith.index_cast %6 : index to i32
    %8 = arith.addi %5, %7 : i32
    %9 = gpu.grid_dim  x
    %10 = arith.index_cast %9 : index to i32
    %11 = arith.muli %10, %4 : i32
    %12 = arith.muli %arg3, %arg5 : i32
    %13 = arith.muli %12, %arg14 : i32
    %14 = arith.muli %13, %arg15 : i32
    %15 = arith.index_cast %14 : i32 to index
    %16 = arith.index_cast %8 : i32 to index
    %17 = arith.index_cast %11 : i32 to index
    %18 = arith.muli %arg15, %arg14 : i32
    %19 = arith.muli %18, %arg5 : i32
    %20 = arith.index_cast %arg4 : i32 to index
    %21 = arith.index_cast %arg8 : i32 to index
    %22 = arith.index_cast %arg9 : i32 to index
    %23 = arith.subi %15, %16 : index
    %24 = arith.subi %17, %c1 : index
    %25 = arith.addi %24, %23 : index
    %26 = arith.divui %25, %17 : index
    %27:2 = scf.for %arg16 = %c0 to %26 step %c1 iter_args(%arg17 = %0, %arg18 = %0) -> (i32, i32) {
      %28 = arith.muli %arg16, %17 : index
      %29 = arith.addi %16, %28 : index
      %30 = arith.index_cast %29 : index to i32
      %31 = arith.remsi %30, %arg15 : i32
      %32 = arith.divsi %30, %arg15 : i32
      %33 = arith.remsi %32, %arg14 : i32
      %34 = arith.divsi %30, %18 : i32
      %35 = arith.remsi %34, %arg5 : i32
      %36 = arith.divsi %30, %19 : i32
      %37 = arith.addi %33, %arg12 : i32
      %38 = arith.addi %31, %arg13 : i32
      %39 = arith.muli %36, %arg4 : i32
      %40:3 = scf.for %arg19 = %c0 to %20 step %c1 iter_args(%arg20 = %arg17, %arg21 = %arg18, %arg22 = %cst) -> (i32, i32, f32) {
        %42 = arith.index_cast %arg19 : index to i32
        %43 = arith.addi %39, %42 : i32
        %44 = arith.muli %43, %arg6 : i32
        %45 = arith.muli %42, %arg5 : i32
        %46 = arith.addi %45, %35 : i32
        %47 = arith.muli %46, %arg8 : i32
        %48:3 = scf.for %arg23 = %c0 to %21 step %c1 iter_args(%arg24 = %arg20, %arg25 = %arg21, %arg26 = %arg22) -> (i32, i32, f32) {
          %49 = arith.index_cast %arg23 : index to i32
          %50 = arith.subi %37, %49 : i32
          %51 = arith.remsi %50, %arg10 : i32
          %52 = arith.cmpi eq, %51, %c0_i32 : i32
          %53 = arith.divsi %50, %arg10 : i32
          %54 = arith.cmpi sge, %53, %c0_i32 : i32
          %55 = arith.cmpi slt, %53, %arg6 : i32
          %56 = arith.addi %44, %53 : i32
          %57 = arith.muli %56, %arg7 : i32
          %58 = arith.addi %47, %49 : i32
          %59 = arith.muli %58, %arg9 : i32
          %60:3 = scf.for %arg27 = %c0 to %22 step %c1 iter_args(%arg28 = %arg24, %arg29 = %arg25, %arg30 = %arg26) -> (i32, i32, f32) {
            %61 = arith.index_cast %arg27 : index to i32
            %62 = arith.subi %38, %61 : i32
            %63 = arith.divsi %62, %arg11 : i32
            %64 = arith.cmpi sge, %63, %c0_i32 : i32
            %65 = arith.cmpi slt, %63, %arg7 : i32
            %66 = arith.remsi %62, %arg11 : i32
            %67 = arith.cmpi eq, %66, %c0_i32 : i32
            %68 = arith.andi %52, %67 : i1
            %69 = arith.andi %65, %68 : i1
            %70 = arith.andi %64, %69 : i1
            %71 = arith.andi %55, %70 : i1
            %72 = arith.andi %54, %71 : i1
            %73:3 = scf.if %72 -> (i32, i32, f32) {
              %74 = arith.addi %57, %63 : i32
              %75 = arith.addi %59, %61 : i32
              %76 = arith.index_cast %74 : i32 to index
              %77 = memref.load %arg0[%76] : memref<?xf32>
              %78 = arith.index_cast %75 : i32 to index
              %79 = memref.load %arg1[%78] : memref<?xf32>
              %80 = arith.mulf %77, %79 : f32
              %81 = arith.addf %arg30, %80 : f32
              scf.yield %75, %74, %81 : i32, i32, f32
            } else {
              scf.yield %arg28, %arg29, %arg30 : i32, i32, f32
            }
            scf.yield %73#0, %73#1, %73#2 : i32, i32, f32
          }
          scf.yield %60#0, %60#1, %60#2 : i32, i32, f32
        }
        scf.yield %48#0, %48#1, %48#2 : i32, i32, f32
      }
      %41 = arith.addi %28, %16 : index
      memref.store %40#2, %arg2[%41] : memref<?xf32>
      scf.yield %40#0, %40#1 : i32, i32
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): before execute: end
WrapAndReplaceBarrierPass::runOnOperation(): after execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg16) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c1_1 = arith.constant 1 : index
      %c0_i32 = arith.constant 0 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %0 = llvm.mlir.undef : i32
      %1 = gpu.block_id  x
      %2 = arith.index_cast %1 : index to i32
      %3 = gpu.block_dim  x
      %4 = arith.index_cast %3 : index to i32
      %5 = arith.muli %2, %4 : i32
      %6 = arith.index_cast %arg16 : index to i32
      %7 = arith.addi %5, %6 : i32
      %8 = gpu.grid_dim  x
      %9 = arith.index_cast %8 : index to i32
      %10 = arith.muli %9, %4 : i32
      %11 = arith.muli %arg3, %arg5 : i32
      %12 = arith.muli %11, %arg14 : i32
      %13 = arith.muli %12, %arg15 : i32
      %14 = arith.index_cast %13 : i32 to index
      %15 = arith.index_cast %7 : i32 to index
      %16 = arith.index_cast %10 : i32 to index
      %17 = arith.muli %arg15, %arg14 : i32
      %18 = arith.muli %17, %arg5 : i32
      %19 = arith.index_cast %arg4 : i32 to index
      %20 = arith.index_cast %arg8 : i32 to index
      %21 = arith.index_cast %arg9 : i32 to index
      %22 = arith.subi %14, %15 : index
      %23 = arith.subi %16, %c1_1 : index
      %24 = arith.addi %23, %22 : index
      %25 = arith.divui %24, %16 : index
      %26:2 = scf.for %arg17 = %c0_0 to %25 step %c1_1 iter_args(%arg18 = %0, %arg19 = %0) -> (i32, i32) {
        %27 = arith.muli %arg17, %16 : index
        %28 = arith.addi %15, %27 : index
        %29 = arith.index_cast %28 : index to i32
        %30 = arith.remsi %29, %arg15 : i32
        %31 = arith.divsi %29, %arg15 : i32
        %32 = arith.remsi %31, %arg14 : i32
        %33 = arith.divsi %29, %17 : i32
        %34 = arith.remsi %33, %arg5 : i32
        %35 = arith.divsi %29, %18 : i32
        %36 = arith.addi %32, %arg12 : i32
        %37 = arith.addi %30, %arg13 : i32
        %38 = arith.muli %35, %arg4 : i32
        %39:3 = scf.for %arg20 = %c0_0 to %19 step %c1_1 iter_args(%arg21 = %arg18, %arg22 = %arg19, %arg23 = %cst) -> (i32, i32, f32) {
          %41 = arith.index_cast %arg20 : index to i32
          %42 = arith.addi %38, %41 : i32
          %43 = arith.muli %42, %arg6 : i32
          %44 = arith.muli %41, %arg5 : i32
          %45 = arith.addi %44, %34 : i32
          %46 = arith.muli %45, %arg8 : i32
          %47:3 = scf.for %arg24 = %c0_0 to %20 step %c1_1 iter_args(%arg25 = %arg21, %arg26 = %arg22, %arg27 = %arg23) -> (i32, i32, f32) {
            %48 = arith.index_cast %arg24 : index to i32
            %49 = arith.subi %36, %48 : i32
            %50 = arith.remsi %49, %arg10 : i32
            %51 = arith.cmpi eq, %50, %c0_i32 : i32
            %52 = arith.divsi %49, %arg10 : i32
            %53 = arith.cmpi sge, %52, %c0_i32 : i32
            %54 = arith.cmpi slt, %52, %arg6 : i32
            %55 = arith.addi %43, %52 : i32
            %56 = arith.muli %55, %arg7 : i32
            %57 = arith.addi %46, %48 : i32
            %58 = arith.muli %57, %arg9 : i32
            %59:3 = scf.for %arg28 = %c0_0 to %21 step %c1_1 iter_args(%arg29 = %arg25, %arg30 = %arg26, %arg31 = %arg27) -> (i32, i32, f32) {
              %60 = arith.index_cast %arg28 : index to i32
              %61 = arith.subi %37, %60 : i32
              %62 = arith.divsi %61, %arg11 : i32
              %63 = arith.cmpi sge, %62, %c0_i32 : i32
              %64 = arith.cmpi slt, %62, %arg7 : i32
              %65 = arith.remsi %61, %arg11 : i32
              %66 = arith.cmpi eq, %65, %c0_i32 : i32
              %67 = arith.andi %51, %66 : i1
              %68 = arith.andi %64, %67 : i1
              %69 = arith.andi %63, %68 : i1
              %70 = arith.andi %54, %69 : i1
              %71 = arith.andi %53, %70 : i1
              %72:3 = scf.if %71 -> (i32, i32, f32) {
                %73 = arith.addi %56, %62 : i32
                %74 = arith.addi %58, %60 : i32
                %75 = arith.index_cast %73 : i32 to index
                %76 = memref.load %arg0[%75] : memref<?xf32>
                %77 = arith.index_cast %74 : i32 to index
                %78 = memref.load %arg1[%77] : memref<?xf32>
                %79 = arith.mulf %76, %78 : f32
                %80 = arith.addf %arg31, %79 : f32
                scf.yield %74, %73, %80 : i32, i32, f32
              } else {
                scf.yield %arg29, %arg30, %arg31 : i32, i32, f32
              }
              scf.yield %72#0, %72#1, %72#2 : i32, i32, f32
            }
            scf.yield %59#0, %59#1, %59#2 : i32, i32, f32
          }
          scf.yield %47#0, %47#1, %47#2 : i32, i32, f32
        }
        %40 = arith.addi %27, %15 : index
        memref.store %39#2, %arg2[%40] : memref<?xf32>
        scf.yield %39#0, %39#1 : i32, i32
      }
      scf.yield
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): after execute: end
[ict-debug] driver.cc: After return 7, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg16) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c1_1 = arith.constant 1 : index
      %c0_i32 = arith.constant 0 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %0 = llvm.mlir.undef : i32
      %1 = gpu.block_id  x
      %2 = arith.index_cast %1 : index to i32
      %3 = gpu.block_dim  x
      %4 = arith.index_cast %3 : index to i32
      %5 = arith.muli %2, %4 : i32
      %6 = arith.index_cast %arg16 : index to i32
      %7 = arith.addi %5, %6 : i32
      %8 = gpu.grid_dim  x
      %9 = arith.index_cast %8 : index to i32
      %10 = arith.muli %9, %4 : i32
      %11 = arith.muli %arg3, %arg5 : i32
      %12 = arith.muli %11, %arg14 : i32
      %13 = arith.muli %12, %arg15 : i32
      %14 = arith.index_cast %13 : i32 to index
      %15 = arith.index_cast %7 : i32 to index
      %16 = arith.index_cast %10 : i32 to index
      %17 = arith.muli %arg15, %arg14 : i32
      %18 = arith.muli %17, %arg5 : i32
      %19 = arith.index_cast %arg4 : i32 to index
      %20 = arith.index_cast %arg8 : i32 to index
      %21 = arith.index_cast %arg9 : i32 to index
      %22 = arith.subi %14, %15 : index
      %23 = arith.subi %16, %c1_1 : index
      %24 = arith.addi %23, %22 : index
      %25 = arith.divui %24, %16 : index
      %26:2 = scf.for %arg17 = %c0_0 to %25 step %c1_1 iter_args(%arg18 = %0, %arg19 = %0) -> (i32, i32) {
        %27 = arith.muli %arg17, %16 : index
        %28 = arith.addi %15, %27 : index
        %29 = arith.index_cast %28 : index to i32
        %30 = arith.remsi %29, %arg15 : i32
        %31 = arith.divsi %29, %arg15 : i32
        %32 = arith.remsi %31, %arg14 : i32
        %33 = arith.divsi %29, %17 : i32
        %34 = arith.remsi %33, %arg5 : i32
        %35 = arith.divsi %29, %18 : i32
        %36 = arith.addi %32, %arg12 : i32
        %37 = arith.addi %30, %arg13 : i32
        %38 = arith.muli %35, %arg4 : i32
        %39:3 = scf.for %arg20 = %c0_0 to %19 step %c1_1 iter_args(%arg21 = %arg18, %arg22 = %arg19, %arg23 = %cst) -> (i32, i32, f32) {
          %41 = arith.index_cast %arg20 : index to i32
          %42 = arith.addi %38, %41 : i32
          %43 = arith.muli %42, %arg6 : i32
          %44 = arith.muli %41, %arg5 : i32
          %45 = arith.addi %44, %34 : i32
          %46 = arith.muli %45, %arg8 : i32
          %47:3 = scf.for %arg24 = %c0_0 to %20 step %c1_1 iter_args(%arg25 = %arg21, %arg26 = %arg22, %arg27 = %arg23) -> (i32, i32, f32) {
            %48 = arith.index_cast %arg24 : index to i32
            %49 = arith.subi %36, %48 : i32
            %50 = arith.remsi %49, %arg10 : i32
            %51 = arith.cmpi eq, %50, %c0_i32 : i32
            %52 = arith.divsi %49, %arg10 : i32
            %53 = arith.cmpi sge, %52, %c0_i32 : i32
            %54 = arith.cmpi slt, %52, %arg6 : i32
            %55 = arith.addi %43, %52 : i32
            %56 = arith.muli %55, %arg7 : i32
            %57 = arith.addi %46, %48 : i32
            %58 = arith.muli %57, %arg9 : i32
            %59:3 = scf.for %arg28 = %c0_0 to %21 step %c1_1 iter_args(%arg29 = %arg25, %arg30 = %arg26, %arg31 = %arg27) -> (i32, i32, f32) {
              %60 = arith.index_cast %arg28 : index to i32
              %61 = arith.subi %37, %60 : i32
              %62 = arith.divsi %61, %arg11 : i32
              %63 = arith.cmpi sge, %62, %c0_i32 : i32
              %64 = arith.cmpi slt, %62, %arg7 : i32
              %65 = arith.remsi %61, %arg11 : i32
              %66 = arith.cmpi eq, %65, %c0_i32 : i32
              %67 = arith.andi %51, %66 : i1
              %68 = arith.andi %64, %67 : i1
              %69 = arith.andi %63, %68 : i1
              %70 = arith.andi %54, %69 : i1
              %71 = arith.andi %53, %70 : i1
              %72:3 = scf.if %71 -> (i32, i32, f32) {
                %73 = arith.addi %56, %62 : i32
                %74 = arith.addi %58, %60 : i32
                %75 = arith.index_cast %73 : i32 to index
                %76 = memref.load %arg0[%75] : memref<?xf32>
                %77 = arith.index_cast %74 : i32 to index
                %78 = memref.load %arg1[%77] : memref<?xf32>
                %79 = arith.mulf %76, %78 : f32
                %80 = arith.addf %arg31, %79 : f32
                scf.yield %74, %73, %80 : i32, i32, f32
              } else {
                scf.yield %arg29, %arg30, %arg31 : i32, i32, f32
              }
              scf.yield %72#0, %72#1, %72#2 : i32, i32, f32
            }
            scf.yield %59#0, %59#1, %59#2 : i32, i32, f32
          }
          scf.yield %47#0, %47#1, %47#2 : i32, i32, f32
        }
        %40 = arith.addi %27, %15 : index
        memref.store %39#2, %arg2[%40] : memref<?xf32>
        scf.yield %39#0, %39#1 : i32, i32
      }
      scf.yield
    }
    return
  }
}
[ict-debug] driver.cc: After return 7, module: end

[ict-debug] driver.cc: Before my pass process:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %cst = arith.constant 0.000000e+00 : f32
    %c0_i32 = arith.constant 0 : i32
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %0 = llvm.mlir.undef : i32
    %1 = gpu.block_id  x
    %2 = arith.index_cast %1 : index to i32
    %3 = gpu.block_dim  x
    %4 = arith.index_cast %3 : index to i32
    %5 = arith.muli %2, %4 : i32
    %6 = gpu.grid_dim  x
    %7 = arith.index_cast %6 : index to i32
    %8 = arith.muli %7, %4 : i32
    %9 = arith.muli %arg3, %arg5 : i32
    %10 = arith.muli %9, %arg14 : i32
    %11 = arith.muli %10, %arg15 : i32
    %12 = arith.index_cast %11 : i32 to index
    %13 = arith.index_cast %8 : i32 to index
    %14 = arith.muli %arg15, %arg14 : i32
    %15 = arith.muli %14, %arg5 : i32
    %16 = arith.index_cast %arg4 : i32 to index
    %17 = arith.index_cast %arg8 : i32 to index
    %18 = arith.index_cast %arg9 : i32 to index
    %19 = arith.subi %13, %c1 : index
    scf.parallel (%arg16) = (%c0) to (%c32) step (%c1) {
      %20 = arith.index_cast %arg16 : index to i32
      %21 = arith.addi %5, %20 : i32
      %22 = arith.index_cast %21 : i32 to index
      %23 = arith.subi %12, %22 : index
      %24 = arith.addi %19, %23 : index
      %25 = arith.divui %24, %13 : index
      %26:2 = scf.for %arg17 = %c0 to %25 step %c1 iter_args(%arg18 = %0, %arg19 = %0) -> (i32, i32) {
        %27 = arith.muli %arg17, %13 : index
        %28 = arith.addi %22, %27 : index
        %29 = arith.index_cast %28 : index to i32
        %30 = arith.remsi %29, %arg15 : i32
        %31 = arith.divsi %29, %arg15 : i32
        %32 = arith.remsi %31, %arg14 : i32
        %33 = arith.divsi %29, %14 : i32
        %34 = arith.remsi %33, %arg5 : i32
        %35 = arith.divsi %29, %15 : i32
        %36 = arith.addi %32, %arg12 : i32
        %37 = arith.addi %30, %arg13 : i32
        %38 = arith.muli %35, %arg4 : i32
        %39:3 = scf.for %arg20 = %c0 to %16 step %c1 iter_args(%arg21 = %arg18, %arg22 = %arg19, %arg23 = %cst) -> (i32, i32, f32) {
          %41 = arith.index_cast %arg20 : index to i32
          %42 = arith.addi %38, %41 : i32
          %43 = arith.muli %42, %arg6 : i32
          %44 = arith.muli %41, %arg5 : i32
          %45 = arith.addi %44, %34 : i32
          %46 = arith.muli %45, %arg8 : i32
          %47:3 = scf.for %arg24 = %c0 to %17 step %c1 iter_args(%arg25 = %arg21, %arg26 = %arg22, %arg27 = %arg23) -> (i32, i32, f32) {
            %48 = arith.index_cast %arg24 : index to i32
            %49 = arith.subi %36, %48 : i32
            %50 = arith.remsi %49, %arg10 : i32
            %51 = arith.cmpi eq, %50, %c0_i32 : i32
            %52 = arith.divsi %49, %arg10 : i32
            %53 = arith.cmpi sge, %52, %c0_i32 : i32
            %54 = arith.cmpi slt, %52, %arg6 : i32
            %55 = arith.addi %43, %52 : i32
            %56 = arith.muli %55, %arg7 : i32
            %57 = arith.addi %46, %48 : i32
            %58 = arith.muli %57, %arg9 : i32
            %59:3 = scf.for %arg28 = %c0 to %18 step %c1 iter_args(%arg29 = %arg25, %arg30 = %arg26, %arg31 = %arg27) -> (i32, i32, f32) {
              %60 = arith.index_cast %arg28 : index to i32
              %61 = arith.subi %37, %60 : i32
              %62 = arith.divsi %61, %arg11 : i32
              %63 = arith.cmpi sge, %62, %c0_i32 : i32
              %64 = arith.cmpi slt, %62, %arg7 : i32
              %65 = arith.remsi %61, %arg11 : i32
              %66 = arith.cmpi eq, %65, %c0_i32 : i32
              %67 = arith.andi %51, %66 : i1
              %68 = arith.andi %64, %67 : i1
              %69 = arith.andi %63, %68 : i1
              %70 = arith.andi %54, %69 : i1
              %71 = arith.andi %53, %70 : i1
              %72:3 = scf.if %71 -> (i32, i32, f32) {
                %73 = arith.addi %56, %62 : i32
                %74 = arith.addi %58, %60 : i32
                %75 = arith.index_cast %73 : i32 to index
                %76 = memref.load %arg0[%75] : memref<?xf32>
                %77 = arith.index_cast %74 : i32 to index
                %78 = memref.load %arg1[%77] : memref<?xf32>
                %79 = arith.mulf %76, %78 : f32
                %80 = arith.addf %arg31, %79 : f32
                scf.yield %74, %73, %80 : i32, i32, f32
              } else {
                scf.yield %arg29, %arg30, %arg31 : i32, i32, f32
              }
              scf.yield %72#0, %72#1, %72#2 : i32, i32, f32
            }
            scf.yield %59#0, %59#1, %59#2 : i32, i32, f32
          }
          scf.yield %47#0, %47#1, %47#2 : i32, i32, f32
        }
        %40 = arith.addi %27, %22 : index
        memref.store %39#2, %arg2[%40] : memref<?xf32>
        scf.yield %39#0, %39#1 : i32, i32
      }
      scf.yield
    }
    return
  }
}
[ict-debug] driver.cc: Before my pass process: end

[ict-debug] driver.cc: vectorizeSize = 1

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii_0 {
    gpu.func @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) {
      %cst = arith.constant 0.000000e+00 : f32
      %c0_i32 = arith.constant 0 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = llvm.mlir.undef : i32
      %1 = gpu.block_id  x
      %2 = arith.index_cast %1 : index to i32
      %3 = gpu.block_dim  x
      %4 = arith.index_cast %3 : index to i32
      %5 = arith.muli %2, %4 : i32
      %6 = gpu.grid_dim  x
      %7 = arith.index_cast %6 : index to i32
      %8 = arith.muli %7, %4 : i32
      %9 = arith.muli %arg3, %arg5 : i32
      %10 = arith.muli %9, %arg14 : i32
      %11 = arith.muli %10, %arg15 : i32
      %12 = arith.index_cast %11 : i32 to index
      %13 = arith.index_cast %8 : i32 to index
      %14 = arith.muli %arg15, %arg14 : i32
      %15 = arith.muli %14, %arg5 : i32
      %16 = arith.index_cast %arg4 : i32 to index
      %17 = arith.index_cast %arg8 : i32 to index
      %18 = arith.index_cast %arg9 : i32 to index
      %19 = arith.subi %13, %c1 : index
      scf.parallel (%arg16) = (%c0) to (%c32) step (%c1) {
        %20 = arith.index_cast %arg16 : index to i32
        %21 = arith.addi %5, %20 : i32
        %22 = arith.index_cast %21 : i32 to index
        %23 = arith.subi %12, %22 : index
        %24 = arith.addi %19, %23 : index
        %25 = arith.divui %24, %13 : index
        %26:2 = scf.for %arg17 = %c0 to %25 step %c1 iter_args(%arg18 = %0, %arg19 = %0) -> (i32, i32) {
          %27 = arith.muli %arg17, %13 : index
          %28 = arith.addi %22, %27 : index
          %29 = arith.index_cast %28 : index to i32
          %30 = arith.remsi %29, %arg15 : i32
          %31 = arith.divsi %29, %arg15 : i32
          %32 = arith.remsi %31, %arg14 : i32
          %33 = arith.divsi %29, %14 : i32
          %34 = arith.remsi %33, %arg5 : i32
          %35 = arith.divsi %29, %15 : i32
          %36 = arith.addi %32, %arg12 : i32
          %37 = arith.addi %30, %arg13 : i32
          %38 = arith.muli %35, %arg4 : i32
          %39:3 = scf.for %arg20 = %c0 to %16 step %c1 iter_args(%arg21 = %arg18, %arg22 = %arg19, %arg23 = %cst) -> (i32, i32, f32) {
            %41 = arith.index_cast %arg20 : index to i32
            %42 = arith.addi %38, %41 : i32
            %43 = arith.muli %42, %arg6 : i32
            %44 = arith.muli %41, %arg5 : i32
            %45 = arith.addi %44, %34 : i32
            %46 = arith.muli %45, %arg8 : i32
            %47:3 = scf.for %arg24 = %c0 to %17 step %c1 iter_args(%arg25 = %arg21, %arg26 = %arg22, %arg27 = %arg23) -> (i32, i32, f32) {
              %48 = arith.index_cast %arg24 : index to i32
              %49 = arith.subi %36, %48 : i32
              %50 = arith.remsi %49, %arg10 : i32
              %51 = arith.cmpi eq, %50, %c0_i32 : i32
              %52 = arith.divsi %49, %arg10 : i32
              %53 = arith.cmpi sge, %52, %c0_i32 : i32
              %54 = arith.cmpi slt, %52, %arg6 : i32
              %55 = arith.addi %43, %52 : i32
              %56 = arith.muli %55, %arg7 : i32
              %57 = arith.addi %46, %48 : i32
              %58 = arith.muli %57, %arg9 : i32
              %59:3 = scf.for %arg28 = %c0 to %18 step %c1 iter_args(%arg29 = %arg25, %arg30 = %arg26, %arg31 = %arg27) -> (i32, i32, f32) {
                %60 = arith.index_cast %arg28 : index to i32
                %61 = arith.subi %37, %60 : i32
                %62 = arith.divsi %61, %arg11 : i32
                %63 = arith.cmpi sge, %62, %c0_i32 : i32
                %64 = arith.cmpi slt, %62, %arg7 : i32
                %65 = arith.remsi %61, %arg11 : i32
                %66 = arith.cmpi eq, %65, %c0_i32 : i32
                %67 = arith.andi %51, %66 : i1
                %68 = arith.andi %64, %67 : i1
                %69 = arith.andi %63, %68 : i1
                %70 = arith.andi %54, %69 : i1
                %71 = arith.andi %53, %70 : i1
                %72:3 = scf.if %71 -> (i32, i32, f32) {
                  %73 = arith.addi %56, %62 : i32
                  %74 = arith.addi %58, %60 : i32
                  %75 = arith.index_cast %73 : i32 to index
                  %76 = memref.load %arg0[%75] : memref<?xf32>
                  %77 = arith.index_cast %74 : i32 to index
                  %78 = memref.load %arg1[%77] : memref<?xf32>
                  %79 = arith.mulf %76, %78 : f32
                  %80 = arith.addf %arg31, %79 : f32
                  scf.yield %74, %73, %80 : i32, i32, f32
                } else {
                  scf.yield %arg29, %arg30, %arg31 : i32, i32, f32
                }
                scf.yield %72#0, %72#1, %72#2 : i32, i32, f32
              }
              scf.yield %59#0, %59#1, %59#2 : i32, i32, f32
            }
            scf.yield %47#0, %47#1, %47#2 : i32, i32, f32
          }
          %40 = arith.addi %27, %22 : index
          memref.store %39#2, %arg2[%40] : memref<?xf32>
          scf.yield %39#0, %39#1 : i32, i32
        }
        scf.yield
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute: end

[ict-debug] ConvertPolygeistToNPU:convertScfParallelToScfFor(): replace gpu.block_dim op with thread loop bound

[ict-debug] ConvertPolygeistToNPU:convertScfParallelToScfFor(): replace gpu.grid_dim with npu.block_num

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize:

"builtin.module"() ({
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32):
      %0 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %1 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 0 : index}> : () -> index
      %3 = "arith.constant"() <{value = 1 : index}> : () -> index
      %4 = "arith.constant"() <{value = 32 : index}> : () -> index
      %5 = "llvm.mlir.undef"() : () -> i32
      %6 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %7 = "arith.index_cast"(%6) : (index) -> i32
      %8 = "arith.constant"() <{value = 32 : index}> : () -> index
      %9 = "arith.index_cast"(%8) : (index) -> i32
      %10 = "arith.muli"(%7, %9) : (i32, i32) -> i32
      %11 = "npu.block_num"() <{dimension = "X"}> : () -> i64
      %12 = "arith.index_cast"(%11) : (i64) -> i32
      %13 = "arith.muli"(%12, %9) : (i32, i32) -> i32
      %14 = "arith.muli"(%arg3, %arg5) : (i32, i32) -> i32
      %15 = "arith.muli"(%14, %arg14) : (i32, i32) -> i32
      %16 = "arith.muli"(%15, %arg15) : (i32, i32) -> i32
      %17 = "arith.index_cast"(%16) : (i32) -> index
      %18 = "arith.index_cast"(%13) : (i32) -> index
      %19 = "arith.muli"(%arg15, %arg14) : (i32, i32) -> i32
      %20 = "arith.muli"(%19, %arg5) : (i32, i32) -> i32
      %21 = "arith.index_cast"(%arg4) : (i32) -> index
      %22 = "arith.index_cast"(%arg8) : (i32) -> index
      %23 = "arith.index_cast"(%arg9) : (i32) -> index
      %24 = "arith.subi"(%18, %3) : (index, index) -> index
      %25 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%2, %4, %25) ({
      ^bb0(%arg16: index):
        %26 = "arith.index_cast"(%arg16) : (index) -> i32
        %27 = "arith.addi"(%10, %26) : (i32, i32) -> i32
        %28 = "arith.index_cast"(%27) : (i32) -> index
        %29 = "arith.subi"(%17, %28) : (index, index) -> index
        %30 = "arith.addi"(%24, %29) : (index, index) -> index
        %31 = "arith.divui"(%30, %18) : (index, index) -> index
        %32:2 = "scf.for"(%2, %31, %3, %5, %5) ({
        ^bb0(%arg17: index, %arg18: i32, %arg19: i32):
          %33 = "arith.muli"(%arg17, %18) : (index, index) -> index
          %34 = "arith.addi"(%28, %33) : (index, index) -> index
          %35 = "arith.index_cast"(%34) : (index) -> i32
          %36 = "arith.remsi"(%35, %arg15) : (i32, i32) -> i32
          %37 = "arith.divsi"(%35, %arg15) : (i32, i32) -> i32
          %38 = "arith.remsi"(%37, %arg14) : (i32, i32) -> i32
          %39 = "arith.divsi"(%35, %19) : (i32, i32) -> i32
          %40 = "arith.remsi"(%39, %arg5) : (i32, i32) -> i32
          %41 = "arith.divsi"(%35, %20) : (i32, i32) -> i32
          %42 = "arith.addi"(%38, %arg12) : (i32, i32) -> i32
          %43 = "arith.addi"(%36, %arg13) : (i32, i32) -> i32
          %44 = "arith.muli"(%41, %arg4) : (i32, i32) -> i32
          %45:3 = "scf.for"(%2, %21, %3, %arg18, %arg19, %0) ({
          ^bb0(%arg20: index, %arg21: i32, %arg22: i32, %arg23: f32):
            %47 = "arith.index_cast"(%arg20) : (index) -> i32
            %48 = "arith.addi"(%44, %47) : (i32, i32) -> i32
            %49 = "arith.muli"(%48, %arg6) : (i32, i32) -> i32
            %50 = "arith.muli"(%47, %arg5) : (i32, i32) -> i32
            %51 = "arith.addi"(%50, %40) : (i32, i32) -> i32
            %52 = "arith.muli"(%51, %arg8) : (i32, i32) -> i32
            %53:3 = "scf.for"(%2, %22, %3, %arg21, %arg22, %arg23) ({
            ^bb0(%arg24: index, %arg25: i32, %arg26: i32, %arg27: f32):
              %54 = "arith.index_cast"(%arg24) : (index) -> i32
              %55 = "arith.subi"(%42, %54) : (i32, i32) -> i32
              %56 = "arith.remsi"(%55, %arg10) : (i32, i32) -> i32
              %57 = "arith.cmpi"(%56, %1) <{predicate = 0 : i64}> : (i32, i32) -> i1
              %58 = "arith.divsi"(%55, %arg10) : (i32, i32) -> i32
              %59 = "arith.cmpi"(%58, %1) <{predicate = 5 : i64}> : (i32, i32) -> i1
              %60 = "arith.cmpi"(%58, %arg6) <{predicate = 2 : i64}> : (i32, i32) -> i1
              %61 = "arith.addi"(%49, %58) : (i32, i32) -> i32
              %62 = "arith.muli"(%61, %arg7) : (i32, i32) -> i32
              %63 = "arith.addi"(%52, %54) : (i32, i32) -> i32
              %64 = "arith.muli"(%63, %arg9) : (i32, i32) -> i32
              %65:3 = "scf.for"(%2, %23, %3, %arg25, %arg26, %arg27) ({
              ^bb0(%arg28: index, %arg29: i32, %arg30: i32, %arg31: f32):
                %66 = "arith.index_cast"(%arg28) : (index) -> i32
                %67 = "arith.subi"(%43, %66) : (i32, i32) -> i32
                %68 = "arith.divsi"(%67, %arg11) : (i32, i32) -> i32
                %69 = "arith.cmpi"(%68, %1) <{predicate = 5 : i64}> : (i32, i32) -> i1
                %70 = "arith.cmpi"(%68, %arg7) <{predicate = 2 : i64}> : (i32, i32) -> i1
                %71 = "arith.remsi"(%67, %arg11) : (i32, i32) -> i32
                %72 = "arith.cmpi"(%71, %1) <{predicate = 0 : i64}> : (i32, i32) -> i1
                %73 = "arith.andi"(%57, %72) : (i1, i1) -> i1
                %74 = "arith.andi"(%70, %73) : (i1, i1) -> i1
                %75 = "arith.andi"(%69, %74) : (i1, i1) -> i1
                %76 = "arith.andi"(%60, %75) : (i1, i1) -> i1
                %77 = "arith.andi"(%59, %76) : (i1, i1) -> i1
                %78:3 = "scf.if"(%77) ({
                  %79 = "arith.addi"(%62, %68) : (i32, i32) -> i32
                  %80 = "arith.addi"(%64, %66) : (i32, i32) -> i32
                  %81 = "arith.index_cast"(%79) : (i32) -> index
                  %82 = "memref.load"(%arg0, %81) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
                  %83 = "arith.index_cast"(%80) : (i32) -> index
                  %84 = "memref.load"(%arg1, %83) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
                  %85 = "arith.mulf"(%82, %84) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
                  %86 = "arith.addf"(%arg31, %85) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
                  "scf.yield"(%80, %79, %86) : (i32, i32, f32) -> ()
                }, {
                  "scf.yield"(%arg29, %arg30, %arg31) : (i32, i32, f32) -> ()
                }) : (i1) -> (i32, i32, f32)
                "scf.yield"(%78#0, %78#1, %78#2) : (i32, i32, f32) -> ()
              }) : (index, index, index, i32, i32, f32) -> (i32, i32, f32)
              "scf.yield"(%65#0, %65#1, %65#2) : (i32, i32, f32) -> ()
            }) : (index, index, index, i32, i32, f32) -> (i32, i32, f32)
            "scf.yield"(%53#0, %53#1, %53#2) : (i32, i32, f32) -> ()
          }) : (index, index, index, i32, i32, f32) -> (i32, i32, f32)
          %46 = "arith.addi"(%33, %28) : (index, index) -> index
          "memref.store"(%45#2, %arg2, %46) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"(%45#0, %45#1) : (i32, i32) -> ()
        }) : (index, index, index, i32, i32) -> (i32, i32)
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii", workgroup_attributions = 0 : i64} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii_0"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize: end

[ict-debug] GPUBlockIdToNPULowering: process op: 

%6 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%13 = "arith.index_cast"(%12) : (i64) -> i32
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii_0 {
    gpu.func @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) {
      %cst = arith.constant 0.000000e+00 : f32
      %c0_i32 = arith.constant 0 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = llvm.mlir.undef : i32
      %1 = "npu.block_id"() <{dimension = "X"}> : () -> i64
      %2 = arith.index_cast %1 : i64 to index
      %3 = builtin.unrealized_conversion_cast %1 : i64 to index
      %4 = arith.index_cast %2 : index to i32
      %c32_0 = arith.constant 32 : index
      %5 = arith.index_cast %c32_0 : index to i32
      %6 = arith.muli %4, %5 : i32
      %7 = "npu.block_num"() <{dimension = "X"}> : () -> i64
      %8 = emitc.cast %7 : i64 to i32
      %9 = arith.muli %8, %5 : i32
      %10 = arith.muli %arg3, %arg5 : i32
      %11 = arith.muli %10, %arg14 : i32
      %12 = arith.muli %11, %arg15 : i32
      %13 = arith.index_cast %12 : i32 to index
      %14 = arith.index_cast %9 : i32 to index
      %15 = arith.muli %arg15, %arg14 : i32
      %16 = arith.muli %15, %arg5 : i32
      %17 = arith.index_cast %arg4 : i32 to index
      %18 = arith.index_cast %arg8 : i32 to index
      %19 = arith.index_cast %arg9 : i32 to index
      %20 = arith.subi %14, %c1 : index
      %c1_1 = arith.constant 1 : index
      scf.for %arg16 = %c0 to %c32 step %c1_1 {
        %21 = arith.index_cast %arg16 : index to i32
        %22 = arith.addi %6, %21 : i32
        %23 = arith.index_cast %22 : i32 to index
        %24 = arith.subi %13, %23 : index
        %25 = arith.addi %20, %24 : index
        %26 = arith.divui %25, %14 : index
        %27:2 = scf.for %arg17 = %c0 to %26 step %c1 iter_args(%arg18 = %0, %arg19 = %0) -> (i32, i32) {
          %28 = arith.muli %arg17, %14 : index
          %29 = arith.addi %23, %28 : index
          %30 = arith.index_cast %29 : index to i32
          %31 = arith.remsi %30, %arg15 : i32
          %32 = arith.divsi %30, %arg15 : i32
          %33 = arith.remsi %32, %arg14 : i32
          %34 = arith.divsi %30, %15 : i32
          %35 = arith.remsi %34, %arg5 : i32
          %36 = arith.divsi %30, %16 : i32
          %37 = arith.addi %33, %arg12 : i32
          %38 = arith.addi %31, %arg13 : i32
          %39 = arith.muli %36, %arg4 : i32
          %40:3 = scf.for %arg20 = %c0 to %17 step %c1 iter_args(%arg21 = %arg18, %arg22 = %arg19, %arg23 = %cst) -> (i32, i32, f32) {
            %42 = arith.index_cast %arg20 : index to i32
            %43 = arith.addi %39, %42 : i32
            %44 = arith.muli %43, %arg6 : i32
            %45 = arith.muli %42, %arg5 : i32
            %46 = arith.addi %45, %35 : i32
            %47 = arith.muli %46, %arg8 : i32
            %48:3 = scf.for %arg24 = %c0 to %18 step %c1 iter_args(%arg25 = %arg21, %arg26 = %arg22, %arg27 = %arg23) -> (i32, i32, f32) {
              %49 = arith.index_cast %arg24 : index to i32
              %50 = arith.subi %37, %49 : i32
              %51 = arith.remsi %50, %arg10 : i32
              %52 = arith.cmpi eq, %51, %c0_i32 : i32
              %53 = arith.divsi %50, %arg10 : i32
              %54 = arith.cmpi sge, %53, %c0_i32 : i32
              %55 = arith.cmpi slt, %53, %arg6 : i32
              %56 = arith.addi %44, %53 : i32
              %57 = arith.muli %56, %arg7 : i32
              %58 = arith.addi %47, %49 : i32
              %59 = arith.muli %58, %arg9 : i32
              %60:3 = scf.for %arg28 = %c0 to %19 step %c1 iter_args(%arg29 = %arg25, %arg30 = %arg26, %arg31 = %arg27) -> (i32, i32, f32) {
                %61 = arith.index_cast %arg28 : index to i32
                %62 = arith.subi %38, %61 : i32
                %63 = arith.divsi %62, %arg11 : i32
                %64 = arith.cmpi sge, %63, %c0_i32 : i32
                %65 = arith.cmpi slt, %63, %arg7 : i32
                %66 = arith.remsi %62, %arg11 : i32
                %67 = arith.cmpi eq, %66, %c0_i32 : i32
                %68 = arith.andi %52, %67 : i1
                %69 = arith.andi %65, %68 : i1
                %70 = arith.andi %64, %69 : i1
                %71 = arith.andi %55, %70 : i1
                %72 = arith.andi %54, %71 : i1
                %73:3 = scf.if %72 -> (i32, i32, f32) {
                  %74 = arith.addi %57, %63 : i32
                  %75 = arith.addi %59, %61 : i32
                  %76 = arith.index_cast %74 : i32 to index
                  %77 = memref.load %arg0[%76] : memref<?xf32>
                  %78 = arith.index_cast %75 : i32 to index
                  %79 = memref.load %arg1[%78] : memref<?xf32>
                  %80 = emitc.mul %77, %79 : (f32, f32) -> f32
                  %81 = emitc.add %arg31, %80 : (f32, f32) -> f32
                  scf.yield %75, %74, %81 : i32, i32, f32
                } else {
                  scf.yield %arg29, %arg30, %arg31 : i32, i32, f32
                }
                scf.yield %73#0, %73#1, %73#2 : i32, i32, f32
              }
              scf.yield %60#0, %60#1, %60#2 : i32, i32, f32
            }
            scf.yield %48#0, %48#1, %48#2 : i32, i32, f32
          }
          %41 = arith.addi %28, %23 : index
          memref.store %40#2, %arg2[%41] : memref<?xf32>
          scf.yield %40#0, %40#1 : i32, i32
        }
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU: end

[ict-debug] driver.cc: Before convert to EmitC dialect:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii_0 {
    gpu.func @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) {
      %c32_i32 = arith.constant 32 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c0_i32 = arith.constant 0 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = llvm.mlir.undef : i32
      %1 = "npu.block_id"() <{dimension = "X"}> : () -> i64
      %2 = arith.index_cast %1 : i64 to index
      %3 = arith.index_cast %2 : index to i32
      %4 = arith.muli %3, %c32_i32 : i32
      %5 = "npu.block_num"() <{dimension = "X"}> : () -> i64
      %6 = emitc.cast %5 : i64 to i32
      %7 = arith.muli %6, %c32_i32 : i32
      %8 = arith.muli %arg3, %arg5 : i32
      %9 = arith.muli %8, %arg14 : i32
      %10 = arith.muli %9, %arg15 : i32
      %11 = arith.index_cast %10 : i32 to index
      %12 = arith.index_cast %7 : i32 to index
      %13 = arith.muli %arg15, %arg14 : i32
      %14 = arith.muli %13, %arg5 : i32
      %15 = arith.index_cast %arg4 : i32 to index
      %16 = arith.index_cast %arg8 : i32 to index
      %17 = arith.index_cast %arg9 : i32 to index
      %18 = arith.subi %12, %c1 : index
      scf.for %arg16 = %c0 to %c32 step %c1 {
        %19 = arith.index_cast %arg16 : index to i32
        %20 = arith.addi %4, %19 : i32
        %21 = arith.index_cast %20 : i32 to index
        %22 = arith.subi %11, %21 : index
        %23 = arith.addi %18, %22 : index
        %24 = arith.divui %23, %12 : index
        %25:2 = scf.for %arg17 = %c0 to %24 step %c1 iter_args(%arg18 = %0, %arg19 = %0) -> (i32, i32) {
          %26 = arith.muli %arg17, %12 : index
          %27 = arith.addi %21, %26 : index
          %28 = arith.index_cast %27 : index to i32
          %29 = arith.remsi %28, %arg15 : i32
          %30 = arith.divsi %28, %arg15 : i32
          %31 = arith.remsi %30, %arg14 : i32
          %32 = arith.divsi %28, %13 : i32
          %33 = arith.remsi %32, %arg5 : i32
          %34 = arith.divsi %28, %14 : i32
          %35 = arith.addi %31, %arg12 : i32
          %36 = arith.addi %29, %arg13 : i32
          %37 = arith.muli %34, %arg4 : i32
          %38:3 = scf.for %arg20 = %c0 to %15 step %c1 iter_args(%arg21 = %arg18, %arg22 = %arg19, %arg23 = %cst) -> (i32, i32, f32) {
            %40 = arith.index_cast %arg20 : index to i32
            %41 = arith.addi %37, %40 : i32
            %42 = arith.muli %41, %arg6 : i32
            %43 = arith.muli %40, %arg5 : i32
            %44 = arith.addi %43, %33 : i32
            %45 = arith.muli %44, %arg8 : i32
            %46:3 = scf.for %arg24 = %c0 to %16 step %c1 iter_args(%arg25 = %arg21, %arg26 = %arg22, %arg27 = %arg23) -> (i32, i32, f32) {
              %47 = arith.index_cast %arg24 : index to i32
              %48 = arith.subi %35, %47 : i32
              %49 = arith.remsi %48, %arg10 : i32
              %50 = arith.cmpi eq, %49, %c0_i32 : i32
              %51 = arith.divsi %48, %arg10 : i32
              %52 = arith.cmpi sge, %51, %c0_i32 : i32
              %53 = arith.cmpi slt, %51, %arg6 : i32
              %54 = arith.addi %42, %51 : i32
              %55 = arith.muli %54, %arg7 : i32
              %56 = arith.addi %45, %47 : i32
              %57 = arith.muli %56, %arg9 : i32
              %58:3 = scf.for %arg28 = %c0 to %17 step %c1 iter_args(%arg29 = %arg25, %arg30 = %arg26, %arg31 = %arg27) -> (i32, i32, f32) {
                %59 = arith.index_cast %arg28 : index to i32
                %60 = arith.subi %36, %59 : i32
                %61 = arith.divsi %60, %arg11 : i32
                %62 = arith.cmpi sge, %61, %c0_i32 : i32
                %63 = arith.cmpi slt, %61, %arg7 : i32
                %64 = arith.remsi %60, %arg11 : i32
                %65 = arith.cmpi eq, %64, %c0_i32 : i32
                %66 = arith.andi %50, %65 : i1
                %67 = arith.andi %63, %66 : i1
                %68 = arith.andi %62, %67 : i1
                %69 = arith.andi %53, %68 : i1
                %70 = arith.andi %52, %69 : i1
                %71:3 = scf.if %70 -> (i32, i32, f32) {
                  %72 = arith.addi %55, %61 : i32
                  %73 = arith.addi %57, %59 : i32
                  %74 = arith.index_cast %72 : i32 to index
                  %75 = memref.load %arg0[%74] : memref<?xf32>
                  %76 = arith.index_cast %73 : i32 to index
                  %77 = memref.load %arg1[%76] : memref<?xf32>
                  %78 = emitc.mul %75, %77 : (f32, f32) -> f32
                  %79 = emitc.add %arg31, %78 : (f32, f32) -> f32
                  scf.yield %73, %72, %79 : i32, i32, f32
                } else {
                  scf.yield %arg29, %arg30, %arg31 : i32, i32, f32
                }
                scf.yield %71#0, %71#1, %71#2 : i32, i32, f32
              }
              scf.yield %58#0, %58#1, %58#2 : i32, i32, f32
            }
            scf.yield %46#0, %46#1, %46#2 : i32, i32, f32
          }
          %39 = arith.addi %26, %21 : index
          memref.store %38#2, %arg2[%39] : memref<?xf32>
          scf.yield %38#0, %38#1 : i32, i32
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: Before convert to EmitC dialect: end

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii_0 {
    gpu.func @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) {
      %c32_i32 = arith.constant 32 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c0_i32 = arith.constant 0 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = llvm.mlir.undef : i32
      %1 = "npu.block_id"() <{dimension = "X"}> : () -> i64
      %2 = arith.index_cast %1 : i64 to index
      %3 = arith.index_cast %2 : index to i32
      %4 = arith.muli %3, %c32_i32 : i32
      %5 = "npu.block_num"() <{dimension = "X"}> : () -> i64
      %6 = emitc.cast %5 : i64 to i32
      %7 = arith.muli %6, %c32_i32 : i32
      %8 = arith.muli %arg3, %arg5 : i32
      %9 = arith.muli %8, %arg14 : i32
      %10 = arith.muli %9, %arg15 : i32
      %11 = arith.index_cast %10 : i32 to index
      %12 = arith.index_cast %7 : i32 to index
      %13 = arith.muli %arg15, %arg14 : i32
      %14 = arith.muli %13, %arg5 : i32
      %15 = arith.index_cast %arg4 : i32 to index
      %16 = arith.index_cast %arg8 : i32 to index
      %17 = arith.index_cast %arg9 : i32 to index
      %18 = arith.subi %12, %c1 : index
      scf.for %arg16 = %c0 to %c32 step %c1 {
        %19 = arith.index_cast %arg16 : index to i32
        %20 = arith.addi %4, %19 : i32
        %21 = arith.index_cast %20 : i32 to index
        %22 = arith.subi %11, %21 : index
        %23 = arith.addi %18, %22 : index
        %24 = arith.divui %23, %12 : index
        %25:2 = scf.for %arg17 = %c0 to %24 step %c1 iter_args(%arg18 = %0, %arg19 = %0) -> (i32, i32) {
          %26 = arith.muli %arg17, %12 : index
          %27 = arith.addi %21, %26 : index
          %28 = arith.index_cast %27 : index to i32
          %29 = arith.remsi %28, %arg15 : i32
          %30 = arith.divsi %28, %arg15 : i32
          %31 = arith.remsi %30, %arg14 : i32
          %32 = arith.divsi %28, %13 : i32
          %33 = arith.remsi %32, %arg5 : i32
          %34 = arith.divsi %28, %14 : i32
          %35 = arith.addi %31, %arg12 : i32
          %36 = arith.addi %29, %arg13 : i32
          %37 = arith.muli %34, %arg4 : i32
          %38:3 = scf.for %arg20 = %c0 to %15 step %c1 iter_args(%arg21 = %arg18, %arg22 = %arg19, %arg23 = %cst) -> (i32, i32, f32) {
            %40 = arith.index_cast %arg20 : index to i32
            %41 = arith.addi %37, %40 : i32
            %42 = arith.muli %41, %arg6 : i32
            %43 = arith.muli %40, %arg5 : i32
            %44 = arith.addi %43, %33 : i32
            %45 = arith.muli %44, %arg8 : i32
            %46:3 = scf.for %arg24 = %c0 to %16 step %c1 iter_args(%arg25 = %arg21, %arg26 = %arg22, %arg27 = %arg23) -> (i32, i32, f32) {
              %47 = arith.index_cast %arg24 : index to i32
              %48 = arith.subi %35, %47 : i32
              %49 = arith.remsi %48, %arg10 : i32
              %50 = arith.cmpi eq, %49, %c0_i32 : i32
              %51 = arith.divsi %48, %arg10 : i32
              %52 = arith.cmpi sge, %51, %c0_i32 : i32
              %53 = arith.cmpi slt, %51, %arg6 : i32
              %54 = arith.addi %42, %51 : i32
              %55 = arith.muli %54, %arg7 : i32
              %56 = arith.addi %45, %47 : i32
              %57 = arith.muli %56, %arg9 : i32
              %58:3 = scf.for %arg28 = %c0 to %17 step %c1 iter_args(%arg29 = %arg25, %arg30 = %arg26, %arg31 = %arg27) -> (i32, i32, f32) {
                %59 = arith.index_cast %arg28 : index to i32
                %60 = arith.subi %36, %59 : i32
                %61 = arith.divsi %60, %arg11 : i32
                %62 = arith.cmpi sge, %61, %c0_i32 : i32
                %63 = arith.cmpi slt, %61, %arg7 : i32
                %64 = arith.remsi %60, %arg11 : i32
                %65 = arith.cmpi eq, %64, %c0_i32 : i32
                %66 = arith.andi %50, %65 : i1
                %67 = arith.andi %63, %66 : i1
                %68 = arith.andi %62, %67 : i1
                %69 = arith.andi %53, %68 : i1
                %70 = arith.andi %52, %69 : i1
                %71 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> i32
                %72 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> i32
                %73 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> f32
                emitc.if %70 {
                  %74 = arith.addi %55, %61 : i32
                  %75 = arith.addi %57, %59 : i32
                  %76 = arith.index_cast %74 : i32 to index
                  %77 = memref.load %arg0[%76] : memref<?xf32>
                  %78 = arith.index_cast %75 : i32 to index
                  %79 = memref.load %arg1[%78] : memref<?xf32>
                  %80 = emitc.mul %77, %79 : (f32, f32) -> f32
                  %81 = emitc.add %arg31, %80 : (f32, f32) -> f32
                  emitc.assign %75 : i32 to %71 : i32
                  emitc.assign %74 : i32 to %72 : i32
                  emitc.assign %81 : f32 to %73 : f32
                } else {
                  emitc.assign %arg29 : i32 to %71 : i32
                  emitc.assign %arg30 : i32 to %72 : i32
                  emitc.assign %arg31 : f32 to %73 : f32
                }
                scf.yield %71, %72, %73 : i32, i32, f32
              }
              scf.yield %58#0, %58#1, %58#2 : i32, i32, f32
            }
            scf.yield %46#0, %46#1, %46#2 : i32, i32, f32
          }
          %39 = arith.addi %26, %21 : index
          memref.store %38#2, %arg2[%39] : memref<?xf32>
          scf.yield %38#0, %38#1 : i32, i32
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: After convert to EmitC dialect:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii_0 {
    gpu.func @_Z23conv_transpose2d_kernelPKfS0_Pfiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32) {
      %c32_i32 = arith.constant 32 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c0_i32 = arith.constant 0 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = llvm.mlir.undef : i32
      %1 = "npu.block_id"() <{dimension = "X"}> : () -> i64
      %2 = arith.index_cast %1 : i64 to index
      %3 = arith.index_cast %2 : index to i32
      %4 = arith.muli %3, %c32_i32 : i32
      %5 = "npu.block_num"() <{dimension = "X"}> : () -> i64
      %6 = emitc.cast %5 : i64 to i32
      %7 = arith.muli %6, %c32_i32 : i32
      %8 = arith.muli %arg3, %arg5 : i32
      %9 = arith.muli %8, %arg14 : i32
      %10 = arith.muli %9, %arg15 : i32
      %11 = arith.index_cast %10 : i32 to index
      %12 = arith.index_cast %7 : i32 to index
      %13 = arith.muli %arg15, %arg14 : i32
      %14 = arith.muli %13, %arg5 : i32
      %15 = arith.index_cast %arg4 : i32 to index
      %16 = arith.index_cast %arg8 : i32 to index
      %17 = arith.index_cast %arg9 : i32 to index
      %18 = arith.subi %12, %c1 : index
      scf.for %arg16 = %c0 to %c32 step %c1 {
        %19 = arith.index_cast %arg16 : index to i32
        %20 = arith.addi %4, %19 : i32
        %21 = arith.index_cast %20 : i32 to index
        %22 = arith.subi %11, %21 : index
        %23 = arith.addi %18, %22 : index
        %24 = arith.divui %23, %12 : index
        %25:2 = scf.for %arg17 = %c0 to %24 step %c1 iter_args(%arg18 = %0, %arg19 = %0) -> (i32, i32) {
          %26 = arith.muli %arg17, %12 : index
          %27 = arith.addi %21, %26 : index
          %28 = arith.index_cast %27 : index to i32
          %29 = arith.remsi %28, %arg15 : i32
          %30 = arith.divsi %28, %arg15 : i32
          %31 = arith.remsi %30, %arg14 : i32
          %32 = arith.divsi %28, %13 : i32
          %33 = arith.remsi %32, %arg5 : i32
          %34 = arith.divsi %28, %14 : i32
          %35 = arith.addi %31, %arg12 : i32
          %36 = arith.addi %29, %arg13 : i32
          %37 = arith.muli %34, %arg4 : i32
          %38:3 = scf.for %arg20 = %c0 to %15 step %c1 iter_args(%arg21 = %arg18, %arg22 = %arg19, %arg23 = %cst) -> (i32, i32, f32) {
            %40 = arith.index_cast %arg20 : index to i32
            %41 = arith.addi %37, %40 : i32
            %42 = arith.muli %41, %arg6 : i32
            %43 = arith.muli %40, %arg5 : i32
            %44 = arith.addi %43, %33 : i32
            %45 = arith.muli %44, %arg8 : i32
            %46:3 = scf.for %arg24 = %c0 to %16 step %c1 iter_args(%arg25 = %arg21, %arg26 = %arg22, %arg27 = %arg23) -> (i32, i32, f32) {
              %47 = arith.index_cast %arg24 : index to i32
              %48 = arith.subi %35, %47 : i32
              %49 = arith.remsi %48, %arg10 : i32
              %50 = arith.cmpi eq, %49, %c0_i32 : i32
              %51 = arith.divsi %48, %arg10 : i32
              %52 = arith.cmpi sge, %51, %c0_i32 : i32
              %53 = arith.cmpi slt, %51, %arg6 : i32
              %54 = arith.addi %42, %51 : i32
              %55 = arith.muli %54, %arg7 : i32
              %56 = arith.addi %45, %47 : i32
              %57 = arith.muli %56, %arg9 : i32
              %58:3 = scf.for %arg28 = %c0 to %17 step %c1 iter_args(%arg29 = %arg25, %arg30 = %arg26, %arg31 = %arg27) -> (i32, i32, f32) {
                %59 = arith.index_cast %arg28 : index to i32
                %60 = arith.subi %36, %59 : i32
                %61 = arith.divsi %60, %arg11 : i32
                %62 = arith.cmpi sge, %61, %c0_i32 : i32
                %63 = arith.cmpi slt, %61, %arg7 : i32
                %64 = arith.remsi %60, %arg11 : i32
                %65 = arith.cmpi eq, %64, %c0_i32 : i32
                %66 = arith.andi %50, %65 : i1
                %67 = arith.andi %63, %66 : i1
                %68 = arith.andi %62, %67 : i1
                %69 = arith.andi %53, %68 : i1
                %70 = arith.andi %52, %69 : i1
                %71 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> i32
                %72 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> i32
                %73 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> f32
                emitc.if %70 {
                  %74 = arith.addi %55, %61 : i32
                  %75 = arith.addi %57, %59 : i32
                  %76 = arith.index_cast %74 : i32 to index
                  %77 = memref.load %arg0[%76] : memref<?xf32>
                  %78 = arith.index_cast %75 : i32 to index
                  %79 = memref.load %arg1[%78] : memref<?xf32>
                  %80 = emitc.mul %77, %79 : (f32, f32) -> f32
                  %81 = emitc.add %arg31, %80 : (f32, f32) -> f32
                  emitc.assign %75 : i32 to %71 : i32
                  emitc.assign %74 : i32 to %72 : i32
                  emitc.assign %81 : f32 to %73 : f32
                } else {
                  emitc.assign %arg29 : i32 to %71 : i32
                  emitc.assign %arg30 : i32 to %72 : i32
                  emitc.assign %arg31 : f32 to %73 : f32
                }
                scf.yield %71, %72, %73 : i32, i32, f32
              }
              scf.yield %58#0, %58#1, %58#2 : i32, i32, f32
            }
            scf.yield %46#0, %46#1, %46#2 : i32, i32, f32
          }
          %39 = arith.addi %26, %21 : index
          memref.store %38#2, %arg2[%39] : memref<?xf32>
          scf.yield %38#0, %38#1 : i32, i32
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: After convert to EmitC dialect: end

loc("/CUDA2BANG/Cambricon_NaiveProfiling/cuda_ops_test/Ascend_kernels/gen_cuda_kernels/level_1_prlblem_78_sample_0_conv_transposed_2D_asymmetric_input_asymmetric_kernel___padded__.cu":45:29): error: 'llvm.mlir.undef' op unable to find printer for op
[ict-debug] driver.cc: After emitc::translateToCpp:

