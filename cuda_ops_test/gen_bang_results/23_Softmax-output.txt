warning: CUDA version 12.1 is only partially supported
warning: CUDA version 12.1 is only partially supported
warning: we failed to emit call to builtin function __builtin_inff
warning: we failed to emit call to builtin function __builtin_inff
warning: we failed to emit call to builtin function __builtin_inff
warning: we failed to emit call to builtin function __builtin_inff
warning: we failed to emit call to builtin function __builtin_inff
[ict-debug] driver.cc: After return 5, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @shared_mem : memref<1xf32>
  func.func @_Z20softmax_forward_cudaPKfPfiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
    %c512_i32 = arith.constant 512 : i32
    %c256_i32 = arith.constant 256 : i32
    %c128_i32 = arith.constant 128 : i32
    %c64_i32 = arith.constant 64 : i32
    %c32_i32 = arith.constant 32 : i32
    %c1_i32 = arith.constant 1 : i32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_3 = memref.cast %alloca_2 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_4 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_5 = memref.cast %alloca_4 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_6 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_7 = memref.cast %alloca_6 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_8 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_9 = memref.cast %alloca_8 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_10 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_11 = memref.cast %alloca_10 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_12 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_13 = memref.cast %alloca_12 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_14 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_15 = memref.cast %alloca_14 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_16 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_17 = memref.cast %alloca_16 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_18 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_19 = memref.cast %alloca_18 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_20 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_21 = memref.cast %alloca_20 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_22 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_23 = memref.cast %alloca_22 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_24 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_25 = memref.cast %alloca_24 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_26 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_27 = memref.cast %alloca_26 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_28 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_29 = memref.cast %alloca_28 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_30 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_31 = memref.cast %alloca_30 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_32 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_33 = memref.cast %alloca_32 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_34 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_35 = memref.cast %alloca_34 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    call @_ZN4dim3C1Ejjj(%cast_35, %arg2, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    cf.switch %arg4 : i32, [
      default: ^bb6,
      32: ^bb1,
      64: ^bb2,
      128: ^bb3,
      256: ^bb4,
      512: ^bb5
    ]
  ^bb1:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_33, %c32_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_31, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %0 = "polygeist.memref2pointer"(%alloca_30) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.getelementptr %0[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %2 = llvm.load %1 : !llvm.ptr -> i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %5 = llvm.load %4 : !llvm.ptr -> i32
    %6 = arith.index_cast %5 : i32 to index
    %7 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %8 = llvm.load %7 : !llvm.ptr -> i32
    %9 = arith.index_cast %8 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_29, %cast_33) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %10 = "polygeist.memref2pointer"(%alloca_28) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %11 = llvm.getelementptr %10[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %12 = llvm.load %11 : !llvm.ptr -> i32
    %13 = arith.index_cast %12 : i32 to index
    %14 = llvm.getelementptr %10[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %15 = llvm.load %14 : !llvm.ptr -> i32
    %16 = arith.index_cast %15 : i32 to index
    %17 = llvm.getelementptr %10[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %18 = llvm.load %17 : !llvm.ptr -> i32
    %19 = arith.index_cast %18 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %3, %arg12 = %6, %arg13 = %9) threads(%arg8, %arg9, %arg10) in (%arg14 = %13, %arg15 = %16, %arg16 = %19) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb2:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_27, %c64_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_25, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %20 = "polygeist.memref2pointer"(%alloca_24) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %21 = llvm.getelementptr %20[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %22 = llvm.load %21 : !llvm.ptr -> i32
    %23 = arith.index_cast %22 : i32 to index
    %24 = llvm.getelementptr %20[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %25 = llvm.load %24 : !llvm.ptr -> i32
    %26 = arith.index_cast %25 : i32 to index
    %27 = llvm.getelementptr %20[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %28 = llvm.load %27 : !llvm.ptr -> i32
    %29 = arith.index_cast %28 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_23, %cast_27) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %30 = "polygeist.memref2pointer"(%alloca_22) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %31 = llvm.getelementptr %30[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %32 = llvm.load %31 : !llvm.ptr -> i32
    %33 = arith.index_cast %32 : i32 to index
    %34 = llvm.getelementptr %30[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %35 = llvm.load %34 : !llvm.ptr -> i32
    %36 = arith.index_cast %35 : i32 to index
    %37 = llvm.getelementptr %30[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %38 = llvm.load %37 : !llvm.ptr -> i32
    %39 = arith.index_cast %38 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %23, %arg12 = %26, %arg13 = %29) threads(%arg8, %arg9, %arg10) in (%arg14 = %33, %arg15 = %36, %arg16 = %39) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb3:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_21, %c128_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_19, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %40 = "polygeist.memref2pointer"(%alloca_18) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %41 = llvm.getelementptr %40[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %42 = llvm.load %41 : !llvm.ptr -> i32
    %43 = arith.index_cast %42 : i32 to index
    %44 = llvm.getelementptr %40[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %45 = llvm.load %44 : !llvm.ptr -> i32
    %46 = arith.index_cast %45 : i32 to index
    %47 = llvm.getelementptr %40[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %48 = llvm.load %47 : !llvm.ptr -> i32
    %49 = arith.index_cast %48 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_17, %cast_21) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %50 = "polygeist.memref2pointer"(%alloca_16) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %51 = llvm.getelementptr %50[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %52 = llvm.load %51 : !llvm.ptr -> i32
    %53 = arith.index_cast %52 : i32 to index
    %54 = llvm.getelementptr %50[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %55 = llvm.load %54 : !llvm.ptr -> i32
    %56 = arith.index_cast %55 : i32 to index
    %57 = llvm.getelementptr %50[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %58 = llvm.load %57 : !llvm.ptr -> i32
    %59 = arith.index_cast %58 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %43, %arg12 = %46, %arg13 = %49) threads(%arg8, %arg9, %arg10) in (%arg14 = %53, %arg15 = %56, %arg16 = %59) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb4:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_15, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_13, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %60 = "polygeist.memref2pointer"(%alloca_12) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %61 = llvm.getelementptr %60[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %62 = llvm.load %61 : !llvm.ptr -> i32
    %63 = arith.index_cast %62 : i32 to index
    %64 = llvm.getelementptr %60[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %65 = llvm.load %64 : !llvm.ptr -> i32
    %66 = arith.index_cast %65 : i32 to index
    %67 = llvm.getelementptr %60[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %68 = llvm.load %67 : !llvm.ptr -> i32
    %69 = arith.index_cast %68 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_11, %cast_15) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %70 = "polygeist.memref2pointer"(%alloca_10) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %71 = llvm.getelementptr %70[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %72 = llvm.load %71 : !llvm.ptr -> i32
    %73 = arith.index_cast %72 : i32 to index
    %74 = llvm.getelementptr %70[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %75 = llvm.load %74 : !llvm.ptr -> i32
    %76 = arith.index_cast %75 : i32 to index
    %77 = llvm.getelementptr %70[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %78 = llvm.load %77 : !llvm.ptr -> i32
    %79 = arith.index_cast %78 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %63, %arg12 = %66, %arg13 = %69) threads(%arg8, %arg9, %arg10) in (%arg14 = %73, %arg15 = %76, %arg16 = %79) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb5:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_9, %c512_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_7, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %80 = "polygeist.memref2pointer"(%alloca_6) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %81 = llvm.getelementptr %80[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %82 = llvm.load %81 : !llvm.ptr -> i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = llvm.getelementptr %80[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %85 = llvm.load %84 : !llvm.ptr -> i32
    %86 = arith.index_cast %85 : i32 to index
    %87 = llvm.getelementptr %80[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %88 = llvm.load %87 : !llvm.ptr -> i32
    %89 = arith.index_cast %88 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_5, %cast_9) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %90 = "polygeist.memref2pointer"(%alloca_4) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %91 = llvm.getelementptr %90[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %92 = llvm.load %91 : !llvm.ptr -> i32
    %93 = arith.index_cast %92 : i32 to index
    %94 = llvm.getelementptr %90[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %95 = llvm.load %94 : !llvm.ptr -> i32
    %96 = arith.index_cast %95 : i32 to index
    %97 = llvm.getelementptr %90[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %98 = llvm.load %97 : !llvm.ptr -> i32
    %99 = arith.index_cast %98 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %83, %arg12 = %86, %arg13 = %89) threads(%arg8, %arg9, %arg10) in (%arg14 = %93, %arg15 = %96, %arg16 = %99) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb6:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_3, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_1, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %100 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %101 = llvm.getelementptr %100[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %102 = llvm.load %101 : !llvm.ptr -> i32
    %103 = arith.index_cast %102 : i32 to index
    %104 = llvm.getelementptr %100[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %105 = llvm.load %104 : !llvm.ptr -> i32
    %106 = arith.index_cast %105 : i32 to index
    %107 = llvm.getelementptr %100[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %108 = llvm.load %107 : !llvm.ptr -> i32
    %109 = arith.index_cast %108 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast, %cast_3) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %110 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %111 = llvm.getelementptr %110[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %112 = llvm.load %111 : !llvm.ptr -> i32
    %113 = arith.index_cast %112 : i32 to index
    %114 = llvm.getelementptr %110[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %115 = llvm.load %114 : !llvm.ptr -> i32
    %116 = arith.index_cast %115 : i32 to index
    %117 = llvm.getelementptr %110[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %118 = llvm.load %117 : !llvm.ptr -> i32
    %119 = arith.index_cast %118 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %103, %arg12 = %106, %arg13 = %109) threads(%arg8, %arg9, %arg10) in (%arg14 = %113, %arg15 = %116, %arg16 = %119) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb7:  // 6 preds: ^bb1, ^bb2, ^bb3, ^bb4, ^bb5, ^bb6
    return
  }
  func.func private @_ZN4dim3C1Ejjj(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: i32, %arg2: i32, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %arg1, %0 : i32, !llvm.ptr
    %1 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg2, %1 : i32, !llvm.ptr
    %2 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg3, %2 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_ZN4dim3C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> i32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %1, %2 : i32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %4 = llvm.load %3 : !llvm.ptr -> i32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %4, %5 : i32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %7 = llvm.load %6 : !llvm.ptr -> i32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %7, %8 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c32 = arith.constant 32 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c16_i32 = arith.constant 16 : i32
    %alloca = memref.alloca() : memref<1xf32, 5>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = arith.muli %1, %arg2 : i32
    %7 = arith.index_cast %6 : i32 to index
    %8 = call @__builtin_inff() : () -> f32
    %9 = arith.negf %8 : f32
    %10 = arith.index_cast %arg2 : i32 to index
    %11 = affine.for %arg3 = %2 to %10 step 32 iter_args(%arg4 = %9) -> (f32) {
      %19 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %20 = arith.maxnumf %arg4, %19 : f32
      affine.yield %20 : f32
    }
    affine.store %11, %alloca[symbol(%2)] : memref<1xf32, 5>
    nvvm.barrier0
    %12 = scf.while (%arg3 = %c16_i32) : (i32) -> i32 {
      %19 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%19) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %19 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %19 {
        %21 = affine.load %alloca[symbol(%2)] : memref<1xf32, 5>
        %22 = arith.addi %3, %arg3 : i32
        %23 = arith.index_cast %22 : i32 to index
        %24 = memref.load %alloca[%23] : memref<1xf32, 5>
        %25 = arith.maxnumf %21, %24 : f32
        affine.store %25, %alloca[symbol(%2)] : memref<1xf32, 5>
      }
      nvvm.barrier0
      %20 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %20 : i32
    }
    %13 = affine.load %alloca[0] : memref<1xf32, 5>
    nvvm.barrier0
    %14 = arith.index_cast %arg2 : i32 to index
    %15 = affine.for %arg3 = %2 to %14 step 32 iter_args(%arg4 = %cst) -> (f32) {
      %19 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %20 = arith.subf %19, %13 : f32
      %21 = math.exp %20 : f32
      affine.store %21, %arg1[%arg3 + symbol(%7)] : memref<?xf32>
      %22 = arith.addf %arg4, %21 : f32
      affine.yield %22 : f32
    }
    affine.store %15, %alloca[symbol(%2) + 32] : memref<1xf32, 5>
    nvvm.barrier0
    %16 = scf.while (%arg3 = %c16_i32) : (i32) -> i32 {
      %19 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%19) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %19 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %19 {
        %21 = arith.addi %3, %arg3 : i32
        %22 = arith.index_cast %21 : i32 to index
        %23 = arith.addi %22, %c32 : index
        %24 = memref.load %alloca[%23] : memref<1xf32, 5>
        %25 = affine.load %alloca[symbol(%2) + 32] : memref<1xf32, 5>
        %26 = arith.addf %25, %24 : f32
        affine.store %26, %alloca[symbol(%2) + 32] : memref<1xf32, 5>
      }
      nvvm.barrier0
      %20 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %20 : i32
    }
    %17 = affine.load %alloca[32] : memref<1xf32, 5>
    nvvm.barrier0
    %18 = arith.index_cast %arg2 : i32 to index
    affine.for %arg3 = %2 to %18 step 32 {
      %19 = affine.load %arg1[%arg3 + symbol(%7)] : memref<?xf32>
      %20 = arith.divf %19, %17 : f32
      affine.store %20, %arg1[%arg3 + symbol(%7)] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c64 = arith.constant 64 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c32_i32 = arith.constant 32 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = arith.muli %1, %arg2 : i32
    %7 = arith.index_cast %6 : i32 to index
    %8 = memref.get_global @shared_mem : memref<1xf32>
    %9 = memref.get_global @shared_mem : memref<1xf32>
    %10 = call @__builtin_inff() : () -> f32
    %11 = arith.negf %10 : f32
    %12 = arith.index_cast %arg2 : i32 to index
    %13 = affine.for %arg3 = %2 to %12 step 64 iter_args(%arg4 = %11) -> (f32) {
      %21 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %22 = arith.maxnumf %arg4, %21 : f32
      affine.yield %22 : f32
    }
    affine.store %13, %8[symbol(%2)] : memref<1xf32>
    nvvm.barrier0
    %14 = scf.while (%arg3 = %c32_i32) : (i32) -> i32 {
      %21 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%21) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %21 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %21 {
        %23 = affine.load %8[symbol(%2)] : memref<1xf32>
        %24 = arith.addi %3, %arg3 : i32
        %25 = arith.index_cast %24 : i32 to index
        %26 = memref.load %8[%25] : memref<1xf32>
        %27 = arith.maxnumf %23, %26 : f32
        affine.store %27, %8[symbol(%2)] : memref<1xf32>
      }
      nvvm.barrier0
      %22 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %22 : i32
    }
    %15 = affine.load %8[0] : memref<1xf32>
    nvvm.barrier0
    %16 = arith.index_cast %arg2 : i32 to index
    %17 = affine.for %arg3 = %2 to %16 step 64 iter_args(%arg4 = %cst) -> (f32) {
      %21 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %22 = arith.subf %21, %15 : f32
      %23 = math.exp %22 : f32
      affine.store %23, %arg1[%arg3 + symbol(%7)] : memref<?xf32>
      %24 = arith.addf %arg4, %23 : f32
      affine.yield %24 : f32
    }
    affine.store %17, %9[symbol(%2) + 64] : memref<1xf32>
    nvvm.barrier0
    %18 = scf.while (%arg3 = %c32_i32) : (i32) -> i32 {
      %21 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%21) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %21 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %21 {
        %23 = arith.addi %3, %arg3 : i32
        %24 = arith.index_cast %23 : i32 to index
        %25 = arith.addi %24, %c64 : index
        %26 = memref.load %9[%25] : memref<1xf32>
        %27 = affine.load %9[symbol(%2) + 64] : memref<1xf32>
        %28 = arith.addf %27, %26 : f32
        affine.store %28, %9[symbol(%2) + 64] : memref<1xf32>
      }
      nvvm.barrier0
      %22 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %22 : i32
    }
    %19 = affine.load %9[64] : memref<1xf32>
    nvvm.barrier0
    %20 = arith.index_cast %arg2 : i32 to index
    affine.for %arg3 = %2 to %20 step 64 {
      %21 = affine.load %arg1[%arg3 + symbol(%7)] : memref<?xf32>
      %22 = arith.divf %21, %19 : f32
      affine.store %22, %arg1[%arg3 + symbol(%7)] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c64_i32 = arith.constant 64 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = arith.muli %1, %arg2 : i32
    %7 = arith.index_cast %6 : i32 to index
    %8 = memref.get_global @shared_mem : memref<1xf32>
    %9 = memref.get_global @shared_mem : memref<1xf32>
    %10 = call @__builtin_inff() : () -> f32
    %11 = arith.negf %10 : f32
    %12 = arith.index_cast %arg2 : i32 to index
    %13 = affine.for %arg3 = %2 to %12 step 128 iter_args(%arg4 = %11) -> (f32) {
      %21 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %22 = arith.maxnumf %arg4, %21 : f32
      affine.yield %22 : f32
    }
    affine.store %13, %8[symbol(%2)] : memref<1xf32>
    nvvm.barrier0
    %14 = scf.while (%arg3 = %c64_i32) : (i32) -> i32 {
      %21 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%21) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %21 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %21 {
        %23 = affine.load %8[symbol(%2)] : memref<1xf32>
        %24 = arith.addi %3, %arg3 : i32
        %25 = arith.index_cast %24 : i32 to index
        %26 = memref.load %8[%25] : memref<1xf32>
        %27 = arith.maxnumf %23, %26 : f32
        affine.store %27, %8[symbol(%2)] : memref<1xf32>
      }
      nvvm.barrier0
      %22 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %22 : i32
    }
    %15 = affine.load %8[0] : memref<1xf32>
    nvvm.barrier0
    %16 = arith.index_cast %arg2 : i32 to index
    %17 = affine.for %arg3 = %2 to %16 step 128 iter_args(%arg4 = %cst) -> (f32) {
      %21 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %22 = arith.subf %21, %15 : f32
      %23 = math.exp %22 : f32
      affine.store %23, %arg1[%arg3 + symbol(%7)] : memref<?xf32>
      %24 = arith.addf %arg4, %23 : f32
      affine.yield %24 : f32
    }
    affine.store %17, %9[symbol(%2) + 128] : memref<1xf32>
    nvvm.barrier0
    %18 = scf.while (%arg3 = %c64_i32) : (i32) -> i32 {
      %21 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%21) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %21 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %21 {
        %23 = arith.addi %3, %arg3 : i32
        %24 = arith.index_cast %23 : i32 to index
        %25 = arith.addi %24, %c128 : index
        %26 = memref.load %9[%25] : memref<1xf32>
        %27 = affine.load %9[symbol(%2) + 128] : memref<1xf32>
        %28 = arith.addf %27, %26 : f32
        affine.store %28, %9[symbol(%2) + 128] : memref<1xf32>
      }
      nvvm.barrier0
      %22 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %22 : i32
    }
    %19 = affine.load %9[128] : memref<1xf32>
    nvvm.barrier0
    %20 = arith.index_cast %arg2 : i32 to index
    affine.for %arg3 = %2 to %20 step 128 {
      %21 = affine.load %arg1[%arg3 + symbol(%7)] : memref<?xf32>
      %22 = arith.divf %21, %19 : f32
      affine.store %22, %arg1[%arg3 + symbol(%7)] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c256 = arith.constant 256 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c128_i32 = arith.constant 128 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = arith.muli %1, %arg2 : i32
    %7 = arith.index_cast %6 : i32 to index
    %8 = memref.get_global @shared_mem : memref<1xf32>
    %9 = memref.get_global @shared_mem : memref<1xf32>
    %10 = call @__builtin_inff() : () -> f32
    %11 = arith.negf %10 : f32
    %12 = arith.index_cast %arg2 : i32 to index
    %13 = affine.for %arg3 = %2 to %12 step 256 iter_args(%arg4 = %11) -> (f32) {
      %21 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %22 = arith.maxnumf %arg4, %21 : f32
      affine.yield %22 : f32
    }
    affine.store %13, %8[symbol(%2)] : memref<1xf32>
    nvvm.barrier0
    %14 = scf.while (%arg3 = %c128_i32) : (i32) -> i32 {
      %21 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%21) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %21 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %21 {
        %23 = affine.load %8[symbol(%2)] : memref<1xf32>
        %24 = arith.addi %3, %arg3 : i32
        %25 = arith.index_cast %24 : i32 to index
        %26 = memref.load %8[%25] : memref<1xf32>
        %27 = arith.maxnumf %23, %26 : f32
        affine.store %27, %8[symbol(%2)] : memref<1xf32>
      }
      nvvm.barrier0
      %22 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %22 : i32
    }
    %15 = affine.load %8[0] : memref<1xf32>
    nvvm.barrier0
    %16 = arith.index_cast %arg2 : i32 to index
    %17 = affine.for %arg3 = %2 to %16 step 256 iter_args(%arg4 = %cst) -> (f32) {
      %21 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %22 = arith.subf %21, %15 : f32
      %23 = math.exp %22 : f32
      affine.store %23, %arg1[%arg3 + symbol(%7)] : memref<?xf32>
      %24 = arith.addf %arg4, %23 : f32
      affine.yield %24 : f32
    }
    affine.store %17, %9[symbol(%2) + 256] : memref<1xf32>
    nvvm.barrier0
    %18 = scf.while (%arg3 = %c128_i32) : (i32) -> i32 {
      %21 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%21) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %21 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %21 {
        %23 = arith.addi %3, %arg3 : i32
        %24 = arith.index_cast %23 : i32 to index
        %25 = arith.addi %24, %c256 : index
        %26 = memref.load %9[%25] : memref<1xf32>
        %27 = affine.load %9[symbol(%2) + 256] : memref<1xf32>
        %28 = arith.addf %27, %26 : f32
        affine.store %28, %9[symbol(%2) + 256] : memref<1xf32>
      }
      nvvm.barrier0
      %22 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %22 : i32
    }
    %19 = affine.load %9[256] : memref<1xf32>
    nvvm.barrier0
    %20 = arith.index_cast %arg2 : i32 to index
    affine.for %arg3 = %2 to %20 step 256 {
      %21 = affine.load %arg1[%arg3 + symbol(%7)] : memref<?xf32>
      %22 = arith.divf %21, %19 : f32
      affine.store %22, %arg1[%arg3 + symbol(%7)] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c512 = arith.constant 512 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c256_i32 = arith.constant 256 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = arith.muli %1, %arg2 : i32
    %7 = arith.index_cast %6 : i32 to index
    %8 = memref.get_global @shared_mem : memref<1xf32>
    %9 = memref.get_global @shared_mem : memref<1xf32>
    %10 = call @__builtin_inff() : () -> f32
    %11 = arith.negf %10 : f32
    %12 = arith.index_cast %arg2 : i32 to index
    %13 = affine.for %arg3 = %2 to %12 step 512 iter_args(%arg4 = %11) -> (f32) {
      %21 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %22 = arith.maxnumf %arg4, %21 : f32
      affine.yield %22 : f32
    }
    affine.store %13, %8[symbol(%2)] : memref<1xf32>
    nvvm.barrier0
    %14 = scf.while (%arg3 = %c256_i32) : (i32) -> i32 {
      %21 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%21) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %21 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %21 {
        %23 = affine.load %8[symbol(%2)] : memref<1xf32>
        %24 = arith.addi %3, %arg3 : i32
        %25 = arith.index_cast %24 : i32 to index
        %26 = memref.load %8[%25] : memref<1xf32>
        %27 = arith.maxnumf %23, %26 : f32
        affine.store %27, %8[symbol(%2)] : memref<1xf32>
      }
      nvvm.barrier0
      %22 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %22 : i32
    }
    %15 = affine.load %8[0] : memref<1xf32>
    nvvm.barrier0
    %16 = arith.index_cast %arg2 : i32 to index
    %17 = affine.for %arg3 = %2 to %16 step 512 iter_args(%arg4 = %cst) -> (f32) {
      %21 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %22 = arith.subf %21, %15 : f32
      %23 = math.exp %22 : f32
      affine.store %23, %arg1[%arg3 + symbol(%7)] : memref<?xf32>
      %24 = arith.addf %arg4, %23 : f32
      affine.yield %24 : f32
    }
    affine.store %17, %9[symbol(%2) + 512] : memref<1xf32>
    nvvm.barrier0
    %18 = scf.while (%arg3 = %c256_i32) : (i32) -> i32 {
      %21 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%21) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %21 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %21 {
        %23 = arith.addi %3, %arg3 : i32
        %24 = arith.index_cast %23 : i32 to index
        %25 = arith.addi %24, %c512 : index
        %26 = memref.load %9[%25] : memref<1xf32>
        %27 = affine.load %9[symbol(%2) + 512] : memref<1xf32>
        %28 = arith.addf %27, %26 : f32
        affine.store %28, %9[symbol(%2) + 512] : memref<1xf32>
      }
      nvvm.barrier0
      %22 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %22 : i32
    }
    %19 = affine.load %9[512] : memref<1xf32>
    nvvm.barrier0
    %20 = arith.index_cast %arg2 : i32 to index
    affine.for %arg3 = %2 to %20 step 512 {
      %21 = affine.load %arg1[%arg3 + symbol(%7)] : memref<?xf32>
      %22 = arith.divf %21, %19 : f32
      affine.store %22, %arg1[%arg3 + symbol(%7)] : memref<?xf32>
    }
    return
  }
  func.func private @__builtin_inff() -> f32 attributes {llvm.linkage = #llvm.linkage<external>}
}
[ict-debug] driver.cc: After return 5, module: end

[ict-debug] driver.cc: After return 6, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @shared_mem : memref<1xf32>
  func.func @_Z20softmax_forward_cudaPKfPfiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
    %c512_i32 = arith.constant 512 : i32
    %c256_i32 = arith.constant 256 : i32
    %c128_i32 = arith.constant 128 : i32
    %c64_i32 = arith.constant 64 : i32
    %c32_i32 = arith.constant 32 : i32
    %c1_i32 = arith.constant 1 : i32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_3 = memref.cast %alloca_2 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_4 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_5 = memref.cast %alloca_4 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_6 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_7 = memref.cast %alloca_6 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_8 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_9 = memref.cast %alloca_8 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_10 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_11 = memref.cast %alloca_10 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_12 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_13 = memref.cast %alloca_12 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_14 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_15 = memref.cast %alloca_14 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_16 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_17 = memref.cast %alloca_16 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_18 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_19 = memref.cast %alloca_18 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_20 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_21 = memref.cast %alloca_20 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_22 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_23 = memref.cast %alloca_22 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_24 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_25 = memref.cast %alloca_24 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_26 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_27 = memref.cast %alloca_26 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_28 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_29 = memref.cast %alloca_28 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_30 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_31 = memref.cast %alloca_30 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_32 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_33 = memref.cast %alloca_32 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_34 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_35 = memref.cast %alloca_34 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    call @_ZN4dim3C1Ejjj(%cast_35, %arg2, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    cf.switch %arg4 : i32, [
      default: ^bb6,
      32: ^bb1,
      64: ^bb2,
      128: ^bb3,
      256: ^bb4,
      512: ^bb5
    ]
  ^bb1:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_33, %c32_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_31, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %0 = "polygeist.memref2pointer"(%alloca_30) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.getelementptr %0[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %2 = llvm.load %1 : !llvm.ptr -> i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %5 = llvm.load %4 : !llvm.ptr -> i32
    %6 = arith.index_cast %5 : i32 to index
    %7 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %8 = llvm.load %7 : !llvm.ptr -> i32
    %9 = arith.index_cast %8 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_29, %cast_33) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %10 = "polygeist.memref2pointer"(%alloca_28) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %11 = llvm.getelementptr %10[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %12 = llvm.load %11 : !llvm.ptr -> i32
    %13 = arith.index_cast %12 : i32 to index
    %14 = llvm.getelementptr %10[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %15 = llvm.load %14 : !llvm.ptr -> i32
    %16 = arith.index_cast %15 : i32 to index
    %17 = llvm.getelementptr %10[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %18 = llvm.load %17 : !llvm.ptr -> i32
    %19 = arith.index_cast %18 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %3, %arg12 = %6, %arg13 = %9) threads(%arg8, %arg9, %arg10) in (%arg14 = %13, %arg15 = %16, %arg16 = %19) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb2:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_27, %c64_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_25, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %20 = "polygeist.memref2pointer"(%alloca_24) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %21 = llvm.getelementptr %20[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %22 = llvm.load %21 : !llvm.ptr -> i32
    %23 = arith.index_cast %22 : i32 to index
    %24 = llvm.getelementptr %20[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %25 = llvm.load %24 : !llvm.ptr -> i32
    %26 = arith.index_cast %25 : i32 to index
    %27 = llvm.getelementptr %20[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %28 = llvm.load %27 : !llvm.ptr -> i32
    %29 = arith.index_cast %28 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_23, %cast_27) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %30 = "polygeist.memref2pointer"(%alloca_22) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %31 = llvm.getelementptr %30[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %32 = llvm.load %31 : !llvm.ptr -> i32
    %33 = arith.index_cast %32 : i32 to index
    %34 = llvm.getelementptr %30[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %35 = llvm.load %34 : !llvm.ptr -> i32
    %36 = arith.index_cast %35 : i32 to index
    %37 = llvm.getelementptr %30[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %38 = llvm.load %37 : !llvm.ptr -> i32
    %39 = arith.index_cast %38 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %23, %arg12 = %26, %arg13 = %29) threads(%arg8, %arg9, %arg10) in (%arg14 = %33, %arg15 = %36, %arg16 = %39) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb3:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_21, %c128_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_19, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %40 = "polygeist.memref2pointer"(%alloca_18) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %41 = llvm.getelementptr %40[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %42 = llvm.load %41 : !llvm.ptr -> i32
    %43 = arith.index_cast %42 : i32 to index
    %44 = llvm.getelementptr %40[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %45 = llvm.load %44 : !llvm.ptr -> i32
    %46 = arith.index_cast %45 : i32 to index
    %47 = llvm.getelementptr %40[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %48 = llvm.load %47 : !llvm.ptr -> i32
    %49 = arith.index_cast %48 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_17, %cast_21) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %50 = "polygeist.memref2pointer"(%alloca_16) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %51 = llvm.getelementptr %50[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %52 = llvm.load %51 : !llvm.ptr -> i32
    %53 = arith.index_cast %52 : i32 to index
    %54 = llvm.getelementptr %50[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %55 = llvm.load %54 : !llvm.ptr -> i32
    %56 = arith.index_cast %55 : i32 to index
    %57 = llvm.getelementptr %50[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %58 = llvm.load %57 : !llvm.ptr -> i32
    %59 = arith.index_cast %58 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %43, %arg12 = %46, %arg13 = %49) threads(%arg8, %arg9, %arg10) in (%arg14 = %53, %arg15 = %56, %arg16 = %59) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb4:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_15, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_13, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %60 = "polygeist.memref2pointer"(%alloca_12) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %61 = llvm.getelementptr %60[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %62 = llvm.load %61 : !llvm.ptr -> i32
    %63 = arith.index_cast %62 : i32 to index
    %64 = llvm.getelementptr %60[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %65 = llvm.load %64 : !llvm.ptr -> i32
    %66 = arith.index_cast %65 : i32 to index
    %67 = llvm.getelementptr %60[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %68 = llvm.load %67 : !llvm.ptr -> i32
    %69 = arith.index_cast %68 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_11, %cast_15) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %70 = "polygeist.memref2pointer"(%alloca_10) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %71 = llvm.getelementptr %70[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %72 = llvm.load %71 : !llvm.ptr -> i32
    %73 = arith.index_cast %72 : i32 to index
    %74 = llvm.getelementptr %70[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %75 = llvm.load %74 : !llvm.ptr -> i32
    %76 = arith.index_cast %75 : i32 to index
    %77 = llvm.getelementptr %70[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %78 = llvm.load %77 : !llvm.ptr -> i32
    %79 = arith.index_cast %78 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %63, %arg12 = %66, %arg13 = %69) threads(%arg8, %arg9, %arg10) in (%arg14 = %73, %arg15 = %76, %arg16 = %79) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb5:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_9, %c512_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_7, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %80 = "polygeist.memref2pointer"(%alloca_6) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %81 = llvm.getelementptr %80[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %82 = llvm.load %81 : !llvm.ptr -> i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = llvm.getelementptr %80[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %85 = llvm.load %84 : !llvm.ptr -> i32
    %86 = arith.index_cast %85 : i32 to index
    %87 = llvm.getelementptr %80[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %88 = llvm.load %87 : !llvm.ptr -> i32
    %89 = arith.index_cast %88 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_5, %cast_9) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %90 = "polygeist.memref2pointer"(%alloca_4) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %91 = llvm.getelementptr %90[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %92 = llvm.load %91 : !llvm.ptr -> i32
    %93 = arith.index_cast %92 : i32 to index
    %94 = llvm.getelementptr %90[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %95 = llvm.load %94 : !llvm.ptr -> i32
    %96 = arith.index_cast %95 : i32 to index
    %97 = llvm.getelementptr %90[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %98 = llvm.load %97 : !llvm.ptr -> i32
    %99 = arith.index_cast %98 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %83, %arg12 = %86, %arg13 = %89) threads(%arg8, %arg9, %arg10) in (%arg14 = %93, %arg15 = %96, %arg16 = %99) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb6:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_3, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_1, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %100 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %101 = llvm.getelementptr %100[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %102 = llvm.load %101 : !llvm.ptr -> i32
    %103 = arith.index_cast %102 : i32 to index
    %104 = llvm.getelementptr %100[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %105 = llvm.load %104 : !llvm.ptr -> i32
    %106 = arith.index_cast %105 : i32 to index
    %107 = llvm.getelementptr %100[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %108 = llvm.load %107 : !llvm.ptr -> i32
    %109 = arith.index_cast %108 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast, %cast_3) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %110 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %111 = llvm.getelementptr %110[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %112 = llvm.load %111 : !llvm.ptr -> i32
    %113 = arith.index_cast %112 : i32 to index
    %114 = llvm.getelementptr %110[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %115 = llvm.load %114 : !llvm.ptr -> i32
    %116 = arith.index_cast %115 : i32 to index
    %117 = llvm.getelementptr %110[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %118 = llvm.load %117 : !llvm.ptr -> i32
    %119 = arith.index_cast %118 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %103, %arg12 = %106, %arg13 = %109) threads(%arg8, %arg9, %arg10) in (%arg14 = %113, %arg15 = %116, %arg16 = %119) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb7:  // 6 preds: ^bb1, ^bb2, ^bb3, ^bb4, ^bb5, ^bb6
    return
  }
  func.func private @_ZN4dim3C1Ejjj(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: i32, %arg2: i32, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %arg1, %0 : i32, !llvm.ptr
    %1 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg2, %1 : i32, !llvm.ptr
    %2 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg3, %2 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_ZN4dim3C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> i32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %1, %2 : i32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %4 = llvm.load %3 : !llvm.ptr -> i32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %4, %5 : i32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %7 = llvm.load %6 : !llvm.ptr -> i32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %7, %8 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c32 = arith.constant 32 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c16_i32 = arith.constant 16 : i32
    %alloca = memref.alloca() : memref<1xf32, 5>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = call @__builtin_inff() : () -> f32
    %7 = arith.negf %6 : f32
    %8 = arith.index_cast %arg2 : i32 to index
    %9 = affine.for %arg3 = %2 to %8 step 32 iter_args(%arg4 = %7) -> (f32) {
      %15 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %16 = arith.maxnumf %arg4, %15 : f32
      affine.yield %16 : f32
    }
    affine.store %9, %alloca[symbol(%2)] : memref<1xf32, 5>
    nvvm.barrier0
    %10 = scf.while (%arg3 = %c16_i32) : (i32) -> i32 {
      %15 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%15) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %15 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %15 {
        %17 = affine.load %alloca[symbol(%2)] : memref<1xf32, 5>
        %18 = arith.addi %3, %arg3 : i32
        %19 = arith.index_cast %18 : i32 to index
        %20 = memref.load %alloca[%19] : memref<1xf32, 5>
        %21 = arith.maxnumf %17, %20 : f32
        affine.store %21, %alloca[symbol(%2)] : memref<1xf32, 5>
      }
      nvvm.barrier0
      %16 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %16 : i32
    }
    %11 = affine.load %alloca[0] : memref<1xf32, 5>
    nvvm.barrier0
    %12 = affine.for %arg3 = %2 to %8 step 32 iter_args(%arg4 = %cst) -> (f32) {
      %15 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %16 = arith.subf %15, %11 : f32
      %17 = math.exp %16 : f32
      affine.store %17, %arg1[%arg3 + symbol(%5)] : memref<?xf32>
      %18 = arith.addf %arg4, %17 : f32
      affine.yield %18 : f32
    }
    affine.store %12, %alloca[symbol(%2) + 32] : memref<1xf32, 5>
    nvvm.barrier0
    %13 = scf.while (%arg3 = %c16_i32) : (i32) -> i32 {
      %15 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%15) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %15 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %15 {
        %17 = arith.addi %3, %arg3 : i32
        %18 = arith.index_cast %17 : i32 to index
        %19 = arith.addi %18, %c32 : index
        %20 = memref.load %alloca[%19] : memref<1xf32, 5>
        %21 = affine.load %alloca[symbol(%2) + 32] : memref<1xf32, 5>
        %22 = arith.addf %21, %20 : f32
        affine.store %22, %alloca[symbol(%2) + 32] : memref<1xf32, 5>
      }
      nvvm.barrier0
      %16 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %16 : i32
    }
    %14 = affine.load %alloca[32] : memref<1xf32, 5>
    nvvm.barrier0
    affine.for %arg3 = %2 to %8 step 32 {
      %15 = affine.load %arg1[%arg3 + symbol(%5)] : memref<?xf32>
      %16 = arith.divf %15, %14 : f32
      affine.store %16, %arg1[%arg3 + symbol(%5)] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c64 = arith.constant 64 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c32_i32 = arith.constant 32 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = memref.get_global @shared_mem : memref<1xf32>
    %7 = call @__builtin_inff() : () -> f32
    %8 = arith.negf %7 : f32
    %9 = arith.index_cast %arg2 : i32 to index
    %10 = affine.for %arg3 = %2 to %9 step 64 iter_args(%arg4 = %8) -> (f32) {
      %16 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.maxnumf %arg4, %16 : f32
      affine.yield %17 : f32
    }
    affine.store %10, %6[symbol(%2)] : memref<1xf32>
    nvvm.barrier0
    %11 = scf.while (%arg3 = %c32_i32) : (i32) -> i32 {
      %16 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%16) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %16 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %16 {
        %18 = affine.load %6[symbol(%2)] : memref<1xf32>
        %19 = arith.addi %3, %arg3 : i32
        %20 = arith.index_cast %19 : i32 to index
        %21 = memref.load %6[%20] : memref<1xf32>
        %22 = arith.maxnumf %18, %21 : f32
        affine.store %22, %6[symbol(%2)] : memref<1xf32>
      }
      nvvm.barrier0
      %17 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %17 : i32
    }
    %12 = affine.load %6[0] : memref<1xf32>
    nvvm.barrier0
    %13 = affine.for %arg3 = %2 to %9 step 64 iter_args(%arg4 = %cst) -> (f32) {
      %16 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.subf %16, %12 : f32
      %18 = math.exp %17 : f32
      affine.store %18, %arg1[%arg3 + symbol(%5)] : memref<?xf32>
      %19 = arith.addf %arg4, %18 : f32
      affine.yield %19 : f32
    }
    affine.store %13, %6[symbol(%2) + 64] : memref<1xf32>
    nvvm.barrier0
    %14 = scf.while (%arg3 = %c32_i32) : (i32) -> i32 {
      %16 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%16) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %16 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %16 {
        %18 = arith.addi %3, %arg3 : i32
        %19 = arith.index_cast %18 : i32 to index
        %20 = arith.addi %19, %c64 : index
        %21 = memref.load %6[%20] : memref<1xf32>
        %22 = affine.load %6[symbol(%2) + 64] : memref<1xf32>
        %23 = arith.addf %22, %21 : f32
        affine.store %23, %6[symbol(%2) + 64] : memref<1xf32>
      }
      nvvm.barrier0
      %17 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %17 : i32
    }
    %15 = affine.load %6[64] : memref<1xf32>
    nvvm.barrier0
    affine.for %arg3 = %2 to %9 step 64 {
      %16 = affine.load %arg1[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.divf %16, %15 : f32
      affine.store %17, %arg1[%arg3 + symbol(%5)] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c64_i32 = arith.constant 64 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = memref.get_global @shared_mem : memref<1xf32>
    %7 = call @__builtin_inff() : () -> f32
    %8 = arith.negf %7 : f32
    %9 = arith.index_cast %arg2 : i32 to index
    %10 = affine.for %arg3 = %2 to %9 step 128 iter_args(%arg4 = %8) -> (f32) {
      %16 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.maxnumf %arg4, %16 : f32
      affine.yield %17 : f32
    }
    affine.store %10, %6[symbol(%2)] : memref<1xf32>
    nvvm.barrier0
    %11 = scf.while (%arg3 = %c64_i32) : (i32) -> i32 {
      %16 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%16) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %16 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %16 {
        %18 = affine.load %6[symbol(%2)] : memref<1xf32>
        %19 = arith.addi %3, %arg3 : i32
        %20 = arith.index_cast %19 : i32 to index
        %21 = memref.load %6[%20] : memref<1xf32>
        %22 = arith.maxnumf %18, %21 : f32
        affine.store %22, %6[symbol(%2)] : memref<1xf32>
      }
      nvvm.barrier0
      %17 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %17 : i32
    }
    %12 = affine.load %6[0] : memref<1xf32>
    nvvm.barrier0
    %13 = affine.for %arg3 = %2 to %9 step 128 iter_args(%arg4 = %cst) -> (f32) {
      %16 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.subf %16, %12 : f32
      %18 = math.exp %17 : f32
      affine.store %18, %arg1[%arg3 + symbol(%5)] : memref<?xf32>
      %19 = arith.addf %arg4, %18 : f32
      affine.yield %19 : f32
    }
    affine.store %13, %6[symbol(%2) + 128] : memref<1xf32>
    nvvm.barrier0
    %14 = scf.while (%arg3 = %c64_i32) : (i32) -> i32 {
      %16 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%16) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %16 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %16 {
        %18 = arith.addi %3, %arg3 : i32
        %19 = arith.index_cast %18 : i32 to index
        %20 = arith.addi %19, %c128 : index
        %21 = memref.load %6[%20] : memref<1xf32>
        %22 = affine.load %6[symbol(%2) + 128] : memref<1xf32>
        %23 = arith.addf %22, %21 : f32
        affine.store %23, %6[symbol(%2) + 128] : memref<1xf32>
      }
      nvvm.barrier0
      %17 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %17 : i32
    }
    %15 = affine.load %6[128] : memref<1xf32>
    nvvm.barrier0
    affine.for %arg3 = %2 to %9 step 128 {
      %16 = affine.load %arg1[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.divf %16, %15 : f32
      affine.store %17, %arg1[%arg3 + symbol(%5)] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c256 = arith.constant 256 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c128_i32 = arith.constant 128 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = memref.get_global @shared_mem : memref<1xf32>
    %7 = call @__builtin_inff() : () -> f32
    %8 = arith.negf %7 : f32
    %9 = arith.index_cast %arg2 : i32 to index
    %10 = affine.for %arg3 = %2 to %9 step 256 iter_args(%arg4 = %8) -> (f32) {
      %16 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.maxnumf %arg4, %16 : f32
      affine.yield %17 : f32
    }
    affine.store %10, %6[symbol(%2)] : memref<1xf32>
    nvvm.barrier0
    %11 = scf.while (%arg3 = %c128_i32) : (i32) -> i32 {
      %16 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%16) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %16 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %16 {
        %18 = affine.load %6[symbol(%2)] : memref<1xf32>
        %19 = arith.addi %3, %arg3 : i32
        %20 = arith.index_cast %19 : i32 to index
        %21 = memref.load %6[%20] : memref<1xf32>
        %22 = arith.maxnumf %18, %21 : f32
        affine.store %22, %6[symbol(%2)] : memref<1xf32>
      }
      nvvm.barrier0
      %17 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %17 : i32
    }
    %12 = affine.load %6[0] : memref<1xf32>
    nvvm.barrier0
    %13 = affine.for %arg3 = %2 to %9 step 256 iter_args(%arg4 = %cst) -> (f32) {
      %16 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.subf %16, %12 : f32
      %18 = math.exp %17 : f32
      affine.store %18, %arg1[%arg3 + symbol(%5)] : memref<?xf32>
      %19 = arith.addf %arg4, %18 : f32
      affine.yield %19 : f32
    }
    affine.store %13, %6[symbol(%2) + 256] : memref<1xf32>
    nvvm.barrier0
    %14 = scf.while (%arg3 = %c128_i32) : (i32) -> i32 {
      %16 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%16) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %16 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %16 {
        %18 = arith.addi %3, %arg3 : i32
        %19 = arith.index_cast %18 : i32 to index
        %20 = arith.addi %19, %c256 : index
        %21 = memref.load %6[%20] : memref<1xf32>
        %22 = affine.load %6[symbol(%2) + 256] : memref<1xf32>
        %23 = arith.addf %22, %21 : f32
        affine.store %23, %6[symbol(%2) + 256] : memref<1xf32>
      }
      nvvm.barrier0
      %17 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %17 : i32
    }
    %15 = affine.load %6[256] : memref<1xf32>
    nvvm.barrier0
    affine.for %arg3 = %2 to %9 step 256 {
      %16 = affine.load %arg1[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.divf %16, %15 : f32
      affine.store %17, %arg1[%arg3 + symbol(%5)] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c512 = arith.constant 512 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c256_i32 = arith.constant 256 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = memref.get_global @shared_mem : memref<1xf32>
    %7 = call @__builtin_inff() : () -> f32
    %8 = arith.negf %7 : f32
    %9 = arith.index_cast %arg2 : i32 to index
    %10 = affine.for %arg3 = %2 to %9 step 512 iter_args(%arg4 = %8) -> (f32) {
      %16 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.maxnumf %arg4, %16 : f32
      affine.yield %17 : f32
    }
    affine.store %10, %6[symbol(%2)] : memref<1xf32>
    nvvm.barrier0
    %11 = scf.while (%arg3 = %c256_i32) : (i32) -> i32 {
      %16 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%16) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %16 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %16 {
        %18 = affine.load %6[symbol(%2)] : memref<1xf32>
        %19 = arith.addi %3, %arg3 : i32
        %20 = arith.index_cast %19 : i32 to index
        %21 = memref.load %6[%20] : memref<1xf32>
        %22 = arith.maxnumf %18, %21 : f32
        affine.store %22, %6[symbol(%2)] : memref<1xf32>
      }
      nvvm.barrier0
      %17 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %17 : i32
    }
    %12 = affine.load %6[0] : memref<1xf32>
    nvvm.barrier0
    %13 = affine.for %arg3 = %2 to %9 step 512 iter_args(%arg4 = %cst) -> (f32) {
      %16 = affine.load %arg0[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.subf %16, %12 : f32
      %18 = math.exp %17 : f32
      affine.store %18, %arg1[%arg3 + symbol(%5)] : memref<?xf32>
      %19 = arith.addf %arg4, %18 : f32
      affine.yield %19 : f32
    }
    affine.store %13, %6[symbol(%2) + 512] : memref<1xf32>
    nvvm.barrier0
    %14 = scf.while (%arg3 = %c256_i32) : (i32) -> i32 {
      %16 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%16) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %16 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %16 {
        %18 = arith.addi %3, %arg3 : i32
        %19 = arith.index_cast %18 : i32 to index
        %20 = arith.addi %19, %c512 : index
        %21 = memref.load %6[%20] : memref<1xf32>
        %22 = affine.load %6[symbol(%2) + 512] : memref<1xf32>
        %23 = arith.addf %22, %21 : f32
        affine.store %23, %6[symbol(%2) + 512] : memref<1xf32>
      }
      nvvm.barrier0
      %17 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %17 : i32
    }
    %15 = affine.load %6[512] : memref<1xf32>
    nvvm.barrier0
    affine.for %arg3 = %2 to %9 step 512 {
      %16 = affine.load %arg1[%arg3 + symbol(%5)] : memref<?xf32>
      %17 = arith.divf %16, %15 : f32
      affine.store %17, %arg1[%arg3 + symbol(%5)] : memref<?xf32>
    }
    return
  }
  func.func private @__builtin_inff() -> f32 attributes {llvm.linkage = #llvm.linkage<external>}
}
[ict-debug] driver.cc: After return 6, module: end

WrapAndReplaceBarrierPass::runOnOperation(): before execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @shared_mem : memref<1xf32>
  func.func @_Z20softmax_forward_cudaPKfPfiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
    %c512_i32 = arith.constant 512 : i32
    %c256_i32 = arith.constant 256 : i32
    %c128_i32 = arith.constant 128 : i32
    %c64_i32 = arith.constant 64 : i32
    %c32_i32 = arith.constant 32 : i32
    %c1_i32 = arith.constant 1 : i32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_3 = memref.cast %alloca_2 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_4 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_5 = memref.cast %alloca_4 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_6 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_7 = memref.cast %alloca_6 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_8 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_9 = memref.cast %alloca_8 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_10 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_11 = memref.cast %alloca_10 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_12 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_13 = memref.cast %alloca_12 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_14 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_15 = memref.cast %alloca_14 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_16 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_17 = memref.cast %alloca_16 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_18 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_19 = memref.cast %alloca_18 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_20 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_21 = memref.cast %alloca_20 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_22 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_23 = memref.cast %alloca_22 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_24 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_25 = memref.cast %alloca_24 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_26 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_27 = memref.cast %alloca_26 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_28 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_29 = memref.cast %alloca_28 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_30 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_31 = memref.cast %alloca_30 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_32 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_33 = memref.cast %alloca_32 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_34 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_35 = memref.cast %alloca_34 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    call @_ZN4dim3C1Ejjj(%cast_35, %arg2, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    cf.switch %arg4 : i32, [
      default: ^bb6,
      32: ^bb1,
      64: ^bb2,
      128: ^bb3,
      256: ^bb4,
      512: ^bb5
    ]
  ^bb1:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_33, %c32_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_31, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %0 = "polygeist.memref2pointer"(%alloca_30) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.getelementptr %0[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %2 = llvm.load %1 : !llvm.ptr -> i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %5 = llvm.load %4 : !llvm.ptr -> i32
    %6 = arith.index_cast %5 : i32 to index
    %7 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %8 = llvm.load %7 : !llvm.ptr -> i32
    %9 = arith.index_cast %8 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_29, %cast_33) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %10 = "polygeist.memref2pointer"(%alloca_28) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %11 = llvm.getelementptr %10[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %12 = llvm.load %11 : !llvm.ptr -> i32
    %13 = arith.index_cast %12 : i32 to index
    %14 = llvm.getelementptr %10[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %15 = llvm.load %14 : !llvm.ptr -> i32
    %16 = arith.index_cast %15 : i32 to index
    %17 = llvm.getelementptr %10[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %18 = llvm.load %17 : !llvm.ptr -> i32
    %19 = arith.index_cast %18 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %3, %arg12 = %6, %arg13 = %9) threads(%arg8, %arg9, %arg10) in (%arg14 = %13, %arg15 = %16, %arg16 = %19) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb2:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_27, %c64_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_25, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %20 = "polygeist.memref2pointer"(%alloca_24) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %21 = llvm.getelementptr %20[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %22 = llvm.load %21 : !llvm.ptr -> i32
    %23 = arith.index_cast %22 : i32 to index
    %24 = llvm.getelementptr %20[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %25 = llvm.load %24 : !llvm.ptr -> i32
    %26 = arith.index_cast %25 : i32 to index
    %27 = llvm.getelementptr %20[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %28 = llvm.load %27 : !llvm.ptr -> i32
    %29 = arith.index_cast %28 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_23, %cast_27) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %30 = "polygeist.memref2pointer"(%alloca_22) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %31 = llvm.getelementptr %30[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %32 = llvm.load %31 : !llvm.ptr -> i32
    %33 = arith.index_cast %32 : i32 to index
    %34 = llvm.getelementptr %30[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %35 = llvm.load %34 : !llvm.ptr -> i32
    %36 = arith.index_cast %35 : i32 to index
    %37 = llvm.getelementptr %30[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %38 = llvm.load %37 : !llvm.ptr -> i32
    %39 = arith.index_cast %38 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %23, %arg12 = %26, %arg13 = %29) threads(%arg8, %arg9, %arg10) in (%arg14 = %33, %arg15 = %36, %arg16 = %39) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb3:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_21, %c128_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_19, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %40 = "polygeist.memref2pointer"(%alloca_18) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %41 = llvm.getelementptr %40[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %42 = llvm.load %41 : !llvm.ptr -> i32
    %43 = arith.index_cast %42 : i32 to index
    %44 = llvm.getelementptr %40[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %45 = llvm.load %44 : !llvm.ptr -> i32
    %46 = arith.index_cast %45 : i32 to index
    %47 = llvm.getelementptr %40[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %48 = llvm.load %47 : !llvm.ptr -> i32
    %49 = arith.index_cast %48 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_17, %cast_21) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %50 = "polygeist.memref2pointer"(%alloca_16) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %51 = llvm.getelementptr %50[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %52 = llvm.load %51 : !llvm.ptr -> i32
    %53 = arith.index_cast %52 : i32 to index
    %54 = llvm.getelementptr %50[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %55 = llvm.load %54 : !llvm.ptr -> i32
    %56 = arith.index_cast %55 : i32 to index
    %57 = llvm.getelementptr %50[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %58 = llvm.load %57 : !llvm.ptr -> i32
    %59 = arith.index_cast %58 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %43, %arg12 = %46, %arg13 = %49) threads(%arg8, %arg9, %arg10) in (%arg14 = %53, %arg15 = %56, %arg16 = %59) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb4:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_15, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_13, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %60 = "polygeist.memref2pointer"(%alloca_12) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %61 = llvm.getelementptr %60[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %62 = llvm.load %61 : !llvm.ptr -> i32
    %63 = arith.index_cast %62 : i32 to index
    %64 = llvm.getelementptr %60[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %65 = llvm.load %64 : !llvm.ptr -> i32
    %66 = arith.index_cast %65 : i32 to index
    %67 = llvm.getelementptr %60[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %68 = llvm.load %67 : !llvm.ptr -> i32
    %69 = arith.index_cast %68 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_11, %cast_15) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %70 = "polygeist.memref2pointer"(%alloca_10) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %71 = llvm.getelementptr %70[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %72 = llvm.load %71 : !llvm.ptr -> i32
    %73 = arith.index_cast %72 : i32 to index
    %74 = llvm.getelementptr %70[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %75 = llvm.load %74 : !llvm.ptr -> i32
    %76 = arith.index_cast %75 : i32 to index
    %77 = llvm.getelementptr %70[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %78 = llvm.load %77 : !llvm.ptr -> i32
    %79 = arith.index_cast %78 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %63, %arg12 = %66, %arg13 = %69) threads(%arg8, %arg9, %arg10) in (%arg14 = %73, %arg15 = %76, %arg16 = %79) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb5:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_9, %c512_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_7, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %80 = "polygeist.memref2pointer"(%alloca_6) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %81 = llvm.getelementptr %80[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %82 = llvm.load %81 : !llvm.ptr -> i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = llvm.getelementptr %80[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %85 = llvm.load %84 : !llvm.ptr -> i32
    %86 = arith.index_cast %85 : i32 to index
    %87 = llvm.getelementptr %80[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %88 = llvm.load %87 : !llvm.ptr -> i32
    %89 = arith.index_cast %88 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_5, %cast_9) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %90 = "polygeist.memref2pointer"(%alloca_4) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %91 = llvm.getelementptr %90[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %92 = llvm.load %91 : !llvm.ptr -> i32
    %93 = arith.index_cast %92 : i32 to index
    %94 = llvm.getelementptr %90[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %95 = llvm.load %94 : !llvm.ptr -> i32
    %96 = arith.index_cast %95 : i32 to index
    %97 = llvm.getelementptr %90[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %98 = llvm.load %97 : !llvm.ptr -> i32
    %99 = arith.index_cast %98 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %83, %arg12 = %86, %arg13 = %89) threads(%arg8, %arg9, %arg10) in (%arg14 = %93, %arg15 = %96, %arg16 = %99) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb6:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_3, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_1, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %100 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %101 = llvm.getelementptr %100[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %102 = llvm.load %101 : !llvm.ptr -> i32
    %103 = arith.index_cast %102 : i32 to index
    %104 = llvm.getelementptr %100[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %105 = llvm.load %104 : !llvm.ptr -> i32
    %106 = arith.index_cast %105 : i32 to index
    %107 = llvm.getelementptr %100[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %108 = llvm.load %107 : !llvm.ptr -> i32
    %109 = arith.index_cast %108 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast, %cast_3) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %110 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %111 = llvm.getelementptr %110[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %112 = llvm.load %111 : !llvm.ptr -> i32
    %113 = arith.index_cast %112 : i32 to index
    %114 = llvm.getelementptr %110[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %115 = llvm.load %114 : !llvm.ptr -> i32
    %116 = arith.index_cast %115 : i32 to index
    %117 = llvm.getelementptr %110[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %118 = llvm.load %117 : !llvm.ptr -> i32
    %119 = arith.index_cast %118 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %103, %arg12 = %106, %arg13 = %109) threads(%arg8, %arg9, %arg10) in (%arg14 = %113, %arg15 = %116, %arg16 = %119) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb7:  // 6 preds: ^bb1, ^bb2, ^bb3, ^bb4, ^bb5, ^bb6
    return
  }
  func.func private @_ZN4dim3C1Ejjj(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: i32, %arg2: i32, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %arg1, %0 : i32, !llvm.ptr
    %1 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg2, %1 : i32, !llvm.ptr
    %2 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg3, %2 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_ZN4dim3C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> i32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %1, %2 : i32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %4 = llvm.load %3 : !llvm.ptr -> i32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %4, %5 : i32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %7 = llvm.load %6 : !llvm.ptr -> i32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %7, %8 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c32 = arith.constant 32 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c16_i32 = arith.constant 16 : i32
    %alloca = memref.alloca() : memref<1xf32, 5>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = call @__builtin_inff() : () -> f32
    %7 = arith.negf %6 : f32
    %8 = arith.index_cast %arg2 : i32 to index
    %9 = scf.for %arg3 = %2 to %8 step %c32 iter_args(%arg4 = %7) -> (f32) {
      %16 = arith.addi %arg3, %5 : index
      %17 = memref.load %arg0[%16] : memref<?xf32>
      %18 = arith.maxnumf %arg4, %17 : f32
      scf.yield %18 : f32
    }
    memref.store %9, %alloca[%2] : memref<1xf32, 5>
    nvvm.barrier0
    %10 = scf.while (%arg3 = %c16_i32) : (i32) -> i32 {
      %16 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%16) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %16 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %16 {
        %18 = memref.load %alloca[%2] : memref<1xf32, 5>
        %19 = arith.addi %3, %arg3 : i32
        %20 = arith.index_cast %19 : i32 to index
        %21 = memref.load %alloca[%20] : memref<1xf32, 5>
        %22 = arith.maxnumf %18, %21 : f32
        memref.store %22, %alloca[%2] : memref<1xf32, 5>
      }
      nvvm.barrier0
      %17 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %17 : i32
    }
    %11 = memref.load %alloca[%c0] : memref<1xf32, 5>
    nvvm.barrier0
    %12 = scf.for %arg3 = %2 to %8 step %c32 iter_args(%arg4 = %cst) -> (f32) {
      %16 = arith.addi %arg3, %5 : index
      %17 = memref.load %arg0[%16] : memref<?xf32>
      %18 = arith.subf %17, %11 : f32
      %19 = math.exp %18 : f32
      memref.store %19, %arg1[%16] : memref<?xf32>
      %20 = arith.addf %arg4, %19 : f32
      scf.yield %20 : f32
    }
    %13 = arith.addi %2, %c32 : index
    memref.store %12, %alloca[%13] : memref<1xf32, 5>
    nvvm.barrier0
    %14 = scf.while (%arg3 = %c16_i32) : (i32) -> i32 {
      %16 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%16) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %16 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %16 {
        %18 = arith.addi %3, %arg3 : i32
        %19 = arith.index_cast %18 : i32 to index
        %20 = arith.addi %19, %c32 : index
        %21 = memref.load %alloca[%20] : memref<1xf32, 5>
        %22 = memref.load %alloca[%13] : memref<1xf32, 5>
        %23 = arith.addf %22, %21 : f32
        memref.store %23, %alloca[%13] : memref<1xf32, 5>
      }
      nvvm.barrier0
      %17 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %17 : i32
    }
    %15 = memref.load %alloca[%c32] : memref<1xf32, 5>
    nvvm.barrier0
    scf.for %arg3 = %2 to %8 step %c32 {
      %16 = arith.addi %arg3, %5 : index
      %17 = memref.load %arg1[%16] : memref<?xf32>
      %18 = arith.divf %17, %15 : f32
      memref.store %18, %arg1[%16] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c64 = arith.constant 64 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c32_i32 = arith.constant 32 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = memref.get_global @shared_mem : memref<1xf32>
    %7 = call @__builtin_inff() : () -> f32
    %8 = arith.negf %7 : f32
    %9 = arith.index_cast %arg2 : i32 to index
    %10 = scf.for %arg3 = %2 to %9 step %c64 iter_args(%arg4 = %8) -> (f32) {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg0[%17] : memref<?xf32>
      %19 = arith.maxnumf %arg4, %18 : f32
      scf.yield %19 : f32
    }
    memref.store %10, %6[%2] : memref<1xf32>
    nvvm.barrier0
    %11 = scf.while (%arg3 = %c32_i32) : (i32) -> i32 {
      %17 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%17) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %17 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %17 {
        %19 = memref.load %6[%2] : memref<1xf32>
        %20 = arith.addi %3, %arg3 : i32
        %21 = arith.index_cast %20 : i32 to index
        %22 = memref.load %6[%21] : memref<1xf32>
        %23 = arith.maxnumf %19, %22 : f32
        memref.store %23, %6[%2] : memref<1xf32>
      }
      nvvm.barrier0
      %18 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %18 : i32
    }
    %12 = memref.load %6[%c0] : memref<1xf32>
    nvvm.barrier0
    %13 = scf.for %arg3 = %2 to %9 step %c64 iter_args(%arg4 = %cst) -> (f32) {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg0[%17] : memref<?xf32>
      %19 = arith.subf %18, %12 : f32
      %20 = math.exp %19 : f32
      memref.store %20, %arg1[%17] : memref<?xf32>
      %21 = arith.addf %arg4, %20 : f32
      scf.yield %21 : f32
    }
    %14 = arith.addi %2, %c64 : index
    memref.store %13, %6[%14] : memref<1xf32>
    nvvm.barrier0
    %15 = scf.while (%arg3 = %c32_i32) : (i32) -> i32 {
      %17 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%17) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %17 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %17 {
        %19 = arith.addi %3, %arg3 : i32
        %20 = arith.index_cast %19 : i32 to index
        %21 = arith.addi %20, %c64 : index
        %22 = memref.load %6[%21] : memref<1xf32>
        %23 = memref.load %6[%14] : memref<1xf32>
        %24 = arith.addf %23, %22 : f32
        memref.store %24, %6[%14] : memref<1xf32>
      }
      nvvm.barrier0
      %18 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %18 : i32
    }
    %16 = memref.load %6[%c64] : memref<1xf32>
    nvvm.barrier0
    scf.for %arg3 = %2 to %9 step %c64 {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg1[%17] : memref<?xf32>
      %19 = arith.divf %18, %16 : f32
      memref.store %19, %arg1[%17] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c128 = arith.constant 128 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c64_i32 = arith.constant 64 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = memref.get_global @shared_mem : memref<1xf32>
    %7 = call @__builtin_inff() : () -> f32
    %8 = arith.negf %7 : f32
    %9 = arith.index_cast %arg2 : i32 to index
    %10 = scf.for %arg3 = %2 to %9 step %c128 iter_args(%arg4 = %8) -> (f32) {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg0[%17] : memref<?xf32>
      %19 = arith.maxnumf %arg4, %18 : f32
      scf.yield %19 : f32
    }
    memref.store %10, %6[%2] : memref<1xf32>
    nvvm.barrier0
    %11 = scf.while (%arg3 = %c64_i32) : (i32) -> i32 {
      %17 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%17) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %17 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %17 {
        %19 = memref.load %6[%2] : memref<1xf32>
        %20 = arith.addi %3, %arg3 : i32
        %21 = arith.index_cast %20 : i32 to index
        %22 = memref.load %6[%21] : memref<1xf32>
        %23 = arith.maxnumf %19, %22 : f32
        memref.store %23, %6[%2] : memref<1xf32>
      }
      nvvm.barrier0
      %18 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %18 : i32
    }
    %12 = memref.load %6[%c0] : memref<1xf32>
    nvvm.barrier0
    %13 = scf.for %arg3 = %2 to %9 step %c128 iter_args(%arg4 = %cst) -> (f32) {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg0[%17] : memref<?xf32>
      %19 = arith.subf %18, %12 : f32
      %20 = math.exp %19 : f32
      memref.store %20, %arg1[%17] : memref<?xf32>
      %21 = arith.addf %arg4, %20 : f32
      scf.yield %21 : f32
    }
    %14 = arith.addi %2, %c128 : index
    memref.store %13, %6[%14] : memref<1xf32>
    nvvm.barrier0
    %15 = scf.while (%arg3 = %c64_i32) : (i32) -> i32 {
      %17 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%17) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %17 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %17 {
        %19 = arith.addi %3, %arg3 : i32
        %20 = arith.index_cast %19 : i32 to index
        %21 = arith.addi %20, %c128 : index
        %22 = memref.load %6[%21] : memref<1xf32>
        %23 = memref.load %6[%14] : memref<1xf32>
        %24 = arith.addf %23, %22 : f32
        memref.store %24, %6[%14] : memref<1xf32>
      }
      nvvm.barrier0
      %18 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %18 : i32
    }
    %16 = memref.load %6[%c128] : memref<1xf32>
    nvvm.barrier0
    scf.for %arg3 = %2 to %9 step %c128 {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg1[%17] : memref<?xf32>
      %19 = arith.divf %18, %16 : f32
      memref.store %19, %arg1[%17] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c256 = arith.constant 256 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c128_i32 = arith.constant 128 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = memref.get_global @shared_mem : memref<1xf32>
    %7 = call @__builtin_inff() : () -> f32
    %8 = arith.negf %7 : f32
    %9 = arith.index_cast %arg2 : i32 to index
    %10 = scf.for %arg3 = %2 to %9 step %c256 iter_args(%arg4 = %8) -> (f32) {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg0[%17] : memref<?xf32>
      %19 = arith.maxnumf %arg4, %18 : f32
      scf.yield %19 : f32
    }
    memref.store %10, %6[%2] : memref<1xf32>
    nvvm.barrier0
    %11 = scf.while (%arg3 = %c128_i32) : (i32) -> i32 {
      %17 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%17) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %17 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %17 {
        %19 = memref.load %6[%2] : memref<1xf32>
        %20 = arith.addi %3, %arg3 : i32
        %21 = arith.index_cast %20 : i32 to index
        %22 = memref.load %6[%21] : memref<1xf32>
        %23 = arith.maxnumf %19, %22 : f32
        memref.store %23, %6[%2] : memref<1xf32>
      }
      nvvm.barrier0
      %18 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %18 : i32
    }
    %12 = memref.load %6[%c0] : memref<1xf32>
    nvvm.barrier0
    %13 = scf.for %arg3 = %2 to %9 step %c256 iter_args(%arg4 = %cst) -> (f32) {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg0[%17] : memref<?xf32>
      %19 = arith.subf %18, %12 : f32
      %20 = math.exp %19 : f32
      memref.store %20, %arg1[%17] : memref<?xf32>
      %21 = arith.addf %arg4, %20 : f32
      scf.yield %21 : f32
    }
    %14 = arith.addi %2, %c256 : index
    memref.store %13, %6[%14] : memref<1xf32>
    nvvm.barrier0
    %15 = scf.while (%arg3 = %c128_i32) : (i32) -> i32 {
      %17 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%17) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %17 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %17 {
        %19 = arith.addi %3, %arg3 : i32
        %20 = arith.index_cast %19 : i32 to index
        %21 = arith.addi %20, %c256 : index
        %22 = memref.load %6[%21] : memref<1xf32>
        %23 = memref.load %6[%14] : memref<1xf32>
        %24 = arith.addf %23, %22 : f32
        memref.store %24, %6[%14] : memref<1xf32>
      }
      nvvm.barrier0
      %18 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %18 : i32
    }
    %16 = memref.load %6[%c256] : memref<1xf32>
    nvvm.barrier0
    scf.for %arg3 = %2 to %9 step %c256 {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg1[%17] : memref<?xf32>
      %19 = arith.divf %18, %16 : f32
      memref.store %19, %arg1[%17] : memref<?xf32>
    }
    return
  }
  func.func private @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c512 = arith.constant 512 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c256_i32 = arith.constant 256 : i32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.thread_id  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %arg2 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6 = memref.get_global @shared_mem : memref<1xf32>
    %7 = call @__builtin_inff() : () -> f32
    %8 = arith.negf %7 : f32
    %9 = arith.index_cast %arg2 : i32 to index
    %10 = scf.for %arg3 = %2 to %9 step %c512 iter_args(%arg4 = %8) -> (f32) {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg0[%17] : memref<?xf32>
      %19 = arith.maxnumf %arg4, %18 : f32
      scf.yield %19 : f32
    }
    memref.store %10, %6[%2] : memref<1xf32>
    nvvm.barrier0
    %11 = scf.while (%arg3 = %c256_i32) : (i32) -> i32 {
      %17 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%17) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %17 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %17 {
        %19 = memref.load %6[%2] : memref<1xf32>
        %20 = arith.addi %3, %arg3 : i32
        %21 = arith.index_cast %20 : i32 to index
        %22 = memref.load %6[%21] : memref<1xf32>
        %23 = arith.maxnumf %19, %22 : f32
        memref.store %23, %6[%2] : memref<1xf32>
      }
      nvvm.barrier0
      %18 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %18 : i32
    }
    %12 = memref.load %6[%c0] : memref<1xf32>
    nvvm.barrier0
    %13 = scf.for %arg3 = %2 to %9 step %c512 iter_args(%arg4 = %cst) -> (f32) {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg0[%17] : memref<?xf32>
      %19 = arith.subf %18, %12 : f32
      %20 = math.exp %19 : f32
      memref.store %20, %arg1[%17] : memref<?xf32>
      %21 = arith.addf %arg4, %20 : f32
      scf.yield %21 : f32
    }
    %14 = arith.addi %2, %c512 : index
    memref.store %13, %6[%14] : memref<1xf32>
    nvvm.barrier0
    %15 = scf.while (%arg3 = %c256_i32) : (i32) -> i32 {
      %17 = arith.cmpi sgt, %arg3, %c0_i32 : i32
      scf.condition(%17) %arg3 : i32
    } do {
    ^bb0(%arg3: i32):
      %17 = arith.cmpi slt, %3, %arg3 : i32
      scf.if %17 {
        %19 = arith.addi %3, %arg3 : i32
        %20 = arith.index_cast %19 : i32 to index
        %21 = arith.addi %20, %c512 : index
        %22 = memref.load %6[%21] : memref<1xf32>
        %23 = memref.load %6[%14] : memref<1xf32>
        %24 = arith.addf %23, %22 : f32
        memref.store %24, %6[%14] : memref<1xf32>
      }
      nvvm.barrier0
      %18 = arith.shrsi %arg3, %c1_i32 : i32
      scf.yield %18 : i32
    }
    %16 = memref.load %6[%c512] : memref<1xf32>
    nvvm.barrier0
    scf.for %arg3 = %2 to %9 step %c512 {
      %17 = arith.addi %arg3, %5 : index
      %18 = memref.load %arg1[%17] : memref<?xf32>
      %19 = arith.divf %18, %16 : f32
      memref.store %19, %arg1[%17] : memref<?xf32>
    }
    return
  }
  func.func private @__builtin_inff() -> f32 attributes {llvm.linkage = #llvm.linkage<external>}
}
WrapAndReplaceBarrierPass::runOnOperation(): before execute: end
WrapAndReplaceBarrierPass::runOnOperation(): after execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @shared_mem : memref<1xf32>
  func.func @_Z20softmax_forward_cudaPKfPfiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
    %c512_i32 = arith.constant 512 : i32
    %c256_i32 = arith.constant 256 : i32
    %c128_i32 = arith.constant 128 : i32
    %c64_i32 = arith.constant 64 : i32
    %c32_i32 = arith.constant 32 : i32
    %c1_i32 = arith.constant 1 : i32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_3 = memref.cast %alloca_2 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_4 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_5 = memref.cast %alloca_4 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_6 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_7 = memref.cast %alloca_6 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_8 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_9 = memref.cast %alloca_8 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_10 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_11 = memref.cast %alloca_10 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_12 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_13 = memref.cast %alloca_12 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_14 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_15 = memref.cast %alloca_14 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_16 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_17 = memref.cast %alloca_16 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_18 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_19 = memref.cast %alloca_18 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_20 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_21 = memref.cast %alloca_20 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_22 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_23 = memref.cast %alloca_22 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_24 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_25 = memref.cast %alloca_24 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_26 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_27 = memref.cast %alloca_26 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_28 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_29 = memref.cast %alloca_28 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_30 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_31 = memref.cast %alloca_30 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_32 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_33 = memref.cast %alloca_32 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_34 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_35 = memref.cast %alloca_34 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    call @_ZN4dim3C1Ejjj(%cast_35, %arg2, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    cf.switch %arg4 : i32, [
      default: ^bb6,
      32: ^bb1,
      64: ^bb2,
      128: ^bb3,
      256: ^bb4,
      512: ^bb5
    ]
  ^bb1:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_33, %c32_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_31, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %0 = "polygeist.memref2pointer"(%alloca_30) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.getelementptr %0[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %2 = llvm.load %1 : !llvm.ptr -> i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %5 = llvm.load %4 : !llvm.ptr -> i32
    %6 = arith.index_cast %5 : i32 to index
    %7 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %8 = llvm.load %7 : !llvm.ptr -> i32
    %9 = arith.index_cast %8 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_29, %cast_33) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %10 = "polygeist.memref2pointer"(%alloca_28) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %11 = llvm.getelementptr %10[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %12 = llvm.load %11 : !llvm.ptr -> i32
    %13 = arith.index_cast %12 : i32 to index
    %14 = llvm.getelementptr %10[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %15 = llvm.load %14 : !llvm.ptr -> i32
    %16 = arith.index_cast %15 : i32 to index
    %17 = llvm.getelementptr %10[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %18 = llvm.load %17 : !llvm.ptr -> i32
    %19 = arith.index_cast %18 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %3, %arg12 = %6, %arg13 = %9) threads(%arg8, %arg9, %arg10) in (%arg14 = %13, %arg15 = %16, %arg16 = %19) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb2:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_27, %c64_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_25, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %20 = "polygeist.memref2pointer"(%alloca_24) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %21 = llvm.getelementptr %20[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %22 = llvm.load %21 : !llvm.ptr -> i32
    %23 = arith.index_cast %22 : i32 to index
    %24 = llvm.getelementptr %20[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %25 = llvm.load %24 : !llvm.ptr -> i32
    %26 = arith.index_cast %25 : i32 to index
    %27 = llvm.getelementptr %20[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %28 = llvm.load %27 : !llvm.ptr -> i32
    %29 = arith.index_cast %28 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_23, %cast_27) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %30 = "polygeist.memref2pointer"(%alloca_22) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %31 = llvm.getelementptr %30[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %32 = llvm.load %31 : !llvm.ptr -> i32
    %33 = arith.index_cast %32 : i32 to index
    %34 = llvm.getelementptr %30[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %35 = llvm.load %34 : !llvm.ptr -> i32
    %36 = arith.index_cast %35 : i32 to index
    %37 = llvm.getelementptr %30[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %38 = llvm.load %37 : !llvm.ptr -> i32
    %39 = arith.index_cast %38 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %23, %arg12 = %26, %arg13 = %29) threads(%arg8, %arg9, %arg10) in (%arg14 = %33, %arg15 = %36, %arg16 = %39) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb3:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_21, %c128_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_19, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %40 = "polygeist.memref2pointer"(%alloca_18) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %41 = llvm.getelementptr %40[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %42 = llvm.load %41 : !llvm.ptr -> i32
    %43 = arith.index_cast %42 : i32 to index
    %44 = llvm.getelementptr %40[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %45 = llvm.load %44 : !llvm.ptr -> i32
    %46 = arith.index_cast %45 : i32 to index
    %47 = llvm.getelementptr %40[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %48 = llvm.load %47 : !llvm.ptr -> i32
    %49 = arith.index_cast %48 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_17, %cast_21) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %50 = "polygeist.memref2pointer"(%alloca_16) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %51 = llvm.getelementptr %50[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %52 = llvm.load %51 : !llvm.ptr -> i32
    %53 = arith.index_cast %52 : i32 to index
    %54 = llvm.getelementptr %50[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %55 = llvm.load %54 : !llvm.ptr -> i32
    %56 = arith.index_cast %55 : i32 to index
    %57 = llvm.getelementptr %50[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %58 = llvm.load %57 : !llvm.ptr -> i32
    %59 = arith.index_cast %58 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %43, %arg12 = %46, %arg13 = %49) threads(%arg8, %arg9, %arg10) in (%arg14 = %53, %arg15 = %56, %arg16 = %59) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb4:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_15, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_13, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %60 = "polygeist.memref2pointer"(%alloca_12) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %61 = llvm.getelementptr %60[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %62 = llvm.load %61 : !llvm.ptr -> i32
    %63 = arith.index_cast %62 : i32 to index
    %64 = llvm.getelementptr %60[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %65 = llvm.load %64 : !llvm.ptr -> i32
    %66 = arith.index_cast %65 : i32 to index
    %67 = llvm.getelementptr %60[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %68 = llvm.load %67 : !llvm.ptr -> i32
    %69 = arith.index_cast %68 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_11, %cast_15) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %70 = "polygeist.memref2pointer"(%alloca_10) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %71 = llvm.getelementptr %70[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %72 = llvm.load %71 : !llvm.ptr -> i32
    %73 = arith.index_cast %72 : i32 to index
    %74 = llvm.getelementptr %70[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %75 = llvm.load %74 : !llvm.ptr -> i32
    %76 = arith.index_cast %75 : i32 to index
    %77 = llvm.getelementptr %70[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %78 = llvm.load %77 : !llvm.ptr -> i32
    %79 = arith.index_cast %78 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %63, %arg12 = %66, %arg13 = %69) threads(%arg8, %arg9, %arg10) in (%arg14 = %73, %arg15 = %76, %arg16 = %79) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb5:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_9, %c512_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_7, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %80 = "polygeist.memref2pointer"(%alloca_6) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %81 = llvm.getelementptr %80[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %82 = llvm.load %81 : !llvm.ptr -> i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = llvm.getelementptr %80[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %85 = llvm.load %84 : !llvm.ptr -> i32
    %86 = arith.index_cast %85 : i32 to index
    %87 = llvm.getelementptr %80[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %88 = llvm.load %87 : !llvm.ptr -> i32
    %89 = arith.index_cast %88 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_5, %cast_9) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %90 = "polygeist.memref2pointer"(%alloca_4) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %91 = llvm.getelementptr %90[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %92 = llvm.load %91 : !llvm.ptr -> i32
    %93 = arith.index_cast %92 : i32 to index
    %94 = llvm.getelementptr %90[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %95 = llvm.load %94 : !llvm.ptr -> i32
    %96 = arith.index_cast %95 : i32 to index
    %97 = llvm.getelementptr %90[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %98 = llvm.load %97 : !llvm.ptr -> i32
    %99 = arith.index_cast %98 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %83, %arg12 = %86, %arg13 = %89) threads(%arg8, %arg9, %arg10) in (%arg14 = %93, %arg15 = %96, %arg16 = %99) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb6:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_3, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_1, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %100 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %101 = llvm.getelementptr %100[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %102 = llvm.load %101 : !llvm.ptr -> i32
    %103 = arith.index_cast %102 : i32 to index
    %104 = llvm.getelementptr %100[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %105 = llvm.load %104 : !llvm.ptr -> i32
    %106 = arith.index_cast %105 : i32 to index
    %107 = llvm.getelementptr %100[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %108 = llvm.load %107 : !llvm.ptr -> i32
    %109 = arith.index_cast %108 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast, %cast_3) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %110 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %111 = llvm.getelementptr %110[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %112 = llvm.load %111 : !llvm.ptr -> i32
    %113 = arith.index_cast %112 : i32 to index
    %114 = llvm.getelementptr %110[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %115 = llvm.load %114 : !llvm.ptr -> i32
    %116 = arith.index_cast %115 : i32 to index
    %117 = llvm.getelementptr %110[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %118 = llvm.load %117 : !llvm.ptr -> i32
    %119 = arith.index_cast %118 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %103, %arg12 = %106, %arg13 = %109) threads(%arg8, %arg9, %arg10) in (%arg14 = %113, %arg15 = %116, %arg16 = %119) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb7:  // 6 preds: ^bb1, ^bb2, ^bb3, ^bb4, ^bb5, ^bb6
    return
  }
  func.func private @_ZN4dim3C1Ejjj(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: i32, %arg2: i32, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %arg1, %0 : i32, !llvm.ptr
    %1 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg2, %1 : i32, !llvm.ptr
    %2 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg3, %2 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_ZN4dim3C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> i32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %1, %2 : i32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %4 = llvm.load %3 : !llvm.ptr -> i32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %4, %5 : i32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %7 = llvm.load %6 : !llvm.ptr -> i32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %7, %8 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c32_1 = arith.constant 32 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c1_i32 = arith.constant 1 : i32
      %c0_i32 = arith.constant 0 : i32
      %c16_i32 = arith.constant 16 : i32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.index_cast %arg3 : index to i32
      %3 = arith.muli %1, %arg2 : i32
      %4 = arith.index_cast %3 : i32 to index
      %5 = func.call @__builtin_inff() : () -> f32
      %6 = arith.negf %5 : f32
      %7 = arith.index_cast %arg2 : i32 to index
      %8 = scf.for %arg4 = %arg3 to %7 step %c32_1 iter_args(%arg5 = %6) -> (f32) {
        %15 = arith.addi %arg4, %4 : index
        %16 = memref.load %arg0[%15] : memref<?xf32>
        %17 = arith.maxnumf %arg5, %16 : f32
        scf.yield %17 : f32
      }
      memref.store %8, %alloca[%arg3] : memref<1xf32, 5>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %9 = scf.while (%arg4 = %c16_i32) : (i32) -> i32 {
        %15 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%15) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %15 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %15 {
          %17 = memref.load %alloca[%arg3] : memref<1xf32, 5>
          %18 = arith.addi %2, %arg4 : i32
          %19 = arith.index_cast %18 : i32 to index
          %20 = memref.load %alloca[%19] : memref<1xf32, 5>
          %21 = arith.maxnumf %17, %20 : f32
          memref.store %21, %alloca[%arg3] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %16 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %16 : i32
      }
      %10 = memref.load %alloca[%c0_0] : memref<1xf32, 5>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %11 = scf.for %arg4 = %arg3 to %7 step %c32_1 iter_args(%arg5 = %cst) -> (f32) {
        %15 = arith.addi %arg4, %4 : index
        %16 = memref.load %arg0[%15] : memref<?xf32>
        %17 = arith.subf %16, %10 : f32
        %18 = math.exp %17 : f32
        memref.store %18, %arg1[%15] : memref<?xf32>
        %19 = arith.addf %arg5, %18 : f32
        scf.yield %19 : f32
      }
      %12 = arith.addi %arg3, %c32_1 : index
      memref.store %11, %alloca[%12] : memref<1xf32, 5>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %13 = scf.while (%arg4 = %c16_i32) : (i32) -> i32 {
        %15 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%15) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %15 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %15 {
          %17 = arith.addi %2, %arg4 : i32
          %18 = arith.index_cast %17 : i32 to index
          %19 = arith.addi %18, %c32_1 : index
          %20 = memref.load %alloca[%19] : memref<1xf32, 5>
          %21 = memref.load %alloca[%12] : memref<1xf32, 5>
          %22 = arith.addf %21, %20 : f32
          memref.store %22, %alloca[%12] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %16 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %16 : i32
      }
      %14 = memref.load %alloca[%c32_1] : memref<1xf32, 5>
      "polygeist.barrier"(%arg3) : (index) -> ()
      scf.for %arg4 = %arg3 to %7 step %c32_1 {
        %15 = arith.addi %arg4, %4 : index
        %16 = memref.load %arg1[%15] : memref<?xf32>
        %17 = arith.divf %16, %14 : f32
        memref.store %17, %arg1[%15] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c64 = arith.constant 64 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c1_i32 = arith.constant 1 : i32
      %c0_i32 = arith.constant 0 : i32
      %c32_i32 = arith.constant 32 : i32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.index_cast %arg3 : index to i32
      %3 = arith.muli %1, %arg2 : i32
      %4 = arith.index_cast %3 : i32 to index
      %5 = memref.get_global @shared_mem : memref<1xf32>
      %6 = func.call @__builtin_inff() : () -> f32
      %7 = arith.negf %6 : f32
      %8 = arith.index_cast %arg2 : i32 to index
      %9 = scf.for %arg4 = %arg3 to %8 step %c64 iter_args(%arg5 = %7) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.maxnumf %arg5, %17 : f32
        scf.yield %18 : f32
      }
      memref.store %9, %5[%arg3] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %10 = scf.while (%arg4 = %c32_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = memref.load %5[%arg3] : memref<1xf32>
          %19 = arith.addi %2, %arg4 : i32
          %20 = arith.index_cast %19 : i32 to index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = arith.maxnumf %18, %21 : f32
          memref.store %22, %5[%arg3] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %11 = memref.load %5[%c0_0] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %12 = scf.for %arg4 = %arg3 to %8 step %c64 iter_args(%arg5 = %cst) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.subf %17, %11 : f32
        %19 = math.exp %18 : f32
        memref.store %19, %arg1[%16] : memref<?xf32>
        %20 = arith.addf %arg5, %19 : f32
        scf.yield %20 : f32
      }
      %13 = arith.addi %arg3, %c64 : index
      memref.store %12, %5[%13] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %14 = scf.while (%arg4 = %c32_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = arith.addi %2, %arg4 : i32
          %19 = arith.index_cast %18 : i32 to index
          %20 = arith.addi %19, %c64 : index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = memref.load %5[%13] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %5[%13] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %15 = memref.load %5[%c64] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      scf.for %arg4 = %arg3 to %8 step %c64 {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg1[%16] : memref<?xf32>
        %18 = arith.divf %17, %15 : f32
        memref.store %18, %arg1[%16] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c128 = arith.constant 128 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c1_i32 = arith.constant 1 : i32
      %c0_i32 = arith.constant 0 : i32
      %c64_i32 = arith.constant 64 : i32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.index_cast %arg3 : index to i32
      %3 = arith.muli %1, %arg2 : i32
      %4 = arith.index_cast %3 : i32 to index
      %5 = memref.get_global @shared_mem : memref<1xf32>
      %6 = func.call @__builtin_inff() : () -> f32
      %7 = arith.negf %6 : f32
      %8 = arith.index_cast %arg2 : i32 to index
      %9 = scf.for %arg4 = %arg3 to %8 step %c128 iter_args(%arg5 = %7) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.maxnumf %arg5, %17 : f32
        scf.yield %18 : f32
      }
      memref.store %9, %5[%arg3] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %10 = scf.while (%arg4 = %c64_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = memref.load %5[%arg3] : memref<1xf32>
          %19 = arith.addi %2, %arg4 : i32
          %20 = arith.index_cast %19 : i32 to index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = arith.maxnumf %18, %21 : f32
          memref.store %22, %5[%arg3] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %11 = memref.load %5[%c0_0] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %12 = scf.for %arg4 = %arg3 to %8 step %c128 iter_args(%arg5 = %cst) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.subf %17, %11 : f32
        %19 = math.exp %18 : f32
        memref.store %19, %arg1[%16] : memref<?xf32>
        %20 = arith.addf %arg5, %19 : f32
        scf.yield %20 : f32
      }
      %13 = arith.addi %arg3, %c128 : index
      memref.store %12, %5[%13] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %14 = scf.while (%arg4 = %c64_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = arith.addi %2, %arg4 : i32
          %19 = arith.index_cast %18 : i32 to index
          %20 = arith.addi %19, %c128 : index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = memref.load %5[%13] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %5[%13] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %15 = memref.load %5[%c128] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      scf.for %arg4 = %arg3 to %8 step %c128 {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg1[%16] : memref<?xf32>
        %18 = arith.divf %17, %15 : f32
        memref.store %18, %arg1[%16] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c256 = arith.constant 256 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c1_i32 = arith.constant 1 : i32
      %c0_i32 = arith.constant 0 : i32
      %c128_i32 = arith.constant 128 : i32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.index_cast %arg3 : index to i32
      %3 = arith.muli %1, %arg2 : i32
      %4 = arith.index_cast %3 : i32 to index
      %5 = memref.get_global @shared_mem : memref<1xf32>
      %6 = func.call @__builtin_inff() : () -> f32
      %7 = arith.negf %6 : f32
      %8 = arith.index_cast %arg2 : i32 to index
      %9 = scf.for %arg4 = %arg3 to %8 step %c256 iter_args(%arg5 = %7) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.maxnumf %arg5, %17 : f32
        scf.yield %18 : f32
      }
      memref.store %9, %5[%arg3] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %10 = scf.while (%arg4 = %c128_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = memref.load %5[%arg3] : memref<1xf32>
          %19 = arith.addi %2, %arg4 : i32
          %20 = arith.index_cast %19 : i32 to index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = arith.maxnumf %18, %21 : f32
          memref.store %22, %5[%arg3] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %11 = memref.load %5[%c0_0] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %12 = scf.for %arg4 = %arg3 to %8 step %c256 iter_args(%arg5 = %cst) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.subf %17, %11 : f32
        %19 = math.exp %18 : f32
        memref.store %19, %arg1[%16] : memref<?xf32>
        %20 = arith.addf %arg5, %19 : f32
        scf.yield %20 : f32
      }
      %13 = arith.addi %arg3, %c256 : index
      memref.store %12, %5[%13] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %14 = scf.while (%arg4 = %c128_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = arith.addi %2, %arg4 : i32
          %19 = arith.index_cast %18 : i32 to index
          %20 = arith.addi %19, %c256 : index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = memref.load %5[%13] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %5[%13] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %15 = memref.load %5[%c256] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      scf.for %arg4 = %arg3 to %8 step %c256 {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg1[%16] : memref<?xf32>
        %18 = arith.divf %17, %15 : f32
        memref.store %18, %arg1[%16] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c512 = arith.constant 512 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c1_i32 = arith.constant 1 : i32
      %c0_i32 = arith.constant 0 : i32
      %c256_i32 = arith.constant 256 : i32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.index_cast %arg3 : index to i32
      %3 = arith.muli %1, %arg2 : i32
      %4 = arith.index_cast %3 : i32 to index
      %5 = memref.get_global @shared_mem : memref<1xf32>
      %6 = func.call @__builtin_inff() : () -> f32
      %7 = arith.negf %6 : f32
      %8 = arith.index_cast %arg2 : i32 to index
      %9 = scf.for %arg4 = %arg3 to %8 step %c512 iter_args(%arg5 = %7) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.maxnumf %arg5, %17 : f32
        scf.yield %18 : f32
      }
      memref.store %9, %5[%arg3] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %10 = scf.while (%arg4 = %c256_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = memref.load %5[%arg3] : memref<1xf32>
          %19 = arith.addi %2, %arg4 : i32
          %20 = arith.index_cast %19 : i32 to index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = arith.maxnumf %18, %21 : f32
          memref.store %22, %5[%arg3] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %11 = memref.load %5[%c0_0] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %12 = scf.for %arg4 = %arg3 to %8 step %c512 iter_args(%arg5 = %cst) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.subf %17, %11 : f32
        %19 = math.exp %18 : f32
        memref.store %19, %arg1[%16] : memref<?xf32>
        %20 = arith.addf %arg5, %19 : f32
        scf.yield %20 : f32
      }
      %13 = arith.addi %arg3, %c512 : index
      memref.store %12, %5[%13] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %14 = scf.while (%arg4 = %c256_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = arith.addi %2, %arg4 : i32
          %19 = arith.index_cast %18 : i32 to index
          %20 = arith.addi %19, %c512 : index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = memref.load %5[%13] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %5[%13] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %15 = memref.load %5[%c512] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      scf.for %arg4 = %arg3 to %8 step %c512 {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg1[%16] : memref<?xf32>
        %18 = arith.divf %17, %15 : f32
        memref.store %18, %arg1[%16] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func private @__builtin_inff() -> f32 attributes {llvm.linkage = #llvm.linkage<external>}
}
WrapAndReplaceBarrierPass::runOnOperation(): after execute: end
[ict-debug] driver.cc: After return 7, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @shared_mem : memref<1xf32>
  func.func @_Z20softmax_forward_cudaPKfPfiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
    %c512_i32 = arith.constant 512 : i32
    %c256_i32 = arith.constant 256 : i32
    %c128_i32 = arith.constant 128 : i32
    %c64_i32 = arith.constant 64 : i32
    %c32_i32 = arith.constant 32 : i32
    %c1_i32 = arith.constant 1 : i32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_3 = memref.cast %alloca_2 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_4 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_5 = memref.cast %alloca_4 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_6 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_7 = memref.cast %alloca_6 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_8 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_9 = memref.cast %alloca_8 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_10 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_11 = memref.cast %alloca_10 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_12 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_13 = memref.cast %alloca_12 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_14 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_15 = memref.cast %alloca_14 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_16 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_17 = memref.cast %alloca_16 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_18 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_19 = memref.cast %alloca_18 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_20 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_21 = memref.cast %alloca_20 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_22 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_23 = memref.cast %alloca_22 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_24 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_25 = memref.cast %alloca_24 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_26 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_27 = memref.cast %alloca_26 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_28 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_29 = memref.cast %alloca_28 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_30 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_31 = memref.cast %alloca_30 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_32 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_33 = memref.cast %alloca_32 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_34 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_35 = memref.cast %alloca_34 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    call @_ZN4dim3C1Ejjj(%cast_35, %arg2, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    cf.switch %arg4 : i32, [
      default: ^bb6,
      32: ^bb1,
      64: ^bb2,
      128: ^bb3,
      256: ^bb4,
      512: ^bb5
    ]
  ^bb1:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_33, %c32_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_31, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %0 = "polygeist.memref2pointer"(%alloca_30) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.getelementptr %0[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %2 = llvm.load %1 : !llvm.ptr -> i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %5 = llvm.load %4 : !llvm.ptr -> i32
    %6 = arith.index_cast %5 : i32 to index
    %7 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %8 = llvm.load %7 : !llvm.ptr -> i32
    %9 = arith.index_cast %8 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_29, %cast_33) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %10 = "polygeist.memref2pointer"(%alloca_28) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %11 = llvm.getelementptr %10[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %12 = llvm.load %11 : !llvm.ptr -> i32
    %13 = arith.index_cast %12 : i32 to index
    %14 = llvm.getelementptr %10[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %15 = llvm.load %14 : !llvm.ptr -> i32
    %16 = arith.index_cast %15 : i32 to index
    %17 = llvm.getelementptr %10[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %18 = llvm.load %17 : !llvm.ptr -> i32
    %19 = arith.index_cast %18 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %3, %arg12 = %6, %arg13 = %9) threads(%arg8, %arg9, %arg10) in (%arg14 = %13, %arg15 = %16, %arg16 = %19) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb2:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_27, %c64_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_25, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %20 = "polygeist.memref2pointer"(%alloca_24) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %21 = llvm.getelementptr %20[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %22 = llvm.load %21 : !llvm.ptr -> i32
    %23 = arith.index_cast %22 : i32 to index
    %24 = llvm.getelementptr %20[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %25 = llvm.load %24 : !llvm.ptr -> i32
    %26 = arith.index_cast %25 : i32 to index
    %27 = llvm.getelementptr %20[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %28 = llvm.load %27 : !llvm.ptr -> i32
    %29 = arith.index_cast %28 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_23, %cast_27) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %30 = "polygeist.memref2pointer"(%alloca_22) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %31 = llvm.getelementptr %30[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %32 = llvm.load %31 : !llvm.ptr -> i32
    %33 = arith.index_cast %32 : i32 to index
    %34 = llvm.getelementptr %30[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %35 = llvm.load %34 : !llvm.ptr -> i32
    %36 = arith.index_cast %35 : i32 to index
    %37 = llvm.getelementptr %30[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %38 = llvm.load %37 : !llvm.ptr -> i32
    %39 = arith.index_cast %38 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %23, %arg12 = %26, %arg13 = %29) threads(%arg8, %arg9, %arg10) in (%arg14 = %33, %arg15 = %36, %arg16 = %39) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb3:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_21, %c128_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_19, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %40 = "polygeist.memref2pointer"(%alloca_18) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %41 = llvm.getelementptr %40[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %42 = llvm.load %41 : !llvm.ptr -> i32
    %43 = arith.index_cast %42 : i32 to index
    %44 = llvm.getelementptr %40[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %45 = llvm.load %44 : !llvm.ptr -> i32
    %46 = arith.index_cast %45 : i32 to index
    %47 = llvm.getelementptr %40[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %48 = llvm.load %47 : !llvm.ptr -> i32
    %49 = arith.index_cast %48 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_17, %cast_21) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %50 = "polygeist.memref2pointer"(%alloca_16) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %51 = llvm.getelementptr %50[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %52 = llvm.load %51 : !llvm.ptr -> i32
    %53 = arith.index_cast %52 : i32 to index
    %54 = llvm.getelementptr %50[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %55 = llvm.load %54 : !llvm.ptr -> i32
    %56 = arith.index_cast %55 : i32 to index
    %57 = llvm.getelementptr %50[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %58 = llvm.load %57 : !llvm.ptr -> i32
    %59 = arith.index_cast %58 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %43, %arg12 = %46, %arg13 = %49) threads(%arg8, %arg9, %arg10) in (%arg14 = %53, %arg15 = %56, %arg16 = %59) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb4:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_15, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_13, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %60 = "polygeist.memref2pointer"(%alloca_12) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %61 = llvm.getelementptr %60[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %62 = llvm.load %61 : !llvm.ptr -> i32
    %63 = arith.index_cast %62 : i32 to index
    %64 = llvm.getelementptr %60[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %65 = llvm.load %64 : !llvm.ptr -> i32
    %66 = arith.index_cast %65 : i32 to index
    %67 = llvm.getelementptr %60[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %68 = llvm.load %67 : !llvm.ptr -> i32
    %69 = arith.index_cast %68 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_11, %cast_15) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %70 = "polygeist.memref2pointer"(%alloca_10) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %71 = llvm.getelementptr %70[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %72 = llvm.load %71 : !llvm.ptr -> i32
    %73 = arith.index_cast %72 : i32 to index
    %74 = llvm.getelementptr %70[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %75 = llvm.load %74 : !llvm.ptr -> i32
    %76 = arith.index_cast %75 : i32 to index
    %77 = llvm.getelementptr %70[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %78 = llvm.load %77 : !llvm.ptr -> i32
    %79 = arith.index_cast %78 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %63, %arg12 = %66, %arg13 = %69) threads(%arg8, %arg9, %arg10) in (%arg14 = %73, %arg15 = %76, %arg16 = %79) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb5:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_9, %c512_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_7, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %80 = "polygeist.memref2pointer"(%alloca_6) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %81 = llvm.getelementptr %80[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %82 = llvm.load %81 : !llvm.ptr -> i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = llvm.getelementptr %80[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %85 = llvm.load %84 : !llvm.ptr -> i32
    %86 = arith.index_cast %85 : i32 to index
    %87 = llvm.getelementptr %80[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %88 = llvm.load %87 : !llvm.ptr -> i32
    %89 = arith.index_cast %88 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_5, %cast_9) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %90 = "polygeist.memref2pointer"(%alloca_4) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %91 = llvm.getelementptr %90[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %92 = llvm.load %91 : !llvm.ptr -> i32
    %93 = arith.index_cast %92 : i32 to index
    %94 = llvm.getelementptr %90[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %95 = llvm.load %94 : !llvm.ptr -> i32
    %96 = arith.index_cast %95 : i32 to index
    %97 = llvm.getelementptr %90[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %98 = llvm.load %97 : !llvm.ptr -> i32
    %99 = arith.index_cast %98 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %83, %arg12 = %86, %arg13 = %89) threads(%arg8, %arg9, %arg10) in (%arg14 = %93, %arg15 = %96, %arg16 = %99) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb6:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_3, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_1, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %100 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %101 = llvm.getelementptr %100[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %102 = llvm.load %101 : !llvm.ptr -> i32
    %103 = arith.index_cast %102 : i32 to index
    %104 = llvm.getelementptr %100[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %105 = llvm.load %104 : !llvm.ptr -> i32
    %106 = arith.index_cast %105 : i32 to index
    %107 = llvm.getelementptr %100[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %108 = llvm.load %107 : !llvm.ptr -> i32
    %109 = arith.index_cast %108 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast, %cast_3) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %110 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %111 = llvm.getelementptr %110[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %112 = llvm.load %111 : !llvm.ptr -> i32
    %113 = arith.index_cast %112 : i32 to index
    %114 = llvm.getelementptr %110[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %115 = llvm.load %114 : !llvm.ptr -> i32
    %116 = arith.index_cast %115 : i32 to index
    %117 = llvm.getelementptr %110[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %118 = llvm.load %117 : !llvm.ptr -> i32
    %119 = arith.index_cast %118 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %103, %arg12 = %106, %arg13 = %109) threads(%arg8, %arg9, %arg10) in (%arg14 = %113, %arg15 = %116, %arg16 = %119) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb7:  // 6 preds: ^bb1, ^bb2, ^bb3, ^bb4, ^bb5, ^bb6
    return
  }
  func.func private @_ZN4dim3C1Ejjj(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: i32, %arg2: i32, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %arg1, %0 : i32, !llvm.ptr
    %1 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg2, %1 : i32, !llvm.ptr
    %2 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg3, %2 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_ZN4dim3C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> i32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %1, %2 : i32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %4 = llvm.load %3 : !llvm.ptr -> i32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %4, %5 : i32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %7 = llvm.load %6 : !llvm.ptr -> i32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %7, %8 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c32_1 = arith.constant 32 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c1_i32 = arith.constant 1 : i32
      %c0_i32 = arith.constant 0 : i32
      %c16_i32 = arith.constant 16 : i32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.index_cast %arg3 : index to i32
      %3 = arith.muli %1, %arg2 : i32
      %4 = arith.index_cast %3 : i32 to index
      %5 = func.call @__builtin_inff() : () -> f32
      %6 = arith.negf %5 : f32
      %7 = arith.index_cast %arg2 : i32 to index
      %8 = scf.for %arg4 = %arg3 to %7 step %c32_1 iter_args(%arg5 = %6) -> (f32) {
        %15 = arith.addi %arg4, %4 : index
        %16 = memref.load %arg0[%15] : memref<?xf32>
        %17 = arith.maxnumf %arg5, %16 : f32
        scf.yield %17 : f32
      }
      memref.store %8, %alloca[%arg3] : memref<1xf32, 5>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %9 = scf.while (%arg4 = %c16_i32) : (i32) -> i32 {
        %15 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%15) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %15 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %15 {
          %17 = memref.load %alloca[%arg3] : memref<1xf32, 5>
          %18 = arith.addi %2, %arg4 : i32
          %19 = arith.index_cast %18 : i32 to index
          %20 = memref.load %alloca[%19] : memref<1xf32, 5>
          %21 = arith.maxnumf %17, %20 : f32
          memref.store %21, %alloca[%arg3] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %16 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %16 : i32
      }
      %10 = memref.load %alloca[%c0_0] : memref<1xf32, 5>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %11 = scf.for %arg4 = %arg3 to %7 step %c32_1 iter_args(%arg5 = %cst) -> (f32) {
        %15 = arith.addi %arg4, %4 : index
        %16 = memref.load %arg0[%15] : memref<?xf32>
        %17 = arith.subf %16, %10 : f32
        %18 = math.exp %17 : f32
        memref.store %18, %arg1[%15] : memref<?xf32>
        %19 = arith.addf %arg5, %18 : f32
        scf.yield %19 : f32
      }
      %12 = arith.addi %arg3, %c32_1 : index
      memref.store %11, %alloca[%12] : memref<1xf32, 5>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %13 = scf.while (%arg4 = %c16_i32) : (i32) -> i32 {
        %15 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%15) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %15 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %15 {
          %17 = arith.addi %2, %arg4 : i32
          %18 = arith.index_cast %17 : i32 to index
          %19 = arith.addi %18, %c32_1 : index
          %20 = memref.load %alloca[%19] : memref<1xf32, 5>
          %21 = memref.load %alloca[%12] : memref<1xf32, 5>
          %22 = arith.addf %21, %20 : f32
          memref.store %22, %alloca[%12] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %16 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %16 : i32
      }
      %14 = memref.load %alloca[%c32_1] : memref<1xf32, 5>
      "polygeist.barrier"(%arg3) : (index) -> ()
      scf.for %arg4 = %arg3 to %7 step %c32_1 {
        %15 = arith.addi %arg4, %4 : index
        %16 = memref.load %arg1[%15] : memref<?xf32>
        %17 = arith.divf %16, %14 : f32
        memref.store %17, %arg1[%15] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c64 = arith.constant 64 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c1_i32 = arith.constant 1 : i32
      %c0_i32 = arith.constant 0 : i32
      %c32_i32 = arith.constant 32 : i32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.index_cast %arg3 : index to i32
      %3 = arith.muli %1, %arg2 : i32
      %4 = arith.index_cast %3 : i32 to index
      %5 = memref.get_global @shared_mem : memref<1xf32>
      %6 = func.call @__builtin_inff() : () -> f32
      %7 = arith.negf %6 : f32
      %8 = arith.index_cast %arg2 : i32 to index
      %9 = scf.for %arg4 = %arg3 to %8 step %c64 iter_args(%arg5 = %7) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.maxnumf %arg5, %17 : f32
        scf.yield %18 : f32
      }
      memref.store %9, %5[%arg3] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %10 = scf.while (%arg4 = %c32_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = memref.load %5[%arg3] : memref<1xf32>
          %19 = arith.addi %2, %arg4 : i32
          %20 = arith.index_cast %19 : i32 to index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = arith.maxnumf %18, %21 : f32
          memref.store %22, %5[%arg3] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %11 = memref.load %5[%c0_0] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %12 = scf.for %arg4 = %arg3 to %8 step %c64 iter_args(%arg5 = %cst) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.subf %17, %11 : f32
        %19 = math.exp %18 : f32
        memref.store %19, %arg1[%16] : memref<?xf32>
        %20 = arith.addf %arg5, %19 : f32
        scf.yield %20 : f32
      }
      %13 = arith.addi %arg3, %c64 : index
      memref.store %12, %5[%13] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %14 = scf.while (%arg4 = %c32_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = arith.addi %2, %arg4 : i32
          %19 = arith.index_cast %18 : i32 to index
          %20 = arith.addi %19, %c64 : index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = memref.load %5[%13] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %5[%13] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %15 = memref.load %5[%c64] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      scf.for %arg4 = %arg3 to %8 step %c64 {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg1[%16] : memref<?xf32>
        %18 = arith.divf %17, %15 : f32
        memref.store %18, %arg1[%16] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c128 = arith.constant 128 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c1_i32 = arith.constant 1 : i32
      %c0_i32 = arith.constant 0 : i32
      %c64_i32 = arith.constant 64 : i32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.index_cast %arg3 : index to i32
      %3 = arith.muli %1, %arg2 : i32
      %4 = arith.index_cast %3 : i32 to index
      %5 = memref.get_global @shared_mem : memref<1xf32>
      %6 = func.call @__builtin_inff() : () -> f32
      %7 = arith.negf %6 : f32
      %8 = arith.index_cast %arg2 : i32 to index
      %9 = scf.for %arg4 = %arg3 to %8 step %c128 iter_args(%arg5 = %7) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.maxnumf %arg5, %17 : f32
        scf.yield %18 : f32
      }
      memref.store %9, %5[%arg3] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %10 = scf.while (%arg4 = %c64_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = memref.load %5[%arg3] : memref<1xf32>
          %19 = arith.addi %2, %arg4 : i32
          %20 = arith.index_cast %19 : i32 to index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = arith.maxnumf %18, %21 : f32
          memref.store %22, %5[%arg3] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %11 = memref.load %5[%c0_0] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %12 = scf.for %arg4 = %arg3 to %8 step %c128 iter_args(%arg5 = %cst) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.subf %17, %11 : f32
        %19 = math.exp %18 : f32
        memref.store %19, %arg1[%16] : memref<?xf32>
        %20 = arith.addf %arg5, %19 : f32
        scf.yield %20 : f32
      }
      %13 = arith.addi %arg3, %c128 : index
      memref.store %12, %5[%13] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %14 = scf.while (%arg4 = %c64_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = arith.addi %2, %arg4 : i32
          %19 = arith.index_cast %18 : i32 to index
          %20 = arith.addi %19, %c128 : index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = memref.load %5[%13] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %5[%13] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %15 = memref.load %5[%c128] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      scf.for %arg4 = %arg3 to %8 step %c128 {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg1[%16] : memref<?xf32>
        %18 = arith.divf %17, %15 : f32
        memref.store %18, %arg1[%16] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c256 = arith.constant 256 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c1_i32 = arith.constant 1 : i32
      %c0_i32 = arith.constant 0 : i32
      %c128_i32 = arith.constant 128 : i32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.index_cast %arg3 : index to i32
      %3 = arith.muli %1, %arg2 : i32
      %4 = arith.index_cast %3 : i32 to index
      %5 = memref.get_global @shared_mem : memref<1xf32>
      %6 = func.call @__builtin_inff() : () -> f32
      %7 = arith.negf %6 : f32
      %8 = arith.index_cast %arg2 : i32 to index
      %9 = scf.for %arg4 = %arg3 to %8 step %c256 iter_args(%arg5 = %7) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.maxnumf %arg5, %17 : f32
        scf.yield %18 : f32
      }
      memref.store %9, %5[%arg3] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %10 = scf.while (%arg4 = %c128_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = memref.load %5[%arg3] : memref<1xf32>
          %19 = arith.addi %2, %arg4 : i32
          %20 = arith.index_cast %19 : i32 to index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = arith.maxnumf %18, %21 : f32
          memref.store %22, %5[%arg3] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %11 = memref.load %5[%c0_0] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %12 = scf.for %arg4 = %arg3 to %8 step %c256 iter_args(%arg5 = %cst) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.subf %17, %11 : f32
        %19 = math.exp %18 : f32
        memref.store %19, %arg1[%16] : memref<?xf32>
        %20 = arith.addf %arg5, %19 : f32
        scf.yield %20 : f32
      }
      %13 = arith.addi %arg3, %c256 : index
      memref.store %12, %5[%13] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %14 = scf.while (%arg4 = %c128_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = arith.addi %2, %arg4 : i32
          %19 = arith.index_cast %18 : i32 to index
          %20 = arith.addi %19, %c256 : index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = memref.load %5[%13] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %5[%13] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %15 = memref.load %5[%c256] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      scf.for %arg4 = %arg3 to %8 step %c256 {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg1[%16] : memref<?xf32>
        %18 = arith.divf %17, %15 : f32
        memref.store %18, %arg1[%16] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c512 = arith.constant 512 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c1_i32 = arith.constant 1 : i32
      %c0_i32 = arith.constant 0 : i32
      %c256_i32 = arith.constant 256 : i32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.index_cast %arg3 : index to i32
      %3 = arith.muli %1, %arg2 : i32
      %4 = arith.index_cast %3 : i32 to index
      %5 = memref.get_global @shared_mem : memref<1xf32>
      %6 = func.call @__builtin_inff() : () -> f32
      %7 = arith.negf %6 : f32
      %8 = arith.index_cast %arg2 : i32 to index
      %9 = scf.for %arg4 = %arg3 to %8 step %c512 iter_args(%arg5 = %7) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.maxnumf %arg5, %17 : f32
        scf.yield %18 : f32
      }
      memref.store %9, %5[%arg3] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %10 = scf.while (%arg4 = %c256_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = memref.load %5[%arg3] : memref<1xf32>
          %19 = arith.addi %2, %arg4 : i32
          %20 = arith.index_cast %19 : i32 to index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = arith.maxnumf %18, %21 : f32
          memref.store %22, %5[%arg3] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %11 = memref.load %5[%c0_0] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %12 = scf.for %arg4 = %arg3 to %8 step %c512 iter_args(%arg5 = %cst) -> (f32) {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg0[%16] : memref<?xf32>
        %18 = arith.subf %17, %11 : f32
        %19 = math.exp %18 : f32
        memref.store %19, %arg1[%16] : memref<?xf32>
        %20 = arith.addf %arg5, %19 : f32
        scf.yield %20 : f32
      }
      %13 = arith.addi %arg3, %c512 : index
      memref.store %12, %5[%13] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      %14 = scf.while (%arg4 = %c256_i32) : (i32) -> i32 {
        %16 = arith.cmpi sgt, %arg4, %c0_i32 : i32
        scf.condition(%16) %arg4 : i32
      } do {
      ^bb0(%arg4: i32):
        %16 = arith.cmpi slt, %2, %arg4 : i32
        scf.if %16 {
          %18 = arith.addi %2, %arg4 : i32
          %19 = arith.index_cast %18 : i32 to index
          %20 = arith.addi %19, %c512 : index
          %21 = memref.load %5[%20] : memref<1xf32>
          %22 = memref.load %5[%13] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %5[%13] : memref<1xf32>
        }
        "polygeist.barrier"(%arg3) : (index) -> ()
        %17 = arith.shrsi %arg4, %c1_i32 : i32
        scf.yield %17 : i32
      }
      %15 = memref.load %5[%c512] : memref<1xf32>
      "polygeist.barrier"(%arg3) : (index) -> ()
      scf.for %arg4 = %arg3 to %8 step %c512 {
        %16 = arith.addi %arg4, %4 : index
        %17 = memref.load %arg1[%16] : memref<?xf32>
        %18 = arith.divf %17, %15 : f32
        memref.store %18, %arg1[%16] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func private @__builtin_inff() -> f32 attributes {llvm.linkage = #llvm.linkage<external>}
}
[ict-debug] driver.cc: After return 7, module: end

[ict-debug] driver.cc: Before my pass process:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @shared_mem : memref<1xf32>
  func.func @_Z20softmax_forward_cudaPKfPfiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32) attributes {llvm.linkage = #llvm.linkage<external>} {
    %c512_i32 = arith.constant 512 : i32
    %c256_i32 = arith.constant 256 : i32
    %c128_i32 = arith.constant 128 : i32
    %c64_i32 = arith.constant 64 : i32
    %c32_i32 = arith.constant 32 : i32
    %c1_i32 = arith.constant 1 : i32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_3 = memref.cast %alloca_2 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_4 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_5 = memref.cast %alloca_4 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_6 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_7 = memref.cast %alloca_6 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_8 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_9 = memref.cast %alloca_8 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_10 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_11 = memref.cast %alloca_10 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_12 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_13 = memref.cast %alloca_12 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_14 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_15 = memref.cast %alloca_14 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_16 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_17 = memref.cast %alloca_16 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_18 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_19 = memref.cast %alloca_18 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_20 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_21 = memref.cast %alloca_20 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_22 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_23 = memref.cast %alloca_22 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_24 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_25 = memref.cast %alloca_24 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_26 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_27 = memref.cast %alloca_26 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_28 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_29 = memref.cast %alloca_28 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_30 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_31 = memref.cast %alloca_30 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_32 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_33 = memref.cast %alloca_32 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %alloca_34 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %cast_35 = memref.cast %alloca_34 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    call @_ZN4dim3C1Ejjj(%cast_35, %arg2, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    cf.switch %arg4 : i32, [
      default: ^bb6,
      32: ^bb1,
      64: ^bb2,
      128: ^bb3,
      256: ^bb4,
      512: ^bb5
    ]
  ^bb1:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_33, %c32_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_31, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %0 = "polygeist.memref2pointer"(%alloca_30) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.getelementptr %0[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %2 = llvm.load %1 : !llvm.ptr -> i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %5 = llvm.load %4 : !llvm.ptr -> i32
    %6 = arith.index_cast %5 : i32 to index
    %7 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %8 = llvm.load %7 : !llvm.ptr -> i32
    %9 = arith.index_cast %8 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_29, %cast_33) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %10 = "polygeist.memref2pointer"(%alloca_28) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %11 = llvm.getelementptr %10[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %12 = llvm.load %11 : !llvm.ptr -> i32
    %13 = arith.index_cast %12 : i32 to index
    %14 = llvm.getelementptr %10[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %15 = llvm.load %14 : !llvm.ptr -> i32
    %16 = arith.index_cast %15 : i32 to index
    %17 = llvm.getelementptr %10[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %18 = llvm.load %17 : !llvm.ptr -> i32
    %19 = arith.index_cast %18 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %3, %arg12 = %6, %arg13 = %9) threads(%arg8, %arg9, %arg10) in (%arg14 = %13, %arg15 = %16, %arg16 = %19) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb2:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_27, %c64_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_25, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %20 = "polygeist.memref2pointer"(%alloca_24) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %21 = llvm.getelementptr %20[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %22 = llvm.load %21 : !llvm.ptr -> i32
    %23 = arith.index_cast %22 : i32 to index
    %24 = llvm.getelementptr %20[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %25 = llvm.load %24 : !llvm.ptr -> i32
    %26 = arith.index_cast %25 : i32 to index
    %27 = llvm.getelementptr %20[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %28 = llvm.load %27 : !llvm.ptr -> i32
    %29 = arith.index_cast %28 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_23, %cast_27) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %30 = "polygeist.memref2pointer"(%alloca_22) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %31 = llvm.getelementptr %30[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %32 = llvm.load %31 : !llvm.ptr -> i32
    %33 = arith.index_cast %32 : i32 to index
    %34 = llvm.getelementptr %30[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %35 = llvm.load %34 : !llvm.ptr -> i32
    %36 = arith.index_cast %35 : i32 to index
    %37 = llvm.getelementptr %30[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %38 = llvm.load %37 : !llvm.ptr -> i32
    %39 = arith.index_cast %38 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %23, %arg12 = %26, %arg13 = %29) threads(%arg8, %arg9, %arg10) in (%arg14 = %33, %arg15 = %36, %arg16 = %39) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb3:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_21, %c128_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_19, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %40 = "polygeist.memref2pointer"(%alloca_18) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %41 = llvm.getelementptr %40[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %42 = llvm.load %41 : !llvm.ptr -> i32
    %43 = arith.index_cast %42 : i32 to index
    %44 = llvm.getelementptr %40[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %45 = llvm.load %44 : !llvm.ptr -> i32
    %46 = arith.index_cast %45 : i32 to index
    %47 = llvm.getelementptr %40[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %48 = llvm.load %47 : !llvm.ptr -> i32
    %49 = arith.index_cast %48 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_17, %cast_21) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %50 = "polygeist.memref2pointer"(%alloca_16) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %51 = llvm.getelementptr %50[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %52 = llvm.load %51 : !llvm.ptr -> i32
    %53 = arith.index_cast %52 : i32 to index
    %54 = llvm.getelementptr %50[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %55 = llvm.load %54 : !llvm.ptr -> i32
    %56 = arith.index_cast %55 : i32 to index
    %57 = llvm.getelementptr %50[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %58 = llvm.load %57 : !llvm.ptr -> i32
    %59 = arith.index_cast %58 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %43, %arg12 = %46, %arg13 = %49) threads(%arg8, %arg9, %arg10) in (%arg14 = %53, %arg15 = %56, %arg16 = %59) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb4:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_15, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_13, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %60 = "polygeist.memref2pointer"(%alloca_12) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %61 = llvm.getelementptr %60[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %62 = llvm.load %61 : !llvm.ptr -> i32
    %63 = arith.index_cast %62 : i32 to index
    %64 = llvm.getelementptr %60[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %65 = llvm.load %64 : !llvm.ptr -> i32
    %66 = arith.index_cast %65 : i32 to index
    %67 = llvm.getelementptr %60[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %68 = llvm.load %67 : !llvm.ptr -> i32
    %69 = arith.index_cast %68 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_11, %cast_15) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %70 = "polygeist.memref2pointer"(%alloca_10) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %71 = llvm.getelementptr %70[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %72 = llvm.load %71 : !llvm.ptr -> i32
    %73 = arith.index_cast %72 : i32 to index
    %74 = llvm.getelementptr %70[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %75 = llvm.load %74 : !llvm.ptr -> i32
    %76 = arith.index_cast %75 : i32 to index
    %77 = llvm.getelementptr %70[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %78 = llvm.load %77 : !llvm.ptr -> i32
    %79 = arith.index_cast %78 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %63, %arg12 = %66, %arg13 = %69) threads(%arg8, %arg9, %arg10) in (%arg14 = %73, %arg15 = %76, %arg16 = %79) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb5:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_9, %c512_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_7, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %80 = "polygeist.memref2pointer"(%alloca_6) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %81 = llvm.getelementptr %80[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %82 = llvm.load %81 : !llvm.ptr -> i32
    %83 = arith.index_cast %82 : i32 to index
    %84 = llvm.getelementptr %80[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %85 = llvm.load %84 : !llvm.ptr -> i32
    %86 = arith.index_cast %85 : i32 to index
    %87 = llvm.getelementptr %80[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %88 = llvm.load %87 : !llvm.ptr -> i32
    %89 = arith.index_cast %88 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast_5, %cast_9) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %90 = "polygeist.memref2pointer"(%alloca_4) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %91 = llvm.getelementptr %90[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %92 = llvm.load %91 : !llvm.ptr -> i32
    %93 = arith.index_cast %92 : i32 to index
    %94 = llvm.getelementptr %90[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %95 = llvm.load %94 : !llvm.ptr -> i32
    %96 = arith.index_cast %95 : i32 to index
    %97 = llvm.getelementptr %90[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %98 = llvm.load %97 : !llvm.ptr -> i32
    %99 = arith.index_cast %98 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %83, %arg12 = %86, %arg13 = %89) threads(%arg8, %arg9, %arg10) in (%arg14 = %93, %arg15 = %96, %arg16 = %99) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb6:  // pred: ^bb0
    call @_ZN4dim3C1Ejjj(%cast_3, %c256_i32, %c1_i32, %c1_i32) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    call @_ZN4dim3C1ERKS_(%cast_1, %cast_35) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %100 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %101 = llvm.getelementptr %100[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %102 = llvm.load %101 : !llvm.ptr -> i32
    %103 = arith.index_cast %102 : i32 to index
    %104 = llvm.getelementptr %100[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %105 = llvm.load %104 : !llvm.ptr -> i32
    %106 = arith.index_cast %105 : i32 to index
    %107 = llvm.getelementptr %100[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %108 = llvm.load %107 : !llvm.ptr -> i32
    %109 = arith.index_cast %108 : i32 to index
    call @_ZN4dim3C1ERKS_(%cast, %cast_3) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %110 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %111 = llvm.getelementptr %110[0, 0] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %112 = llvm.load %111 : !llvm.ptr -> i32
    %113 = arith.index_cast %112 : i32 to index
    %114 = llvm.getelementptr %110[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %115 = llvm.load %114 : !llvm.ptr -> i32
    %116 = arith.index_cast %115 : i32 to index
    %117 = llvm.getelementptr %110[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %118 = llvm.load %117 : !llvm.ptr -> i32
    %119 = arith.index_cast %118 : i32 to index
    gpu.launch blocks(%arg5, %arg6, %arg7) in (%arg11 = %103, %arg12 = %106, %arg13 = %109) threads(%arg8, %arg9, %arg10) in (%arg14 = %113, %arg15 = %116, %arg16 = %119) {
      func.call @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg3) : (memref<?xf32>, memref<?xf32>, i32) -> ()
      gpu.terminator
    }
    cf.br ^bb7
  ^bb7:  // 6 preds: ^bb1, ^bb2, ^bb3, ^bb4, ^bb5, ^bb6
    return
  }
  func.func private @_ZN4dim3C1Ejjj(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: i32, %arg2: i32, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %arg1, %0 : i32, !llvm.ptr
    %1 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg2, %1 : i32, !llvm.ptr
    %2 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %arg3, %2 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_ZN4dim3C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> i32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    llvm.store %1, %2 : i32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %4 = llvm.load %3 : !llvm.ptr -> i32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %4, %5 : i32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    %7 = llvm.load %6 : !llvm.ptr -> i32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>
    llvm.store %7, %8 : i32, !llvm.ptr
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    call @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0, %arg1, %arg2) : (memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func @_Z23softmax_kernel_templateILi32EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c16_i32 = arith.constant 16 : i32
    %c0_i32 = arith.constant 0 : i32
    %c1_i32 = arith.constant 1 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    %alloca_0 = memref.alloca() : memref<32xi32>
    %alloca_1 = memref.alloca() : memref<32xi32>
    %alloca_2 = memref.alloca() : memref<32xi32>
    %alloca_3 = memref.alloca() : memref<32xi32>
    %alloca_4 = memref.alloca() : memref<i1>
    %alloca_5 = memref.alloca() : memref<32xf32>
    %alloca_6 = memref.alloca() : memref<i1>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.muli %1, %arg2 : i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = arith.index_cast %arg2 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %17 = func.call @__builtin_inff() : () -> f32
      %18 = arith.negf %17 : f32
      %19 = scf.for %arg4 = %arg3 to %4 step %c32 iter_args(%arg5 = %18) -> (f32) {
        %20 = arith.addi %arg4, %3 : index
        %21 = memref.load %arg0[%20] : memref<?xf32>
        %22 = arith.maxnumf %arg5, %21 : f32
        scf.yield %22 : f32
      }
      memref.store %19, %alloca[%arg3] : memref<1xf32, 5>
      scf.yield
    }
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      memref.store %c16_i32, %alloca_2[%arg3] : memref<32xi32>
      scf.yield
    }
    scf.while : () -> () {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %18 = memref.load %alloca_2[%arg3] : memref<32xi32>
        %19 = arith.cmpi sgt, %18, %c0_i32 : i32
        %20 = arith.cmpi eq, %arg3, %c0 : index
        scf.if %20 {
          memref.store %19, %alloca_4[] : memref<i1>
        }
        memref.store %18, %alloca_3[%arg3] : memref<32xi32>
        scf.yield
      }
      %17 = memref.load %alloca_4[] : memref<i1>
      scf.condition(%17)
    } do {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %17 = arith.index_cast %arg3 : index to i32
        %18 = memref.load %alloca_3[%arg3] : memref<32xi32>
        %19 = arith.cmpi slt, %17, %18 : i32
        scf.if %19 {
          %20 = memref.load %alloca[%arg3] : memref<1xf32, 5>
          %21 = arith.addi %17, %18 : i32
          %22 = arith.index_cast %21 : i32 to index
          %23 = memref.load %alloca[%22] : memref<1xf32, 5>
          %24 = arith.maxnumf %20, %23 : f32
          memref.store %24, %alloca[%arg3] : memref<1xf32, 5>
        }
        scf.yield
      }
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %17 = memref.load %alloca_3[%arg3] : memref<32xi32>
        %18 = arith.shrsi %17, %c1_i32 : i32
        memref.store %18, %alloca_2[%arg3] : memref<32xi32>
        scf.yield
      }
      scf.yield
    }
    %5 = memref.load %alloca[%c0] : memref<1xf32, 5>
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      memref.store %5, %alloca_5[%arg3] : memref<32xf32>
      scf.yield
    }
    %6 = gpu.block_id  x
    %7 = arith.index_cast %6 : index to i32
    %8 = arith.muli %7, %arg2 : i32
    %9 = arith.index_cast %8 : i32 to index
    %10 = arith.index_cast %arg2 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %17 = memref.load %alloca_5[%arg3] : memref<32xf32>
      %18 = scf.for %arg4 = %arg3 to %10 step %c32 iter_args(%arg5 = %cst) -> (f32) {
        %20 = arith.addi %arg4, %9 : index
        %21 = memref.load %arg0[%20] : memref<?xf32>
        %22 = arith.subf %21, %17 : f32
        %23 = math.exp %22 : f32
        memref.store %23, %arg1[%20] : memref<?xf32>
        %24 = arith.addf %arg5, %23 : f32
        scf.yield %24 : f32
      }
      %19 = arith.addi %arg3, %c32 : index
      memref.store %18, %alloca[%19] : memref<1xf32, 5>
      memref.store %c16_i32, %alloca_0[%arg3] : memref<32xi32>
      scf.yield
    }
    scf.while : () -> () {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %18 = memref.load %alloca_0[%arg3] : memref<32xi32>
        %19 = arith.cmpi sgt, %18, %c0_i32 : i32
        %20 = arith.cmpi eq, %arg3, %c0 : index
        scf.if %20 {
          memref.store %19, %alloca_6[] : memref<i1>
        }
        memref.store %18, %alloca_1[%arg3] : memref<32xi32>
        scf.yield
      }
      %17 = memref.load %alloca_6[] : memref<i1>
      scf.condition(%17)
    } do {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %17 = arith.addi %arg3, %c32 : index
        %18 = arith.index_cast %arg3 : index to i32
        %19 = memref.load %alloca_1[%arg3] : memref<32xi32>
        %20 = arith.cmpi slt, %18, %19 : i32
        scf.if %20 {
          %21 = arith.addi %18, %19 : i32
          %22 = arith.index_cast %21 : i32 to index
          %23 = arith.addi %22, %c32 : index
          %24 = memref.load %alloca[%23] : memref<1xf32, 5>
          %25 = memref.load %alloca[%17] : memref<1xf32, 5>
          %26 = arith.addf %25, %24 : f32
          memref.store %26, %alloca[%17] : memref<1xf32, 5>
        }
        scf.yield
      }
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %17 = memref.load %alloca_1[%arg3] : memref<32xi32>
        %18 = arith.shrsi %17, %c1_i32 : i32
        memref.store %18, %alloca_0[%arg3] : memref<32xi32>
        scf.yield
      }
      scf.yield
    }
    %11 = gpu.block_id  x
    %12 = arith.index_cast %11 : index to i32
    %13 = arith.muli %12, %arg2 : i32
    %14 = arith.index_cast %13 : i32 to index
    %15 = arith.index_cast %arg2 : i32 to index
    %16 = arith.cmpi slt, %c0, %c32 : index
    scf.if %16 {
      %17 = memref.load %alloca[%c32] : memref<1xf32, 5>
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        scf.for %arg4 = %arg3 to %15 step %c32 {
          %18 = arith.addi %arg4, %14 : index
          %19 = memref.load %arg1[%18] : memref<?xf32>
          %20 = arith.divf %19, %17 : f32
          memref.store %20, %arg1[%18] : memref<?xf32>
        }
        scf.yield
      }
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi64EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c32_i32 = arith.constant 32 : i32
    %c0_i32 = arith.constant 0 : i32
    %c1_i32 = arith.constant 1 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %c64 = arith.constant 64 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<32xi32>
    %alloca_0 = memref.alloca() : memref<32xi32>
    %alloca_1 = memref.alloca() : memref<32xi32>
    %alloca_2 = memref.alloca() : memref<32xi32>
    %alloca_3 = memref.alloca() : memref<i1>
    %alloca_4 = memref.alloca() : memref<32xf32>
    %alloca_5 = memref.alloca() : memref<i1>
    %alloca_6 = memref.alloca() : memref<32xf32>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.muli %1, %arg2 : i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = memref.get_global @shared_mem : memref<1xf32>
    %5 = arith.index_cast %arg2 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = func.call @__builtin_inff() : () -> f32
      %24 = arith.negf %23 : f32
      %25 = scf.for %arg4 = %arg3 to %5 step %c64 iter_args(%arg5 = %24) -> (f32) {
        %26 = arith.addi %arg4, %3 : index
        %27 = memref.load %arg0[%26] : memref<?xf32>
        %28 = arith.maxnumf %arg5, %27 : f32
        scf.yield %28 : f32
      }
      memref.store %25, %4[%arg3] : memref<1xf32>
      scf.yield
    }
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      memref.store %c32_i32, %alloca_1[%arg3] : memref<32xi32>
      scf.yield
    }
    %6 = memref.get_global @shared_mem : memref<1xf32>
    scf.while : () -> () {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %24 = memref.load %alloca_1[%arg3] : memref<32xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.cmpi eq, %arg3, %c0 : index
        scf.if %26 {
          memref.store %25, %alloca_3[] : memref<i1>
        }
        memref.store %24, %alloca_2[%arg3] : memref<32xi32>
        scf.yield
      }
      %23 = memref.load %alloca_3[] : memref<i1>
      scf.condition(%23)
    } do {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = arith.index_cast %arg3 : index to i32
        %24 = memref.load %alloca_2[%arg3] : memref<32xi32>
        %25 = arith.cmpi slt, %23, %24 : i32
        scf.if %25 {
          %26 = memref.load %6[%arg3] : memref<1xf32>
          %27 = arith.addi %23, %24 : i32
          %28 = arith.index_cast %27 : i32 to index
          %29 = memref.load %6[%28] : memref<1xf32>
          %30 = arith.maxnumf %26, %29 : f32
          memref.store %30, %6[%arg3] : memref<1xf32>
        }
        scf.yield
      }
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_2[%arg3] : memref<32xi32>
        %24 = arith.shrsi %23, %c1_i32 : i32
        memref.store %24, %alloca_1[%arg3] : memref<32xi32>
        scf.yield
      }
      scf.yield
    }
    %7 = memref.get_global @shared_mem : memref<1xf32>
    %8 = arith.cmpi slt, %c0, %c32 : index
    scf.if %8 {
      %23 = memref.load %7[%c0] : memref<1xf32>
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        memref.store %23, %alloca_4[%arg3] : memref<32xf32>
        scf.yield
      }
    }
    %9 = gpu.block_id  x
    %10 = arith.index_cast %9 : index to i32
    %11 = arith.muli %10, %arg2 : i32
    %12 = arith.index_cast %11 : i32 to index
    %13 = memref.get_global @shared_mem : memref<1xf32>
    %14 = arith.index_cast %arg2 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = memref.load %alloca_4[%arg3] : memref<32xf32>
      %24 = scf.for %arg4 = %arg3 to %14 step %c64 iter_args(%arg5 = %cst) -> (f32) {
        %26 = arith.addi %arg4, %12 : index
        %27 = memref.load %arg0[%26] : memref<?xf32>
        %28 = arith.subf %27, %23 : f32
        %29 = math.exp %28 : f32
        memref.store %29, %arg1[%26] : memref<?xf32>
        %30 = arith.addf %arg5, %29 : f32
        scf.yield %30 : f32
      }
      %25 = arith.addi %arg3, %c64 : index
      memref.store %24, %13[%25] : memref<1xf32>
      memref.store %c32_i32, %alloca[%arg3] : memref<32xi32>
      scf.yield
    }
    %15 = memref.get_global @shared_mem : memref<1xf32>
    scf.while : () -> () {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %24 = memref.load %alloca[%arg3] : memref<32xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.cmpi eq, %arg3, %c0 : index
        scf.if %26 {
          memref.store %25, %alloca_5[] : memref<i1>
        }
        memref.store %24, %alloca_0[%arg3] : memref<32xi32>
        scf.yield
      }
      %23 = memref.load %alloca_5[] : memref<i1>
      scf.condition(%23)
    } do {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = arith.addi %arg3, %c64 : index
        %24 = arith.index_cast %arg3 : index to i32
        %25 = memref.load %alloca_0[%arg3] : memref<32xi32>
        %26 = arith.cmpi slt, %24, %25 : i32
        scf.if %26 {
          %27 = arith.addi %24, %25 : i32
          %28 = arith.index_cast %27 : i32 to index
          %29 = arith.addi %28, %c64 : index
          %30 = memref.load %15[%29] : memref<1xf32>
          %31 = memref.load %15[%23] : memref<1xf32>
          %32 = arith.addf %31, %30 : f32
          memref.store %32, %15[%23] : memref<1xf32>
        }
        scf.yield
      }
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_0[%arg3] : memref<32xi32>
        %24 = arith.shrsi %23, %c1_i32 : i32
        memref.store %24, %alloca[%arg3] : memref<32xi32>
        scf.yield
      }
      scf.yield
    }
    %16 = memref.get_global @shared_mem : memref<1xf32>
    %17 = arith.cmpi slt, %c0, %c32 : index
    scf.if %17 {
      %23 = memref.load %16[%c64] : memref<1xf32>
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        memref.store %23, %alloca_6[%arg3] : memref<32xf32>
        scf.yield
      }
    }
    %18 = arith.index_cast %arg2 : i32 to index
    %19 = gpu.block_id  x
    %20 = arith.index_cast %19 : index to i32
    %21 = arith.muli %20, %arg2 : i32
    %22 = arith.index_cast %21 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = memref.load %alloca_6[%arg3] : memref<32xf32>
      scf.for %arg4 = %arg3 to %18 step %c64 {
        %24 = arith.addi %arg4, %22 : index
        %25 = memref.load %arg1[%24] : memref<?xf32>
        %26 = arith.divf %25, %23 : f32
        memref.store %26, %arg1[%24] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi128EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c64_i32 = arith.constant 64 : i32
    %c0_i32 = arith.constant 0 : i32
    %c1_i32 = arith.constant 1 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %c128 = arith.constant 128 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<32xi32>
    %alloca_0 = memref.alloca() : memref<32xi32>
    %alloca_1 = memref.alloca() : memref<32xi32>
    %alloca_2 = memref.alloca() : memref<32xi32>
    %alloca_3 = memref.alloca() : memref<i1>
    %alloca_4 = memref.alloca() : memref<32xf32>
    %alloca_5 = memref.alloca() : memref<i1>
    %alloca_6 = memref.alloca() : memref<32xf32>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.muli %1, %arg2 : i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = memref.get_global @shared_mem : memref<1xf32>
    %5 = arith.index_cast %arg2 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = func.call @__builtin_inff() : () -> f32
      %24 = arith.negf %23 : f32
      %25 = scf.for %arg4 = %arg3 to %5 step %c128 iter_args(%arg5 = %24) -> (f32) {
        %26 = arith.addi %arg4, %3 : index
        %27 = memref.load %arg0[%26] : memref<?xf32>
        %28 = arith.maxnumf %arg5, %27 : f32
        scf.yield %28 : f32
      }
      memref.store %25, %4[%arg3] : memref<1xf32>
      scf.yield
    }
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      memref.store %c64_i32, %alloca_1[%arg3] : memref<32xi32>
      scf.yield
    }
    %6 = memref.get_global @shared_mem : memref<1xf32>
    scf.while : () -> () {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %24 = memref.load %alloca_1[%arg3] : memref<32xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.cmpi eq, %arg3, %c0 : index
        scf.if %26 {
          memref.store %25, %alloca_3[] : memref<i1>
        }
        memref.store %24, %alloca_2[%arg3] : memref<32xi32>
        scf.yield
      }
      %23 = memref.load %alloca_3[] : memref<i1>
      scf.condition(%23)
    } do {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = arith.index_cast %arg3 : index to i32
        %24 = memref.load %alloca_2[%arg3] : memref<32xi32>
        %25 = arith.cmpi slt, %23, %24 : i32
        scf.if %25 {
          %26 = memref.load %6[%arg3] : memref<1xf32>
          %27 = arith.addi %23, %24 : i32
          %28 = arith.index_cast %27 : i32 to index
          %29 = memref.load %6[%28] : memref<1xf32>
          %30 = arith.maxnumf %26, %29 : f32
          memref.store %30, %6[%arg3] : memref<1xf32>
        }
        scf.yield
      }
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_2[%arg3] : memref<32xi32>
        %24 = arith.shrsi %23, %c1_i32 : i32
        memref.store %24, %alloca_1[%arg3] : memref<32xi32>
        scf.yield
      }
      scf.yield
    }
    %7 = memref.get_global @shared_mem : memref<1xf32>
    %8 = arith.cmpi slt, %c0, %c32 : index
    scf.if %8 {
      %23 = memref.load %7[%c0] : memref<1xf32>
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        memref.store %23, %alloca_4[%arg3] : memref<32xf32>
        scf.yield
      }
    }
    %9 = gpu.block_id  x
    %10 = arith.index_cast %9 : index to i32
    %11 = arith.muli %10, %arg2 : i32
    %12 = arith.index_cast %11 : i32 to index
    %13 = memref.get_global @shared_mem : memref<1xf32>
    %14 = arith.index_cast %arg2 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = memref.load %alloca_4[%arg3] : memref<32xf32>
      %24 = scf.for %arg4 = %arg3 to %14 step %c128 iter_args(%arg5 = %cst) -> (f32) {
        %26 = arith.addi %arg4, %12 : index
        %27 = memref.load %arg0[%26] : memref<?xf32>
        %28 = arith.subf %27, %23 : f32
        %29 = math.exp %28 : f32
        memref.store %29, %arg1[%26] : memref<?xf32>
        %30 = arith.addf %arg5, %29 : f32
        scf.yield %30 : f32
      }
      %25 = arith.addi %arg3, %c128 : index
      memref.store %24, %13[%25] : memref<1xf32>
      memref.store %c64_i32, %alloca[%arg3] : memref<32xi32>
      scf.yield
    }
    %15 = memref.get_global @shared_mem : memref<1xf32>
    scf.while : () -> () {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %24 = memref.load %alloca[%arg3] : memref<32xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.cmpi eq, %arg3, %c0 : index
        scf.if %26 {
          memref.store %25, %alloca_5[] : memref<i1>
        }
        memref.store %24, %alloca_0[%arg3] : memref<32xi32>
        scf.yield
      }
      %23 = memref.load %alloca_5[] : memref<i1>
      scf.condition(%23)
    } do {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = arith.addi %arg3, %c128 : index
        %24 = arith.index_cast %arg3 : index to i32
        %25 = memref.load %alloca_0[%arg3] : memref<32xi32>
        %26 = arith.cmpi slt, %24, %25 : i32
        scf.if %26 {
          %27 = arith.addi %24, %25 : i32
          %28 = arith.index_cast %27 : i32 to index
          %29 = arith.addi %28, %c128 : index
          %30 = memref.load %15[%29] : memref<1xf32>
          %31 = memref.load %15[%23] : memref<1xf32>
          %32 = arith.addf %31, %30 : f32
          memref.store %32, %15[%23] : memref<1xf32>
        }
        scf.yield
      }
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_0[%arg3] : memref<32xi32>
        %24 = arith.shrsi %23, %c1_i32 : i32
        memref.store %24, %alloca[%arg3] : memref<32xi32>
        scf.yield
      }
      scf.yield
    }
    %16 = memref.get_global @shared_mem : memref<1xf32>
    %17 = arith.cmpi slt, %c0, %c32 : index
    scf.if %17 {
      %23 = memref.load %16[%c128] : memref<1xf32>
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        memref.store %23, %alloca_6[%arg3] : memref<32xf32>
        scf.yield
      }
    }
    %18 = arith.index_cast %arg2 : i32 to index
    %19 = gpu.block_id  x
    %20 = arith.index_cast %19 : index to i32
    %21 = arith.muli %20, %arg2 : i32
    %22 = arith.index_cast %21 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = memref.load %alloca_6[%arg3] : memref<32xf32>
      scf.for %arg4 = %arg3 to %18 step %c128 {
        %24 = arith.addi %arg4, %22 : index
        %25 = memref.load %arg1[%24] : memref<?xf32>
        %26 = arith.divf %25, %23 : f32
        memref.store %26, %arg1[%24] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi256EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c128_i32 = arith.constant 128 : i32
    %c0_i32 = arith.constant 0 : i32
    %c1_i32 = arith.constant 1 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<32xi32>
    %alloca_0 = memref.alloca() : memref<32xi32>
    %alloca_1 = memref.alloca() : memref<32xi32>
    %alloca_2 = memref.alloca() : memref<32xi32>
    %alloca_3 = memref.alloca() : memref<i1>
    %alloca_4 = memref.alloca() : memref<32xf32>
    %alloca_5 = memref.alloca() : memref<i1>
    %alloca_6 = memref.alloca() : memref<32xf32>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.muli %1, %arg2 : i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = memref.get_global @shared_mem : memref<1xf32>
    %5 = arith.index_cast %arg2 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = func.call @__builtin_inff() : () -> f32
      %24 = arith.negf %23 : f32
      %25 = scf.for %arg4 = %arg3 to %5 step %c256 iter_args(%arg5 = %24) -> (f32) {
        %26 = arith.addi %arg4, %3 : index
        %27 = memref.load %arg0[%26] : memref<?xf32>
        %28 = arith.maxnumf %arg5, %27 : f32
        scf.yield %28 : f32
      }
      memref.store %25, %4[%arg3] : memref<1xf32>
      scf.yield
    }
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      memref.store %c128_i32, %alloca_1[%arg3] : memref<32xi32>
      scf.yield
    }
    %6 = memref.get_global @shared_mem : memref<1xf32>
    scf.while : () -> () {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %24 = memref.load %alloca_1[%arg3] : memref<32xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.cmpi eq, %arg3, %c0 : index
        scf.if %26 {
          memref.store %25, %alloca_3[] : memref<i1>
        }
        memref.store %24, %alloca_2[%arg3] : memref<32xi32>
        scf.yield
      }
      %23 = memref.load %alloca_3[] : memref<i1>
      scf.condition(%23)
    } do {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = arith.index_cast %arg3 : index to i32
        %24 = memref.load %alloca_2[%arg3] : memref<32xi32>
        %25 = arith.cmpi slt, %23, %24 : i32
        scf.if %25 {
          %26 = memref.load %6[%arg3] : memref<1xf32>
          %27 = arith.addi %23, %24 : i32
          %28 = arith.index_cast %27 : i32 to index
          %29 = memref.load %6[%28] : memref<1xf32>
          %30 = arith.maxnumf %26, %29 : f32
          memref.store %30, %6[%arg3] : memref<1xf32>
        }
        scf.yield
      }
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_2[%arg3] : memref<32xi32>
        %24 = arith.shrsi %23, %c1_i32 : i32
        memref.store %24, %alloca_1[%arg3] : memref<32xi32>
        scf.yield
      }
      scf.yield
    }
    %7 = memref.get_global @shared_mem : memref<1xf32>
    %8 = arith.cmpi slt, %c0, %c32 : index
    scf.if %8 {
      %23 = memref.load %7[%c0] : memref<1xf32>
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        memref.store %23, %alloca_4[%arg3] : memref<32xf32>
        scf.yield
      }
    }
    %9 = gpu.block_id  x
    %10 = arith.index_cast %9 : index to i32
    %11 = arith.muli %10, %arg2 : i32
    %12 = arith.index_cast %11 : i32 to index
    %13 = memref.get_global @shared_mem : memref<1xf32>
    %14 = arith.index_cast %arg2 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = memref.load %alloca_4[%arg3] : memref<32xf32>
      %24 = scf.for %arg4 = %arg3 to %14 step %c256 iter_args(%arg5 = %cst) -> (f32) {
        %26 = arith.addi %arg4, %12 : index
        %27 = memref.load %arg0[%26] : memref<?xf32>
        %28 = arith.subf %27, %23 : f32
        %29 = math.exp %28 : f32
        memref.store %29, %arg1[%26] : memref<?xf32>
        %30 = arith.addf %arg5, %29 : f32
        scf.yield %30 : f32
      }
      %25 = arith.addi %arg3, %c256 : index
      memref.store %24, %13[%25] : memref<1xf32>
      memref.store %c128_i32, %alloca[%arg3] : memref<32xi32>
      scf.yield
    }
    %15 = memref.get_global @shared_mem : memref<1xf32>
    scf.while : () -> () {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %24 = memref.load %alloca[%arg3] : memref<32xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.cmpi eq, %arg3, %c0 : index
        scf.if %26 {
          memref.store %25, %alloca_5[] : memref<i1>
        }
        memref.store %24, %alloca_0[%arg3] : memref<32xi32>
        scf.yield
      }
      %23 = memref.load %alloca_5[] : memref<i1>
      scf.condition(%23)
    } do {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = arith.addi %arg3, %c256 : index
        %24 = arith.index_cast %arg3 : index to i32
        %25 = memref.load %alloca_0[%arg3] : memref<32xi32>
        %26 = arith.cmpi slt, %24, %25 : i32
        scf.if %26 {
          %27 = arith.addi %24, %25 : i32
          %28 = arith.index_cast %27 : i32 to index
          %29 = arith.addi %28, %c256 : index
          %30 = memref.load %15[%29] : memref<1xf32>
          %31 = memref.load %15[%23] : memref<1xf32>
          %32 = arith.addf %31, %30 : f32
          memref.store %32, %15[%23] : memref<1xf32>
        }
        scf.yield
      }
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_0[%arg3] : memref<32xi32>
        %24 = arith.shrsi %23, %c1_i32 : i32
        memref.store %24, %alloca[%arg3] : memref<32xi32>
        scf.yield
      }
      scf.yield
    }
    %16 = memref.get_global @shared_mem : memref<1xf32>
    %17 = arith.cmpi slt, %c0, %c32 : index
    scf.if %17 {
      %23 = memref.load %16[%c256] : memref<1xf32>
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        memref.store %23, %alloca_6[%arg3] : memref<32xf32>
        scf.yield
      }
    }
    %18 = arith.index_cast %arg2 : i32 to index
    %19 = gpu.block_id  x
    %20 = arith.index_cast %19 : index to i32
    %21 = arith.muli %20, %arg2 : i32
    %22 = arith.index_cast %21 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = memref.load %alloca_6[%arg3] : memref<32xf32>
      scf.for %arg4 = %arg3 to %18 step %c256 {
        %24 = arith.addi %arg4, %22 : index
        %25 = memref.load %arg1[%24] : memref<?xf32>
        %26 = arith.divf %25, %23 : f32
        memref.store %26, %arg1[%24] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z23softmax_kernel_templateILi512EEvPKfPfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c256_i32 = arith.constant 256 : i32
    %c0_i32 = arith.constant 0 : i32
    %c1_i32 = arith.constant 1 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %c512 = arith.constant 512 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<32xi32>
    %alloca_0 = memref.alloca() : memref<32xi32>
    %alloca_1 = memref.alloca() : memref<32xi32>
    %alloca_2 = memref.alloca() : memref<32xi32>
    %alloca_3 = memref.alloca() : memref<i1>
    %alloca_4 = memref.alloca() : memref<32xf32>
    %alloca_5 = memref.alloca() : memref<i1>
    %alloca_6 = memref.alloca() : memref<32xf32>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.muli %1, %arg2 : i32
    %3 = arith.index_cast %2 : i32 to index
    %4 = memref.get_global @shared_mem : memref<1xf32>
    %5 = arith.index_cast %arg2 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = func.call @__builtin_inff() : () -> f32
      %24 = arith.negf %23 : f32
      %25 = scf.for %arg4 = %arg3 to %5 step %c512 iter_args(%arg5 = %24) -> (f32) {
        %26 = arith.addi %arg4, %3 : index
        %27 = memref.load %arg0[%26] : memref<?xf32>
        %28 = arith.maxnumf %arg5, %27 : f32
        scf.yield %28 : f32
      }
      memref.store %25, %4[%arg3] : memref<1xf32>
      scf.yield
    }
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      memref.store %c256_i32, %alloca_1[%arg3] : memref<32xi32>
      scf.yield
    }
    %6 = memref.get_global @shared_mem : memref<1xf32>
    scf.while : () -> () {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %24 = memref.load %alloca_1[%arg3] : memref<32xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.cmpi eq, %arg3, %c0 : index
        scf.if %26 {
          memref.store %25, %alloca_3[] : memref<i1>
        }
        memref.store %24, %alloca_2[%arg3] : memref<32xi32>
        scf.yield
      }
      %23 = memref.load %alloca_3[] : memref<i1>
      scf.condition(%23)
    } do {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = arith.index_cast %arg3 : index to i32
        %24 = memref.load %alloca_2[%arg3] : memref<32xi32>
        %25 = arith.cmpi slt, %23, %24 : i32
        scf.if %25 {
          %26 = memref.load %6[%arg3] : memref<1xf32>
          %27 = arith.addi %23, %24 : i32
          %28 = arith.index_cast %27 : i32 to index
          %29 = memref.load %6[%28] : memref<1xf32>
          %30 = arith.maxnumf %26, %29 : f32
          memref.store %30, %6[%arg3] : memref<1xf32>
        }
        scf.yield
      }
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_2[%arg3] : memref<32xi32>
        %24 = arith.shrsi %23, %c1_i32 : i32
        memref.store %24, %alloca_1[%arg3] : memref<32xi32>
        scf.yield
      }
      scf.yield
    }
    %7 = memref.get_global @shared_mem : memref<1xf32>
    %8 = arith.cmpi slt, %c0, %c32 : index
    scf.if %8 {
      %23 = memref.load %7[%c0] : memref<1xf32>
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        memref.store %23, %alloca_4[%arg3] : memref<32xf32>
        scf.yield
      }
    }
    %9 = gpu.block_id  x
    %10 = arith.index_cast %9 : index to i32
    %11 = arith.muli %10, %arg2 : i32
    %12 = arith.index_cast %11 : i32 to index
    %13 = memref.get_global @shared_mem : memref<1xf32>
    %14 = arith.index_cast %arg2 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = memref.load %alloca_4[%arg3] : memref<32xf32>
      %24 = scf.for %arg4 = %arg3 to %14 step %c512 iter_args(%arg5 = %cst) -> (f32) {
        %26 = arith.addi %arg4, %12 : index
        %27 = memref.load %arg0[%26] : memref<?xf32>
        %28 = arith.subf %27, %23 : f32
        %29 = math.exp %28 : f32
        memref.store %29, %arg1[%26] : memref<?xf32>
        %30 = arith.addf %arg5, %29 : f32
        scf.yield %30 : f32
      }
      %25 = arith.addi %arg3, %c512 : index
      memref.store %24, %13[%25] : memref<1xf32>
      memref.store %c256_i32, %alloca[%arg3] : memref<32xi32>
      scf.yield
    }
    %15 = memref.get_global @shared_mem : memref<1xf32>
    scf.while : () -> () {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %24 = memref.load %alloca[%arg3] : memref<32xi32>
        %25 = arith.cmpi sgt, %24, %c0_i32 : i32
        %26 = arith.cmpi eq, %arg3, %c0 : index
        scf.if %26 {
          memref.store %25, %alloca_5[] : memref<i1>
        }
        memref.store %24, %alloca_0[%arg3] : memref<32xi32>
        scf.yield
      }
      %23 = memref.load %alloca_5[] : memref<i1>
      scf.condition(%23)
    } do {
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = arith.addi %arg3, %c512 : index
        %24 = arith.index_cast %arg3 : index to i32
        %25 = memref.load %alloca_0[%arg3] : memref<32xi32>
        %26 = arith.cmpi slt, %24, %25 : i32
        scf.if %26 {
          %27 = arith.addi %24, %25 : i32
          %28 = arith.index_cast %27 : i32 to index
          %29 = arith.addi %28, %c512 : index
          %30 = memref.load %15[%29] : memref<1xf32>
          %31 = memref.load %15[%23] : memref<1xf32>
          %32 = arith.addf %31, %30 : f32
          memref.store %32, %15[%23] : memref<1xf32>
        }
        scf.yield
      }
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_0[%arg3] : memref<32xi32>
        %24 = arith.shrsi %23, %c1_i32 : i32
        memref.store %24, %alloca[%arg3] : memref<32xi32>
        scf.yield
      }
      scf.yield
    }
    %16 = memref.get_global @shared_mem : memref<1xf32>
    %17 = arith.cmpi slt, %c0, %c32 : index
    scf.if %17 {
      %23 = memref.load %16[%c512] : memref<1xf32>
      scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
        memref.store %23, %alloca_6[%arg3] : memref<32xf32>
        scf.yield
      }
    }
    %18 = arith.index_cast %arg2 : i32 to index
    %19 = gpu.block_id  x
    %20 = arith.index_cast %19 : index to i32
    %21 = arith.muli %20, %arg2 : i32
    %22 = arith.index_cast %21 : i32 to index
    scf.parallel (%arg3) = (%c0) to (%c32) step (%c1) {
      %23 = memref.load %alloca_6[%arg3] : memref<32xf32>
      scf.for %arg4 = %arg3 to %18 step %c512 {
        %24 = arith.addi %arg4, %22 : index
        %25 = memref.load %arg1[%24] : memref<?xf32>
        %26 = arith.divf %25, %23 : f32
        memref.store %26, %arg1[%24] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func private @__builtin_inff() -> f32 attributes {llvm.linkage = #llvm.linkage<external>}
}
[ict-debug] driver.cc: Before my pass process: end

[ict-debug] driver.cc: vectorizeSize = 1

loc("/usr/local/cuda/include/crt/host_defines.h":96:9): error: 'func.call' op '_Z23softmax_kernel_templateILi512EEvPKfPfi' does not reference a valid function
"builtin.module"() ({
  "memref.global"() <{sym_name = "shared_mem", type = memref<1xf32>}> : () -> ()
  "func.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, i32, i32) -> (), sym_name = "_Z20softmax_forward_cudaPKfPfiii"}> ({
  ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: i32, %arg4: i32):
    %0 = "arith.constant"() <{value = 512 : i32}> : () -> i32
    %1 = "arith.constant"() <{value = 256 : i32}> : () -> i32
    %2 = "arith.constant"() <{value = 128 : i32}> : () -> i32
    %3 = "arith.constant"() <{value = 64 : i32}> : () -> i32
    %4 = "arith.constant"() <{value = 32 : i32}> : () -> i32
    %5 = "arith.constant"() <{value = 1 : i32}> : () -> i32
    %6 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %7 = "memref.cast"(%6) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %8 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %9 = "memref.cast"(%8) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %10 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %11 = "memref.cast"(%10) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %12 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %13 = "memref.cast"(%12) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %14 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %15 = "memref.cast"(%14) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %16 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %17 = "memref.cast"(%16) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %18 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %19 = "memref.cast"(%18) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %20 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %21 = "memref.cast"(%20) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %22 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %23 = "memref.cast"(%22) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %24 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %25 = "memref.cast"(%24) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %26 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %27 = "memref.cast"(%26) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %28 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %29 = "memref.cast"(%28) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %30 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %31 = "memref.cast"(%30) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %32 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %33 = "memref.cast"(%32) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %34 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %35 = "memref.cast"(%34) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %36 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %37 = "memref.cast"(%36) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %38 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %39 = "memref.cast"(%38) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %40 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %41 = "memref.cast"(%40) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %42 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    %43 = "memref.cast"(%42) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>
    "func.call"(%43, %arg2, %5, %5) <{callee = @_ZN4dim3C1Ejjj}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    "cf.switch"(%arg4)[^bb6, ^bb1, ^bb2, ^bb3, ^bb4, ^bb5] <{case_operand_segments = array<i32: 0, 0, 0, 0, 0>, case_values = dense<[32, 64, 128, 256, 512]> : vector<5xi32>, operandSegmentSizes = array<i32: 1, 0, 0>}> : (i32) -> ()
  ^bb1:  // pred: ^bb0
    "func.call"(%41, %4, %5, %5) <{callee = @_ZN4dim3C1Ejjj}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    "func.call"(%39, %43) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %44 = "polygeist.memref2pointer"(%38) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %45 = "llvm.getelementptr"(%44) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %46 = "llvm.load"(%45) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %47 = "arith.index_cast"(%46) : (i32) -> index
    %48 = "llvm.getelementptr"(%44) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %49 = "llvm.load"(%48) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %50 = "arith.index_cast"(%49) : (i32) -> index
    %51 = "llvm.getelementptr"(%44) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %52 = "llvm.load"(%51) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %53 = "arith.index_cast"(%52) : (i32) -> index
    "func.call"(%37, %41) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %54 = "polygeist.memref2pointer"(%36) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %55 = "llvm.getelementptr"(%54) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %56 = "llvm.load"(%55) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %57 = "arith.index_cast"(%56) : (i32) -> index
    %58 = "llvm.getelementptr"(%54) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %59 = "llvm.load"(%58) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %60 = "arith.index_cast"(%59) : (i32) -> index
    %61 = "llvm.getelementptr"(%54) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %62 = "llvm.load"(%61) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %63 = "arith.index_cast"(%62) : (i32) -> index
    "gpu.launch"(%47, %50, %53, %57, %60, %63) <{operandSegmentSizes = array<i32: 0, 1, 1, 1, 1, 1, 1, 0>}> ({
    ^bb0(%arg5: index, %arg6: index, %arg7: index, %arg8: index, %arg9: index, %arg10: index, %arg11: index, %arg12: index, %arg13: index, %arg14: index, %arg15: index, %arg16: index):
      "func.call"(%arg0, %arg1, %arg3) <{callee = @_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi}> : (memref<?xf32>, memref<?xf32>, i32) -> ()
      "gpu.terminator"() : () -> ()
    }) {workgroup_attributions = 0 : i64} : (index, index, index, index, index, index) -> ()
    "cf.br"()[^bb7] : () -> ()
  ^bb2:  // pred: ^bb0
    "func.call"(%35, %3, %5, %5) <{callee = @_ZN4dim3C1Ejjj}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    "func.call"(%33, %43) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %64 = "polygeist.memref2pointer"(%32) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %65 = "llvm.getelementptr"(%64) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %66 = "llvm.load"(%65) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %67 = "arith.index_cast"(%66) : (i32) -> index
    %68 = "llvm.getelementptr"(%64) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %69 = "llvm.load"(%68) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %70 = "arith.index_cast"(%69) : (i32) -> index
    %71 = "llvm.getelementptr"(%64) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %72 = "llvm.load"(%71) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %73 = "arith.index_cast"(%72) : (i32) -> index
    "func.call"(%31, %35) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %74 = "polygeist.memref2pointer"(%30) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %75 = "llvm.getelementptr"(%74) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %76 = "llvm.load"(%75) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %77 = "arith.index_cast"(%76) : (i32) -> index
    %78 = "llvm.getelementptr"(%74) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %79 = "llvm.load"(%78) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %80 = "arith.index_cast"(%79) : (i32) -> index
    %81 = "llvm.getelementptr"(%74) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %82 = "llvm.load"(%81) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %83 = "arith.index_cast"(%82) : (i32) -> index
    "gpu.launch"(%67, %70, %73, %77, %80, %83) <{operandSegmentSizes = array<i32: 0, 1, 1, 1, 1, 1, 1, 0>}> ({
    ^bb0(%arg5: index, %arg6: index, %arg7: index, %arg8: index, %arg9: index, %arg10: index, %arg11: index, %arg12: index, %arg13: index, %arg14: index, %arg15: index, %arg16: index):
      "func.call"(%arg0, %arg1, %arg3) <{callee = @_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi}> : (memref<?xf32>, memref<?xf32>, i32) -> ()
      "gpu.terminator"() : () -> ()
    }) {workgroup_attributions = 0 : i64} : (index, index, index, index, index, index) -> ()
    "cf.br"()[^bb7] : () -> ()
  ^bb3:  // pred: ^bb0
    "func.call"(%29, %2, %5, %5) <{callee = @_ZN4dim3C1Ejjj}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    "func.call"(%27, %43) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %84 = "polygeist.memref2pointer"(%26) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %85 = "llvm.getelementptr"(%84) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %86 = "llvm.load"(%85) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %87 = "arith.index_cast"(%86) : (i32) -> index
    %88 = "llvm.getelementptr"(%84) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %89 = "llvm.load"(%88) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %90 = "arith.index_cast"(%89) : (i32) -> index
    %91 = "llvm.getelementptr"(%84) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %92 = "llvm.load"(%91) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %93 = "arith.index_cast"(%92) : (i32) -> index
    "func.call"(%25, %29) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %94 = "polygeist.memref2pointer"(%24) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %95 = "llvm.getelementptr"(%94) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %96 = "llvm.load"(%95) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %97 = "arith.index_cast"(%96) : (i32) -> index
    %98 = "llvm.getelementptr"(%94) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %99 = "llvm.load"(%98) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %100 = "arith.index_cast"(%99) : (i32) -> index
    %101 = "llvm.getelementptr"(%94) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %102 = "llvm.load"(%101) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %103 = "arith.index_cast"(%102) : (i32) -> index
    "gpu.launch"(%87, %90, %93, %97, %100, %103) <{operandSegmentSizes = array<i32: 0, 1, 1, 1, 1, 1, 1, 0>}> ({
    ^bb0(%arg5: index, %arg6: index, %arg7: index, %arg8: index, %arg9: index, %arg10: index, %arg11: index, %arg12: index, %arg13: index, %arg14: index, %arg15: index, %arg16: index):
      "func.call"(%arg0, %arg1, %arg3) <{callee = @_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi}> : (memref<?xf32>, memref<?xf32>, i32) -> ()
      "gpu.terminator"() : () -> ()
    }) {workgroup_attributions = 0 : i64} : (index, index, index, index, index, index) -> ()
    "cf.br"()[^bb7] : () -> ()
  ^bb4:  // pred: ^bb0
    "func.call"(%23, %1, %5, %5) <{callee = @_ZN4dim3C1Ejjj}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    "func.call"(%21, %43) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %104 = "polygeist.memref2pointer"(%20) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %105 = "llvm.getelementptr"(%104) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %106 = "llvm.load"(%105) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %107 = "arith.index_cast"(%106) : (i32) -> index
    %108 = "llvm.getelementptr"(%104) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %109 = "llvm.load"(%108) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %110 = "arith.index_cast"(%109) : (i32) -> index
    %111 = "llvm.getelementptr"(%104) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %112 = "llvm.load"(%111) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %113 = "arith.index_cast"(%112) : (i32) -> index
    "func.call"(%19, %23) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %114 = "polygeist.memref2pointer"(%18) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %115 = "llvm.getelementptr"(%114) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %116 = "llvm.load"(%115) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %117 = "arith.index_cast"(%116) : (i32) -> index
    %118 = "llvm.getelementptr"(%114) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %119 = "llvm.load"(%118) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %120 = "arith.index_cast"(%119) : (i32) -> index
    %121 = "llvm.getelementptr"(%114) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %122 = "llvm.load"(%121) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %123 = "arith.index_cast"(%122) : (i32) -> index
    "gpu.launch"(%107, %110, %113, %117, %120, %123) <{operandSegmentSizes = array<i32: 0, 1, 1, 1, 1, 1, 1, 0>}> ({
    ^bb0(%arg5: index, %arg6: index, %arg7: index, %arg8: index, %arg9: index, %arg10: index, %arg11: index, %arg12: index, %arg13: index, %arg14: index, %arg15: index, %arg16: index):
      "func.call"(%arg0, %arg1, %arg3) <{callee = @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi}> : (memref<?xf32>, memref<?xf32>, i32) -> ()
      "gpu.terminator"() : () -> ()
    }) {workgroup_attributions = 0 : i64} : (index, index, index, index, index, index) -> ()
    "cf.br"()[^bb7] : () -> ()
  ^bb5:  // pred: ^bb0
    "func.call"(%17, %0, %5, %5) <{callee = @_ZN4dim3C1Ejjj}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    "func.call"(%15, %43) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %124 = "polygeist.memref2pointer"(%14) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %125 = "llvm.getelementptr"(%124) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %126 = "llvm.load"(%125) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %127 = "arith.index_cast"(%126) : (i32) -> index
    %128 = "llvm.getelementptr"(%124) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %129 = "llvm.load"(%128) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %130 = "arith.index_cast"(%129) : (i32) -> index
    %131 = "llvm.getelementptr"(%124) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %132 = "llvm.load"(%131) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %133 = "arith.index_cast"(%132) : (i32) -> index
    "func.call"(%13, %17) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %134 = "polygeist.memref2pointer"(%12) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %135 = "llvm.getelementptr"(%134) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %136 = "llvm.load"(%135) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %137 = "arith.index_cast"(%136) : (i32) -> index
    %138 = "llvm.getelementptr"(%134) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %139 = "llvm.load"(%138) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %140 = "arith.index_cast"(%139) : (i32) -> index
    %141 = "llvm.getelementptr"(%134) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %142 = "llvm.load"(%141) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %143 = "arith.index_cast"(%142) : (i32) -> index
    "gpu.launch"(%127, %130, %133, %137, %140, %143) <{operandSegmentSizes = array<i32: 0, 1, 1, 1, 1, 1, 1, 0>}> ({
    ^bb0(%arg5: index, %arg6: index, %arg7: index, %arg8: index, %arg9: index, %arg10: index, %arg11: index, %arg12: index, %arg13: index, %arg14: index, %arg15: index, %arg16: index):
      "func.call"(%arg0, %arg1, %arg3) <{callee = @_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi}> : (memref<?xf32>, memref<?xf32>, i32) -> ()
      "gpu.terminator"() : () -> ()
    }) {workgroup_attributions = 0 : i64} : (index, index, index, index, index, index) -> ()
    "cf.br"()[^bb7] : () -> ()
  ^bb6:  // pred: ^bb0
    "func.call"(%11, %1, %5, %5) <{callee = @_ZN4dim3C1Ejjj}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> ()
    "func.call"(%9, %43) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %144 = "polygeist.memref2pointer"(%8) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %145 = "llvm.getelementptr"(%144) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %146 = "llvm.load"(%145) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %147 = "arith.index_cast"(%146) : (i32) -> index
    %148 = "llvm.getelementptr"(%144) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %149 = "llvm.load"(%148) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %150 = "arith.index_cast"(%149) : (i32) -> index
    %151 = "llvm.getelementptr"(%144) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %152 = "llvm.load"(%151) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %153 = "arith.index_cast"(%152) : (i32) -> index
    "func.call"(%7, %11) <{callee = @_ZN4dim3C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> ()
    %154 = "polygeist.memref2pointer"(%6) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %155 = "llvm.getelementptr"(%154) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 0>}> : (!llvm.ptr) -> !llvm.ptr
    %156 = "llvm.load"(%155) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %157 = "arith.index_cast"(%156) : (i32) -> index
    %158 = "llvm.getelementptr"(%154) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %159 = "llvm.load"(%158) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %160 = "arith.index_cast"(%159) : (i32) -> index
    %161 = "llvm.getelementptr"(%154) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %162 = "llvm.load"(%161) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %163 = "arith.index_cast"(%162) : (i32) -> index
    "gpu.launch"(%147, %150, %153, %157, %160, %163) <{operandSegmentSizes = array<i32: 0, 1, 1, 1, 1, 1, 1, 0>}> ({
    ^bb0(%arg5: index, %arg6: index, %arg7: index, %arg8: index, %arg9: index, %arg10: index, %arg11: index, %arg12: index, %arg13: index, %arg14: index, %arg15: index, %arg16: index):
      "func.call"(%arg0, %arg1, %arg3) <{callee = @_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi}> : (memref<?xf32>, memref<?xf32>, i32) -> ()
      "gpu.terminator"() : () -> ()
    }) {workgroup_attributions = 0 : i64} : (index, index, index, index, index, index) -> ()
    "cf.br"()[^bb7] : () -> ()
  ^bb7:  // 6 preds: ^bb1, ^bb2, ^bb3, ^bb4, ^bb5, ^bb6
    "func.return"() : () -> ()
  }) {llvm.linkage = #llvm.linkage<external>} : () -> ()
  "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, i32, i32, i32) -> (), sym_name = "_ZN4dim3C1Ejjj", sym_visibility = "private"}> ({
  ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: i32, %arg2: i32, %arg3: i32):
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    "llvm.store"(%arg1, %0) <{ordering = 0 : i64}> : (i32, !llvm.ptr) -> ()
    %1 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    "llvm.store"(%arg2, %1) <{ordering = 0 : i64}> : (i32, !llvm.ptr) -> ()
    %2 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    "llvm.store"(%arg3, %2) <{ordering = 0 : i64}> : (i32, !llvm.ptr) -> ()
    "func.return"() : () -> ()
  }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
  "func.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32) -> (), sym_name = "_Z38__device_stub__softmax_kernel_templateILi32EEvPKfPfi", sym_visibility = "private"}> ({
  ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32):
    "func.call"(%arg0, %arg1, %arg2) <{callee = @_Z23softmax_kernel_templateILi32EEvPKfPfi}> : (memref<?xf32>, memref<?xf32>, i32) -> ()
    "func.return"() : () -> ()
  }) {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} : () -> ()
  "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> (), sym_name = "_ZN4dim3C1ERKS_", sym_visibility = "private"}> ({
  ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>):
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>>) -> !llvm.ptr
    "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (i32, !llvm.ptr) -> ()
    %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
    "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (i32, !llvm.ptr) -> ()
    %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> i32
    %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.dim3", (i32, i32, i32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
    "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (i32, !llvm.ptr) -> ()
    "func.return"() : () -> ()
  }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
  "func.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32) -> (), sym_name = "_Z38__device_stub__softmax_kernel_templateILi64EEvPKfPfi", sym_visibility = "private"}> ({
  ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32):
    "func.call"(%arg0, %arg1, %arg2) <{callee = @_Z23softmax_kernel_templateILi64EEvPKfPfi}> : (memref<?xf32>, memref<?xf32>, i32) -> ()
    "func.return"() : () -> ()
  }) {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} : () -> ()
  "func.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32) -> (), sym_name = "_Z38__device_stub__softmax_kernel_templateILi128EEvPKfPfi", sym_visibility = "private"}> ({
  ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32):
    "func.call"(%arg0, %arg1, %arg2) <{callee = @_Z23softmax_kernel_templateILi128EEvPKfPfi}> : (memref<?xf32>, memref<?xf32>, i32) -> ()
    "func.return"() : () -> ()
  }) {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} : () -> ()
  "func.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32) -> (), sym_name = "_Z38__device_stub__softmax_kernel_templateILi256EEvPKfPfi", sym_visibility = "private"}> ({
  ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32):
    "func.call"(%arg0, %arg1, %arg2) <{callee = @_Z23softmax_kernel_templateILi256EEvPKfPfi}> : (memref<?xf32>, memref<?xf32>, i32) -> ()
    "func.return"() : () -> ()
  }) {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} : () -> ()
  "func.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32) -> (), sym_name = "_Z38__device_stub__softmax_kernel_templateILi512EEvPKfPfi", sym_visibility = "private"}> ({
  ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32):
    "func.call"(%arg0, %arg1, %arg2) <{callee = @_Z23softmax_kernel_templateILi512EEvPKfPfi}> : (memref<?xf32>, memref<?xf32>, i32) -> ()
    "func.return"() : () -> ()
  }) {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32):
      %0 = "arith.constant"() <{value = 16 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 1 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %4 = "arith.constant"() <{value = 0 : index}> : () -> index
      %5 = "arith.constant"() <{value = 1 : index}> : () -> index
      %6 = "arith.constant"() <{value = 32 : index}> : () -> index
      %7 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1xf32, 5>
      %8 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %9 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %10 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %11 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %12 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
      %13 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %14 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
      %15 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %16 = "arith.index_cast"(%15) : (index) -> i32
      %17 = "arith.muli"(%16, %arg2) : (i32, i32) -> i32
      %18 = "arith.index_cast"(%17) : (i32) -> index
      %19 = "arith.index_cast"(%arg2) : (i32) -> index
      "scf.parallel"(%4, %6, %5) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %32 = "func.call"() <{callee = @__builtin_inff}> : () -> f32
        %33 = "arith.negf"(%32) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
        %34 = "scf.for"(%arg3, %19, %6, %33) ({
        ^bb0(%arg4: index, %arg5: f32):
          %35 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %36 = "memref.load"(%arg0, %35) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %37 = "arith.maxnumf"(%arg5, %36) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%37) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%34, %7, %arg3) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "scf.parallel"(%4, %6, %5) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        "memref.store"(%0, %10, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "scf.while"() ({
        "scf.parallel"(%4, %6, %5) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %33 = "memref.load"(%10, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %34 = "arith.cmpi"(%33, %1) <{predicate = 4 : i64}> : (i32, i32) -> i1
          %35 = "arith.cmpi"(%arg3, %4) <{predicate = 0 : i64}> : (index, index) -> i1
          "scf.if"(%35) ({
            "memref.store"(%34, %12) : (i1, memref<i1>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "memref.store"(%33, %11, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        %32 = "memref.load"(%12) : (memref<i1>) -> i1
        "scf.condition"(%32) : (i1) -> ()
      }, {
        "scf.parallel"(%4, %6, %5) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %32 = "arith.index_cast"(%arg3) : (index) -> i32
          %33 = "memref.load"(%11, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %34 = "arith.cmpi"(%32, %33) <{predicate = 2 : i64}> : (i32, i32) -> i1
          "scf.if"(%34) ({
            %35 = "memref.load"(%7, %arg3) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
            %36 = "arith.addi"(%32, %33) : (i32, i32) -> i32
            %37 = "arith.index_cast"(%36) : (i32) -> index
            %38 = "memref.load"(%7, %37) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
            %39 = "arith.maxnumf"(%35, %38) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "memref.store"(%39, %7, %arg3) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.parallel"(%4, %6, %5) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %32 = "memref.load"(%11, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %33 = "arith.shrsi"(%32, %2) : (i32, i32) -> i32
          "memref.store"(%33, %10, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : () -> ()
      %20 = "memref.load"(%7, %4) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
      "scf.parallel"(%4, %6, %5) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        "memref.store"(%20, %13, %arg3) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %21 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %22 = "arith.index_cast"(%21) : (index) -> i32
      %23 = "arith.muli"(%22, %arg2) : (i32, i32) -> i32
      %24 = "arith.index_cast"(%23) : (i32) -> index
      %25 = "arith.index_cast"(%arg2) : (i32) -> index
      "scf.parallel"(%4, %6, %5) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %32 = "memref.load"(%13, %arg3) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        %33 = "scf.for"(%arg3, %25, %6, %3) ({
        ^bb0(%arg4: index, %arg5: f32):
          %35 = "arith.addi"(%arg4, %24) : (index, index) -> index
          %36 = "memref.load"(%arg0, %35) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %37 = "arith.subf"(%36, %32) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %38 = "math.exp"(%37) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          "memref.store"(%38, %arg1, %35) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          %39 = "arith.addf"(%arg5, %38) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%39) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        %34 = "arith.addi"(%arg3, %6) : (index, index) -> index
        "memref.store"(%33, %7, %34) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "memref.store"(%0, %8, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "scf.while"() ({
        "scf.parallel"(%4, %6, %5) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %33 = "memref.load"(%8, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %34 = "arith.cmpi"(%33, %1) <{predicate = 4 : i64}> : (i32, i32) -> i1
          %35 = "arith.cmpi"(%arg3, %4) <{predicate = 0 : i64}> : (index, index) -> i1
          "scf.if"(%35) ({
            "memref.store"(%34, %14) : (i1, memref<i1>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "memref.store"(%33, %9, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        %32 = "memref.load"(%14) : (memref<i1>) -> i1
        "scf.condition"(%32) : (i1) -> ()
      }, {
        "scf.parallel"(%4, %6, %5) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %32 = "arith.addi"(%arg3, %6) : (index, index) -> index
          %33 = "arith.index_cast"(%arg3) : (index) -> i32
          %34 = "memref.load"(%9, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %35 = "arith.cmpi"(%33, %34) <{predicate = 2 : i64}> : (i32, i32) -> i1
          "scf.if"(%35) ({
            %36 = "arith.addi"(%33, %34) : (i32, i32) -> i32
            %37 = "arith.index_cast"(%36) : (i32) -> index
            %38 = "arith.addi"(%37, %6) : (index, index) -> index
            %39 = "memref.load"(%7, %38) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
            %40 = "memref.load"(%7, %32) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
            %41 = "arith.addf"(%40, %39) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "memref.store"(%41, %7, %32) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.parallel"(%4, %6, %5) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %32 = "memref.load"(%9, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %33 = "arith.shrsi"(%32, %2) : (i32, i32) -> i32
          "memref.store"(%33, %8, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : () -> ()
      %26 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %27 = "arith.index_cast"(%26) : (index) -> i32
      %28 = "arith.muli"(%27, %arg2) : (i32, i32) -> i32
      %29 = "arith.index_cast"(%28) : (i32) -> index
      %30 = "arith.index_cast"(%arg2) : (i32) -> index
      %31 = "arith.cmpi"(%4, %6) <{predicate = 2 : i64}> : (index, index) -> i1
      "scf.if"(%31) ({
        %32 = "memref.load"(%7, %6) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
        "scf.parallel"(%4, %6, %5) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          "scf.for"(%arg3, %30, %6) ({
          ^bb0(%arg4: index):
            %33 = "arith.addi"(%arg4, %29) : (index, index) -> index
            %34 = "memref.load"(%arg1, %33) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
            %35 = "arith.divf"(%34, %32) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "memref.store"(%35, %arg1, %33) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
            "scf.yield"() : () -> ()
          }) : (index, index, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }, {
      }) : (i1) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z23softmax_kernel_templateILi32EEvPKfPfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = () -> f32, sym_name = "__builtin_inff", sym_visibility = "private"}> ({
    }) {llvm.linkage = #llvm.linkage<external>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z23softmax_kernel_templateILi32EEvPKfPfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32):
      %0 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 1 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %4 = "arith.constant"() <{value = 64 : index}> : () -> index
      %5 = "arith.constant"() <{value = 0 : index}> : () -> index
      %6 = "arith.constant"() <{value = 1 : index}> : () -> index
      %7 = "arith.constant"() <{value = 32 : index}> : () -> index
      %8 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %9 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %10 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %11 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %12 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
      %13 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %14 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
      %15 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %16 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %17 = "arith.index_cast"(%16) : (index) -> i32
      %18 = "arith.muli"(%17, %arg2) : (i32, i32) -> i32
      %19 = "arith.index_cast"(%18) : (i32) -> index
      %20 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %21 = "arith.index_cast"(%arg2) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "func.call"() <{callee = @__builtin_inff}> : () -> f32
        %40 = "arith.negf"(%39) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
        %41 = "scf.for"(%arg3, %21, %4, %40) ({
        ^bb0(%arg4: index, %arg5: f32):
          %42 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %43 = "memref.load"(%arg0, %42) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %44 = "arith.maxnumf"(%arg5, %43) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%44) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%41, %20, %arg3) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        "memref.store"(%0, %10, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %22 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      "scf.while"() ({
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %40 = "memref.load"(%10, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%40, %1) <{predicate = 4 : i64}> : (i32, i32) -> i1
          %42 = "arith.cmpi"(%arg3, %5) <{predicate = 0 : i64}> : (index, index) -> i1
          "scf.if"(%42) ({
            "memref.store"(%41, %12) : (i1, memref<i1>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "memref.store"(%40, %11, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        %39 = "memref.load"(%12) : (memref<i1>) -> i1
        "scf.condition"(%39) : (i1) -> ()
      }, {
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "arith.index_cast"(%arg3) : (index) -> i32
          %40 = "memref.load"(%11, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%39, %40) <{predicate = 2 : i64}> : (i32, i32) -> i1
          "scf.if"(%41) ({
            %42 = "memref.load"(%22, %arg3) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %43 = "arith.addi"(%39, %40) : (i32, i32) -> i32
            %44 = "arith.index_cast"(%43) : (i32) -> index
            %45 = "memref.load"(%22, %44) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %46 = "arith.maxnumf"(%42, %45) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "memref.store"(%46, %22, %arg3) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "memref.load"(%11, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %40 = "arith.shrsi"(%39, %2) : (i32, i32) -> i32
          "memref.store"(%40, %10, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : () -> ()
      %23 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %24 = "arith.cmpi"(%5, %7) <{predicate = 2 : i64}> : (index, index) -> i1
      "scf.if"(%24) ({
        %39 = "memref.load"(%23, %5) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          "memref.store"(%39, %13, %arg3) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }, {
      }) : (i1) -> ()
      %25 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %26 = "arith.index_cast"(%25) : (index) -> i32
      %27 = "arith.muli"(%26, %arg2) : (i32, i32) -> i32
      %28 = "arith.index_cast"(%27) : (i32) -> index
      %29 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %30 = "arith.index_cast"(%arg2) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "memref.load"(%13, %arg3) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        %40 = "scf.for"(%arg3, %30, %4, %3) ({
        ^bb0(%arg4: index, %arg5: f32):
          %42 = "arith.addi"(%arg4, %28) : (index, index) -> index
          %43 = "memref.load"(%arg0, %42) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %44 = "arith.subf"(%43, %39) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %45 = "math.exp"(%44) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          "memref.store"(%45, %arg1, %42) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          %46 = "arith.addf"(%arg5, %45) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%46) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        %41 = "arith.addi"(%arg3, %4) : (index, index) -> index
        "memref.store"(%40, %29, %41) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "memref.store"(%0, %8, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %31 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      "scf.while"() ({
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %40 = "memref.load"(%8, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%40, %1) <{predicate = 4 : i64}> : (i32, i32) -> i1
          %42 = "arith.cmpi"(%arg3, %5) <{predicate = 0 : i64}> : (index, index) -> i1
          "scf.if"(%42) ({
            "memref.store"(%41, %14) : (i1, memref<i1>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "memref.store"(%40, %9, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        %39 = "memref.load"(%14) : (memref<i1>) -> i1
        "scf.condition"(%39) : (i1) -> ()
      }, {
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "arith.addi"(%arg3, %4) : (index, index) -> index
          %40 = "arith.index_cast"(%arg3) : (index) -> i32
          %41 = "memref.load"(%9, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %42 = "arith.cmpi"(%40, %41) <{predicate = 2 : i64}> : (i32, i32) -> i1
          "scf.if"(%42) ({
            %43 = "arith.addi"(%40, %41) : (i32, i32) -> i32
            %44 = "arith.index_cast"(%43) : (i32) -> index
            %45 = "arith.addi"(%44, %4) : (index, index) -> index
            %46 = "memref.load"(%31, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %47 = "memref.load"(%31, %39) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "memref.store"(%48, %31, %39) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "memref.load"(%9, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %40 = "arith.shrsi"(%39, %2) : (i32, i32) -> i32
          "memref.store"(%40, %8, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : () -> ()
      %32 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %33 = "arith.cmpi"(%5, %7) <{predicate = 2 : i64}> : (index, index) -> i1
      "scf.if"(%33) ({
        %39 = "memref.load"(%32, %4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          "memref.store"(%39, %15, %arg3) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }, {
      }) : (i1) -> ()
      %34 = "arith.index_cast"(%arg2) : (i32) -> index
      %35 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %36 = "arith.index_cast"(%35) : (index) -> i32
      %37 = "arith.muli"(%36, %arg2) : (i32, i32) -> i32
      %38 = "arith.index_cast"(%37) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "memref.load"(%15, %arg3) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        "scf.for"(%arg3, %34, %4) ({
        ^bb0(%arg4: index):
          %40 = "arith.addi"(%arg4, %38) : (index, index) -> index
          %41 = "memref.load"(%arg1, %40) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %42 = "arith.divf"(%41, %39) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%42, %arg1, %40) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z23softmax_kernel_templateILi64EEvPKfPfi", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "shared_mem", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = () -> f32, sym_name = "__builtin_inff", sym_visibility = "private"}> ({
    }) {llvm.linkage = #llvm.linkage<external>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z23softmax_kernel_templateILi64EEvPKfPfi_1"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32):
      %0 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 1 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %4 = "arith.constant"() <{value = 128 : index}> : () -> index
      %5 = "arith.constant"() <{value = 0 : index}> : () -> index
      %6 = "arith.constant"() <{value = 1 : index}> : () -> index
      %7 = "arith.constant"() <{value = 32 : index}> : () -> index
      %8 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %9 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %10 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %11 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %12 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
      %13 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %14 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
      %15 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %16 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %17 = "arith.index_cast"(%16) : (index) -> i32
      %18 = "arith.muli"(%17, %arg2) : (i32, i32) -> i32
      %19 = "arith.index_cast"(%18) : (i32) -> index
      %20 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %21 = "arith.index_cast"(%arg2) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "func.call"() <{callee = @__builtin_inff}> : () -> f32
        %40 = "arith.negf"(%39) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
        %41 = "scf.for"(%arg3, %21, %4, %40) ({
        ^bb0(%arg4: index, %arg5: f32):
          %42 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %43 = "memref.load"(%arg0, %42) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %44 = "arith.maxnumf"(%arg5, %43) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%44) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%41, %20, %arg3) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        "memref.store"(%0, %10, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %22 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      "scf.while"() ({
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %40 = "memref.load"(%10, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%40, %1) <{predicate = 4 : i64}> : (i32, i32) -> i1
          %42 = "arith.cmpi"(%arg3, %5) <{predicate = 0 : i64}> : (index, index) -> i1
          "scf.if"(%42) ({
            "memref.store"(%41, %12) : (i1, memref<i1>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "memref.store"(%40, %11, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        %39 = "memref.load"(%12) : (memref<i1>) -> i1
        "scf.condition"(%39) : (i1) -> ()
      }, {
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "arith.index_cast"(%arg3) : (index) -> i32
          %40 = "memref.load"(%11, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%39, %40) <{predicate = 2 : i64}> : (i32, i32) -> i1
          "scf.if"(%41) ({
            %42 = "memref.load"(%22, %arg3) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %43 = "arith.addi"(%39, %40) : (i32, i32) -> i32
            %44 = "arith.index_cast"(%43) : (i32) -> index
            %45 = "memref.load"(%22, %44) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %46 = "arith.maxnumf"(%42, %45) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "memref.store"(%46, %22, %arg3) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "memref.load"(%11, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %40 = "arith.shrsi"(%39, %2) : (i32, i32) -> i32
          "memref.store"(%40, %10, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : () -> ()
      %23 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %24 = "arith.cmpi"(%5, %7) <{predicate = 2 : i64}> : (index, index) -> i1
      "scf.if"(%24) ({
        %39 = "memref.load"(%23, %5) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          "memref.store"(%39, %13, %arg3) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }, {
      }) : (i1) -> ()
      %25 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %26 = "arith.index_cast"(%25) : (index) -> i32
      %27 = "arith.muli"(%26, %arg2) : (i32, i32) -> i32
      %28 = "arith.index_cast"(%27) : (i32) -> index
      %29 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %30 = "arith.index_cast"(%arg2) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "memref.load"(%13, %arg3) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        %40 = "scf.for"(%arg3, %30, %4, %3) ({
        ^bb0(%arg4: index, %arg5: f32):
          %42 = "arith.addi"(%arg4, %28) : (index, index) -> index
          %43 = "memref.load"(%arg0, %42) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %44 = "arith.subf"(%43, %39) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %45 = "math.exp"(%44) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          "memref.store"(%45, %arg1, %42) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          %46 = "arith.addf"(%arg5, %45) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%46) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        %41 = "arith.addi"(%arg3, %4) : (index, index) -> index
        "memref.store"(%40, %29, %41) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "memref.store"(%0, %8, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %31 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      "scf.while"() ({
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %40 = "memref.load"(%8, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%40, %1) <{predicate = 4 : i64}> : (i32, i32) -> i1
          %42 = "arith.cmpi"(%arg3, %5) <{predicate = 0 : i64}> : (index, index) -> i1
          "scf.if"(%42) ({
            "memref.store"(%41, %14) : (i1, memref<i1>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "memref.store"(%40, %9, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        %39 = "memref.load"(%14) : (memref<i1>) -> i1
        "scf.condition"(%39) : (i1) -> ()
      }, {
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "arith.addi"(%arg3, %4) : (index, index) -> index
          %40 = "arith.index_cast"(%arg3) : (index) -> i32
          %41 = "memref.load"(%9, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %42 = "arith.cmpi"(%40, %41) <{predicate = 2 : i64}> : (i32, i32) -> i1
          "scf.if"(%42) ({
            %43 = "arith.addi"(%40, %41) : (i32, i32) -> i32
            %44 = "arith.index_cast"(%43) : (i32) -> index
            %45 = "arith.addi"(%44, %4) : (index, index) -> index
            %46 = "memref.load"(%31, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %47 = "memref.load"(%31, %39) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "memref.store"(%48, %31, %39) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "memref.load"(%9, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %40 = "arith.shrsi"(%39, %2) : (i32, i32) -> i32
          "memref.store"(%40, %8, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : () -> ()
      %32 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %33 = "arith.cmpi"(%5, %7) <{predicate = 2 : i64}> : (index, index) -> i1
      "scf.if"(%33) ({
        %39 = "memref.load"(%32, %4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          "memref.store"(%39, %15, %arg3) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }, {
      }) : (i1) -> ()
      %34 = "arith.index_cast"(%arg2) : (i32) -> index
      %35 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %36 = "arith.index_cast"(%35) : (index) -> i32
      %37 = "arith.muli"(%36, %arg2) : (i32, i32) -> i32
      %38 = "arith.index_cast"(%37) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "memref.load"(%15, %arg3) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        "scf.for"(%arg3, %34, %4) ({
        ^bb0(%arg4: index):
          %40 = "arith.addi"(%arg4, %38) : (index, index) -> index
          %41 = "memref.load"(%arg1, %40) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %42 = "arith.divf"(%41, %39) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%42, %arg1, %40) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z23softmax_kernel_templateILi128EEvPKfPfi", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "shared_mem", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = () -> f32, sym_name = "__builtin_inff", sym_visibility = "private"}> ({
    }) {llvm.linkage = #llvm.linkage<external>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z23softmax_kernel_templateILi128EEvPKfPfi_2"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32):
      %0 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 1 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %4 = "arith.constant"() <{value = 256 : index}> : () -> index
      %5 = "arith.constant"() <{value = 0 : index}> : () -> index
      %6 = "arith.constant"() <{value = 1 : index}> : () -> index
      %7 = "arith.constant"() <{value = 32 : index}> : () -> index
      %8 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %9 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %10 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %11 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %12 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
      %13 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %14 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
      %15 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %16 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %17 = "arith.index_cast"(%16) : (index) -> i32
      %18 = "arith.muli"(%17, %arg2) : (i32, i32) -> i32
      %19 = "arith.index_cast"(%18) : (i32) -> index
      %20 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %21 = "arith.index_cast"(%arg2) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "func.call"() <{callee = @__builtin_inff}> : () -> f32
        %40 = "arith.negf"(%39) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
        %41 = "scf.for"(%arg3, %21, %4, %40) ({
        ^bb0(%arg4: index, %arg5: f32):
          %42 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %43 = "memref.load"(%arg0, %42) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %44 = "arith.maxnumf"(%arg5, %43) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%44) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%41, %20, %arg3) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        "memref.store"(%0, %10, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %22 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      "scf.while"() ({
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %40 = "memref.load"(%10, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%40, %1) <{predicate = 4 : i64}> : (i32, i32) -> i1
          %42 = "arith.cmpi"(%arg3, %5) <{predicate = 0 : i64}> : (index, index) -> i1
          "scf.if"(%42) ({
            "memref.store"(%41, %12) : (i1, memref<i1>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "memref.store"(%40, %11, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        %39 = "memref.load"(%12) : (memref<i1>) -> i1
        "scf.condition"(%39) : (i1) -> ()
      }, {
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "arith.index_cast"(%arg3) : (index) -> i32
          %40 = "memref.load"(%11, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%39, %40) <{predicate = 2 : i64}> : (i32, i32) -> i1
          "scf.if"(%41) ({
            %42 = "memref.load"(%22, %arg3) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %43 = "arith.addi"(%39, %40) : (i32, i32) -> i32
            %44 = "arith.index_cast"(%43) : (i32) -> index
            %45 = "memref.load"(%22, %44) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %46 = "arith.maxnumf"(%42, %45) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "memref.store"(%46, %22, %arg3) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "memref.load"(%11, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %40 = "arith.shrsi"(%39, %2) : (i32, i32) -> i32
          "memref.store"(%40, %10, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : () -> ()
      %23 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %24 = "arith.cmpi"(%5, %7) <{predicate = 2 : i64}> : (index, index) -> i1
      "scf.if"(%24) ({
        %39 = "memref.load"(%23, %5) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          "memref.store"(%39, %13, %arg3) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }, {
      }) : (i1) -> ()
      %25 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %26 = "arith.index_cast"(%25) : (index) -> i32
      %27 = "arith.muli"(%26, %arg2) : (i32, i32) -> i32
      %28 = "arith.index_cast"(%27) : (i32) -> index
      %29 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %30 = "arith.index_cast"(%arg2) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "memref.load"(%13, %arg3) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        %40 = "scf.for"(%arg3, %30, %4, %3) ({
        ^bb0(%arg4: index, %arg5: f32):
          %42 = "arith.addi"(%arg4, %28) : (index, index) -> index
          %43 = "memref.load"(%arg0, %42) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %44 = "arith.subf"(%43, %39) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %45 = "math.exp"(%44) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          "memref.store"(%45, %arg1, %42) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          %46 = "arith.addf"(%arg5, %45) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%46) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        %41 = "arith.addi"(%arg3, %4) : (index, index) -> index
        "memref.store"(%40, %29, %41) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "memref.store"(%0, %8, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %31 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      "scf.while"() ({
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %40 = "memref.load"(%8, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%40, %1) <{predicate = 4 : i64}> : (i32, i32) -> i1
          %42 = "arith.cmpi"(%arg3, %5) <{predicate = 0 : i64}> : (index, index) -> i1
          "scf.if"(%42) ({
            "memref.store"(%41, %14) : (i1, memref<i1>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "memref.store"(%40, %9, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        %39 = "memref.load"(%14) : (memref<i1>) -> i1
        "scf.condition"(%39) : (i1) -> ()
      }, {
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "arith.addi"(%arg3, %4) : (index, index) -> index
          %40 = "arith.index_cast"(%arg3) : (index) -> i32
          %41 = "memref.load"(%9, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %42 = "arith.cmpi"(%40, %41) <{predicate = 2 : i64}> : (i32, i32) -> i1
          "scf.if"(%42) ({
            %43 = "arith.addi"(%40, %41) : (i32, i32) -> i32
            %44 = "arith.index_cast"(%43) : (i32) -> index
            %45 = "arith.addi"(%44, %4) : (index, index) -> index
            %46 = "memref.load"(%31, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %47 = "memref.load"(%31, %39) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "memref.store"(%48, %31, %39) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "memref.load"(%9, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %40 = "arith.shrsi"(%39, %2) : (i32, i32) -> i32
          "memref.store"(%40, %8, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : () -> ()
      %32 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %33 = "arith.cmpi"(%5, %7) <{predicate = 2 : i64}> : (index, index) -> i1
      "scf.if"(%33) ({
        %39 = "memref.load"(%32, %4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          "memref.store"(%39, %15, %arg3) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }, {
      }) : (i1) -> ()
      %34 = "arith.index_cast"(%arg2) : (i32) -> index
      %35 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %36 = "arith.index_cast"(%35) : (index) -> i32
      %37 = "arith.muli"(%36, %arg2) : (i32, i32) -> i32
      %38 = "arith.index_cast"(%37) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "memref.load"(%15, %arg3) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        "scf.for"(%arg3, %34, %4) ({
        ^bb0(%arg4: index):
          %40 = "arith.addi"(%arg4, %38) : (index, index) -> index
          %41 = "memref.load"(%arg1, %40) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %42 = "arith.divf"(%41, %39) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%42, %arg1, %40) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z23softmax_kernel_templateILi256EEvPKfPfi", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "shared_mem", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = () -> f32, sym_name = "__builtin_inff", sym_visibility = "private"}> ({
    }) {llvm.linkage = #llvm.linkage<external>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z23softmax_kernel_templateILi256EEvPKfPfi_3"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32):
      %0 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 1 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %4 = "arith.constant"() <{value = 512 : index}> : () -> index
      %5 = "arith.constant"() <{value = 0 : index}> : () -> index
      %6 = "arith.constant"() <{value = 1 : index}> : () -> index
      %7 = "arith.constant"() <{value = 32 : index}> : () -> index
      %8 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %9 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %10 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %11 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xi32>
      %12 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
      %13 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %14 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<i1>
      %15 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %16 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %17 = "arith.index_cast"(%16) : (index) -> i32
      %18 = "arith.muli"(%17, %arg2) : (i32, i32) -> i32
      %19 = "arith.index_cast"(%18) : (i32) -> index
      %20 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %21 = "arith.index_cast"(%arg2) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "func.call"() <{callee = @__builtin_inff}> : () -> f32
        %40 = "arith.negf"(%39) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
        %41 = "scf.for"(%arg3, %21, %4, %40) ({
        ^bb0(%arg4: index, %arg5: f32):
          %42 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %43 = "memref.load"(%arg0, %42) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %44 = "arith.maxnumf"(%arg5, %43) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%44) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%41, %20, %arg3) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        "memref.store"(%0, %10, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %22 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      "scf.while"() ({
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %40 = "memref.load"(%10, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%40, %1) <{predicate = 4 : i64}> : (i32, i32) -> i1
          %42 = "arith.cmpi"(%arg3, %5) <{predicate = 0 : i64}> : (index, index) -> i1
          "scf.if"(%42) ({
            "memref.store"(%41, %12) : (i1, memref<i1>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "memref.store"(%40, %11, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        %39 = "memref.load"(%12) : (memref<i1>) -> i1
        "scf.condition"(%39) : (i1) -> ()
      }, {
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "arith.index_cast"(%arg3) : (index) -> i32
          %40 = "memref.load"(%11, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%39, %40) <{predicate = 2 : i64}> : (i32, i32) -> i1
          "scf.if"(%41) ({
            %42 = "memref.load"(%22, %arg3) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %43 = "arith.addi"(%39, %40) : (i32, i32) -> i32
            %44 = "arith.index_cast"(%43) : (i32) -> index
            %45 = "memref.load"(%22, %44) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %46 = "arith.maxnumf"(%42, %45) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "memref.store"(%46, %22, %arg3) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "memref.load"(%11, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %40 = "arith.shrsi"(%39, %2) : (i32, i32) -> i32
          "memref.store"(%40, %10, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : () -> ()
      %23 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %24 = "arith.cmpi"(%5, %7) <{predicate = 2 : i64}> : (index, index) -> i1
      "scf.if"(%24) ({
        %39 = "memref.load"(%23, %5) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          "memref.store"(%39, %13, %arg3) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }, {
      }) : (i1) -> ()
      %25 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %26 = "arith.index_cast"(%25) : (index) -> i32
      %27 = "arith.muli"(%26, %arg2) : (i32, i32) -> i32
      %28 = "arith.index_cast"(%27) : (i32) -> index
      %29 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %30 = "arith.index_cast"(%arg2) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "memref.load"(%13, %arg3) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        %40 = "scf.for"(%arg3, %30, %4, %3) ({
        ^bb0(%arg4: index, %arg5: f32):
          %42 = "arith.addi"(%arg4, %28) : (index, index) -> index
          %43 = "memref.load"(%arg0, %42) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %44 = "arith.subf"(%43, %39) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %45 = "math.exp"(%44) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          "memref.store"(%45, %arg1, %42) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          %46 = "arith.addf"(%arg5, %45) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%46) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        %41 = "arith.addi"(%arg3, %4) : (index, index) -> index
        "memref.store"(%40, %29, %41) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "memref.store"(%0, %8, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %31 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      "scf.while"() ({
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %40 = "memref.load"(%8, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %41 = "arith.cmpi"(%40, %1) <{predicate = 4 : i64}> : (i32, i32) -> i1
          %42 = "arith.cmpi"(%arg3, %5) <{predicate = 0 : i64}> : (index, index) -> i1
          "scf.if"(%42) ({
            "memref.store"(%41, %14) : (i1, memref<i1>) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "memref.store"(%40, %9, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        %39 = "memref.load"(%14) : (memref<i1>) -> i1
        "scf.condition"(%39) : (i1) -> ()
      }, {
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "arith.addi"(%arg3, %4) : (index, index) -> index
          %40 = "arith.index_cast"(%arg3) : (index) -> i32
          %41 = "memref.load"(%9, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %42 = "arith.cmpi"(%40, %41) <{predicate = 2 : i64}> : (i32, i32) -> i1
          "scf.if"(%42) ({
            %43 = "arith.addi"(%40, %41) : (i32, i32) -> i32
            %44 = "arith.index_cast"(%43) : (i32) -> index
            %45 = "arith.addi"(%44, %4) : (index, index) -> index
            %46 = "memref.load"(%31, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %47 = "memref.load"(%31, %39) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
            %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "memref.store"(%48, %31, %39) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
            "scf.yield"() : () -> ()
          }, {
          }) : (i1) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          %39 = "memref.load"(%9, %arg3) <{nontemporal = false}> : (memref<32xi32>, index) -> i32
          %40 = "arith.shrsi"(%39, %2) : (i32, i32) -> i32
          "memref.store"(%40, %8, %arg3) <{nontemporal = false}> : (i32, memref<32xi32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : () -> ()
      %32 = "memref.get_global"() <{name = @shared_mem}> : () -> memref<1xf32>
      %33 = "arith.cmpi"(%5, %7) <{predicate = 2 : i64}> : (index, index) -> i1
      "scf.if"(%33) ({
        %39 = "memref.load"(%32, %4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
        "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
        ^bb0(%arg3: index):
          "memref.store"(%39, %15, %arg3) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }, {
      }) : (i1) -> ()
      %34 = "arith.index_cast"(%arg2) : (i32) -> index
      %35 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %36 = "arith.index_cast"(%35) : (index) -> i32
      %37 = "arith.muli"(%36, %arg2) : (i32, i32) -> i32
      %38 = "arith.index_cast"(%37) : (i32) -> index
      "scf.parallel"(%5, %7, %6) <{operandSegmentSizes = array<i32: 1, 1, 1, 0>}> ({
      ^bb0(%arg3: index):
        %39 = "memref.load"(%15, %arg3) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        "scf.for"(%arg3, %34, %4) ({
        ^bb0(%arg4: index):
          %40 = "arith.addi"(%arg4, %38) : (index, index) -> index
          %41 = "memref.load"(%arg1, %40) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %42 = "arith.divf"(%41, %39) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%42, %arg1, %40) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z23softmax_kernel_templateILi512EEvPKfPfi", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "shared_mem", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = () -> f32, sym_name = "__builtin_inff", sym_visibility = "private"}> ({
    }) {llvm.linkage = #llvm.linkage<external>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z23softmax_kernel_templateILi512EEvPKfPfi_4"} : () -> ()
  "func.func"() <{function_type = () -> f32, sym_name = "__builtin_inff", sym_visibility = "private"}> ({
  }) {llvm.linkage = #llvm.linkage<external>} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
