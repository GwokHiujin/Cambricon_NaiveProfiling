warning: CUDA version 12.1 is only partially supported
warning: CUDA version 12.1 is only partially supported
[ict-debug] driver.cc: After return 5, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z33__device_stub__conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    call @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11, %arg12, %arg13, %arg14, %arg15, %arg16, %arg17, %arg18, %arg19) : (memref<?xf32>, memref<?xf32>, memref<?xf32>, memref<?xf32>, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32) -> ()
    return
  }
  func.func private @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %cst = arith.constant 0.000000e+00 : f32
    %c0_i32 = arith.constant 0 : i32
    %c4_i32 = arith.constant 4 : i32
    %c1_i32 = arith.constant 1 : i32
    %0 = arith.index_cast %arg7 : i32 to index
    %1 = arith.index_cast %arg18 : i32 to index
    %2 = arith.index_cast %arg16 : i32 to index
    %3 = arith.index_cast %arg6 : i32 to index
    %4 = arith.index_cast %arg17 : i32 to index
    %5 = arith.index_cast %arg15 : i32 to index
    %6 = arith.index_cast %arg19 : i32 to index
    %7 = arith.index_cast %arg5 : i32 to index
    %8 = arith.divsi %arg5, %arg19 : i32
    %9 = arith.divsi %arg8, %arg19 : i32
    %10 = arith.index_cast %arg11 : i32 to index
    %11 = arith.index_cast %arg12 : i32 to index
    %12 = arith.index_cast %arg10 : i32 to index
    %13 = llvm.mlir.undef : i32
    %14 = gpu.block_id  x
    %15 = arith.index_cast %14 : index to i32
    %16 = gpu.block_dim  x
    %17 = arith.index_cast %16 : index to i32
    %18 = arith.muli %15, %17 : i32
    %19 = gpu.thread_id  x
    %20 = arith.index_cast %19 : index to i32
    %21 = arith.addi %18, %20 : i32
    %22 = arith.remsi %21, %arg10 : i32
    %23 = arith.muli %22, %arg14 : i32
    %24 = arith.index_cast %23 : i32 to index
    %25 = arith.index_cast %21 : i32 to index
    %26 = arith.divsi %21, %arg10 : i32
    %27 = arith.remsi %26, %arg9 : i32
    %28 = arith.muli %27, %arg13 : i32
    %29 = arith.index_cast %28 : i32 to index
    %30 = arith.divsi %26, %arg9 : i32
    %31 = arith.remsi %30, %arg8 : i32
    %32 = arith.divsi %31, %9 : i32
    %33 = arith.muli %32, %8 : i32
    %34 = arith.index_cast %33 : i32 to index
    %35 = arith.index_cast %33 : i32 to index
    %36 = arith.index_cast %31 : i32 to index
    %37 = arith.divsi %30, %arg8 : i32
    %38 = arith.muli %37, %arg8 : i32
    %39 = arith.addi %38, %31 : i32
    %40 = arith.muli %39, %arg9 : i32
    %41 = arith.addi %40, %27 : i32
    %42 = arith.muli %41, %arg10 : i32
    %43 = arith.index_cast %42 : i32 to index
    %44 = arith.muli %arg4, %arg8 : i32
    %45 = arith.muli %44, %arg9 : i32
    %46 = arith.muli %45, %arg10 : i32
    %47 = arith.cmpi slt, %21, %46 : i32
    scf.if %47 {
      %48 = llvm.mlir.zero : !llvm.ptr
      %49 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %50 = llvm.icmp "ne" %49, %48 : !llvm.ptr
      %51 = scf.if %50 -> (f32) {
        %64 = affine.load %arg2[symbol(%36)] : memref<?xf32>
        scf.yield %64 : f32
      } else {
        scf.yield %cst : f32
      }
      %52 = arith.divsi %arg5, %arg19 : i32
      %53 = arith.addi %33, %52 : i32
      %54 = arith.index_cast %33 : i32 to index
      %55 = arith.index_cast %33 : i32 to index
      %56 = arith.subi %28, %arg15 : i32
      %57 = arith.subi %23, %arg16 : i32
      %58 = arith.muli %37, %arg5 : i32
      %59 = arith.muli %58, %arg6 : i32
      %60 = arith.divsi %arg5, %arg19 : i32
      %61 = arith.muli %31, %60 : i32
      %62 = arith.muli %61, %arg11 : i32
      %63:6 = affine.for %arg20 = %35 to affine_map<()[s0, s1, s2] -> (s0 + s1 floordiv s2)>()[%34, %7, %6] step 4 iter_args(%arg21 = %13, %arg22 = %13, %arg23 = %13, %arg24 = %13, %arg25 = %13, %arg26 = %51) -> (i32, i32, i32, i32, i32, f32) {
        %64 = arith.subi %arg20, %54 : index
        %65 = arith.addi %55, %64 : index
        %66 = arith.index_cast %65 : index to i32
        %67:6 = affine.for %arg27 = 0 to %10 iter_args(%arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26) -> (i32, i32, i32, i32, i32, f32) {
          %68 = arith.index_cast %arg27 : index to i32
          %69 = arith.muli %68, %arg17 : i32
          %70 = arith.addi %56, %69 : i32
          %71 = arith.addi %59, %70 : i32
          %72 = arith.muli %71, %arg7 : i32
          %73 = arith.addi %62, %68 : i32
          %74 = arith.muli %73, %arg12 : i32
          %75:6 = affine.for %arg34 = 0 to %11 iter_args(%arg35 = %arg28, %arg36 = %arg29, %arg37 = %arg30, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33) -> (i32, i32, i32, i32, i32, f32) {
            %76 = arith.index_cast %arg34 : index to i32
            %77 = arith.muli %76, %arg18 : i32
            %78 = arith.addi %57, %77 : i32
            %79:6 = affine.if affine_set<(d0, d1)[s0, s1, s2, s3, s4, s5, s6, s7] : (d0 * s2 + s0 - s1 >= 0, -(d0 * s2) - s0 + s1 + s3 - 1 >= 0, d1 * s6 + s4 - s5 >= 0, -(d1 * s6) - s4 + s5 + s7 - 1 >= 0)>(%arg27, %arg34)[%29, %5, %4, %3, %24, %2, %1, %0] -> (i32, i32, i32, i32, i32, f32) {
              %80 = arith.addi %72, %78 : i32
              %81 = arith.addi %74, %76 : i32
              %82:4 = scf.while (%arg41 = %arg35, %arg42 = %arg36, %arg43 = %c0_i32, %arg44 = %arg40) : (i32, i32, i32, f32) -> (i32, i32, i32, f32) {
                %83 = arith.cmpi slt, %arg43, %c4_i32 : i32
                %84 = arith.addi %66, %arg43 : i32
                %85 = arith.cmpi slt, %84, %53 : i32
                %86 = arith.andi %83, %85 : i1
                scf.condition(%86) %arg41, %arg42, %arg43, %arg44 : i32, i32, i32, f32
              } do {
              ^bb0(%arg41: i32, %arg42: i32, %arg43: i32, %arg44: f32):
                %83 = arith.addi %66, %arg43 : i32
                %84 = arith.muli %83, %arg6 : i32
                %85 = arith.muli %84, %arg7 : i32
                %86 = arith.addi %80, %85 : i32
                %87 = arith.muli %arg43, %arg11 : i32
                %88 = arith.muli %87, %arg12 : i32
                %89 = arith.addi %81, %88 : i32
                %90 = arith.index_cast %86 : i32 to index
                %91 = memref.load %arg0[%90] : memref<?xf32>
                %92 = arith.index_cast %89 : i32 to index
                %93 = memref.load %arg1[%92] : memref<?xf32>
                %94 = arith.mulf %91, %93 : f32
                %95 = arith.addf %arg44, %94 : f32
                %96 = arith.addi %arg43, %c1_i32 : i32
                scf.yield %89, %86, %96, %95 : i32, i32, i32, f32
              }
              affine.yield %82#0, %82#1, %82#2, %81, %80, %82#3 : i32, i32, i32, i32, i32, f32
            } else {
              affine.yield %arg35, %arg36, %arg37, %arg38, %arg39, %arg40 : i32, i32, i32, i32, i32, f32
            }
            affine.yield %79#0, %79#1, %79#2, %79#3, %79#4, %79#5 : i32, i32, i32, i32, i32, f32
          }
          affine.yield %75#0, %75#1, %75#2, %75#3, %75#4, %75#5 : i32, i32, i32, i32, i32, f32
        }
        affine.yield %67#0, %67#1, %67#2, %67#3, %67#4, %67#5 : i32, i32, i32, i32, i32, f32
      }
      affine.store %63#5, %arg3[symbol(%43) + symbol(%25) mod symbol(%12)] : memref<?xf32>
    }
    return
  }
}
[ict-debug] driver.cc: After return 5, module: end

[ict-debug] driver.cc: After return 6, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c-1 = arith.constant -1 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c0_i32 = arith.constant 0 : i32
    %c4_i32 = arith.constant 4 : i32
    %c1_i32 = arith.constant 1 : i32
    %0 = arith.index_cast %arg7 : i32 to index
    %1 = arith.index_cast %arg18 : i32 to index
    %2 = arith.index_cast %arg16 : i32 to index
    %3 = arith.index_cast %arg6 : i32 to index
    %4 = arith.index_cast %arg17 : i32 to index
    %5 = arith.index_cast %arg15 : i32 to index
    %6 = arith.index_cast %arg19 : i32 to index
    %7 = arith.index_cast %arg5 : i32 to index
    %8 = arith.subi %c-1, %7 : index
    %9 = arith.cmpi slt, %7, %c0 : index
    %10 = arith.select %9, %8, %7 : index
    %11 = arith.divsi %10, %6 : index
    %12 = arith.subi %c-1, %11 : index
    %13 = arith.select %9, %12, %11 : index
    %14 = arith.divsi %arg5, %arg19 : i32
    %15 = arith.divsi %arg8, %arg19 : i32
    %16 = arith.index_cast %arg11 : i32 to index
    %17 = arith.index_cast %arg12 : i32 to index
    %18 = arith.index_cast %arg10 : i32 to index
    %19 = llvm.mlir.undef : i32
    %20 = gpu.block_id  x
    %21 = arith.index_cast %20 : index to i32
    %22 = gpu.block_dim  x
    %23 = arith.index_cast %22 : index to i32
    %24 = arith.muli %21, %23 : i32
    %25 = gpu.thread_id  x
    %26 = arith.index_cast %25 : index to i32
    %27 = arith.addi %24, %26 : i32
    %28 = arith.remsi %27, %arg10 : i32
    %29 = arith.muli %28, %arg14 : i32
    %30 = arith.index_cast %29 : i32 to index
    %31 = arith.index_cast %27 : i32 to index
    %32 = arith.remsi %31, %18 : index
    %33 = arith.addi %32, %18 : index
    %34 = arith.cmpi slt, %32, %c0 : index
    %35 = arith.select %34, %33, %32 : index
    %36 = arith.divsi %27, %arg10 : i32
    %37 = arith.remsi %36, %arg9 : i32
    %38 = arith.muli %37, %arg13 : i32
    %39 = arith.index_cast %38 : i32 to index
    %40 = arith.divsi %36, %arg9 : i32
    %41 = arith.remsi %40, %arg8 : i32
    %42 = arith.divsi %41, %15 : i32
    %43 = arith.muli %42, %14 : i32
    %44 = arith.index_cast %43 : i32 to index
    %45 = arith.index_cast %41 : i32 to index
    %46 = arith.divsi %40, %arg8 : i32
    %47 = arith.muli %46, %arg8 : i32
    %48 = arith.addi %47, %41 : i32
    %49 = arith.muli %48, %arg9 : i32
    %50 = arith.addi %49, %37 : i32
    %51 = arith.muli %50, %arg10 : i32
    %52 = arith.index_cast %51 : i32 to index
    %53 = arith.muli %arg4, %arg8 : i32
    %54 = arith.muli %53, %arg9 : i32
    %55 = arith.muli %54, %arg10 : i32
    %56 = arith.cmpi slt, %27, %55 : i32
    scf.if %56 {
      %57 = llvm.mlir.zero : !llvm.ptr
      %58 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %59 = llvm.icmp "ne" %58, %57 : !llvm.ptr
      %60 = scf.if %59 -> (f32) {
        %69 = affine.load %arg2[symbol(%45)] : memref<?xf32>
        scf.yield %69 : f32
      } else {
        scf.yield %cst : f32
      }
      %61 = arith.addi %43, %14 : i32
      %62 = arith.subi %38, %arg15 : i32
      %63 = arith.subi %29, %arg16 : i32
      %64 = arith.muli %46, %arg5 : i32
      %65 = arith.muli %64, %arg6 : i32
      %66 = arith.muli %41, %14 : i32
      %67 = arith.muli %66, %arg11 : i32
      %68:6 = affine.for %arg20 = %44 to affine_map<()[s0, s1] -> (s0 + s1)>()[%44, %13] step 4 iter_args(%arg21 = %19, %arg22 = %19, %arg23 = %19, %arg24 = %19, %arg25 = %19, %arg26 = %60) -> (i32, i32, i32, i32, i32, f32) {
        %69 = arith.index_cast %arg20 : index to i32
        %70:6 = affine.for %arg27 = 0 to %16 iter_args(%arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26) -> (i32, i32, i32, i32, i32, f32) {
          %71 = arith.index_cast %arg27 : index to i32
          %72 = arith.muli %71, %arg17 : i32
          %73 = arith.addi %62, %72 : i32
          %74 = arith.addi %65, %73 : i32
          %75 = arith.muli %74, %arg7 : i32
          %76 = arith.addi %67, %71 : i32
          %77 = arith.muli %76, %arg12 : i32
          %78:6 = affine.for %arg34 = 0 to %17 iter_args(%arg35 = %arg28, %arg36 = %arg29, %arg37 = %arg30, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33) -> (i32, i32, i32, i32, i32, f32) {
            %79 = arith.index_cast %arg34 : index to i32
            %80 = arith.muli %79, %arg18 : i32
            %81 = arith.addi %63, %80 : i32
            %82:6 = affine.if affine_set<(d0, d1)[s0, s1, s2, s3, s4, s5, s6, s7] : (-(d0 * s0) - s1 + s2 + s3 - 1 >= 0, d0 * s0 + s1 - s2 >= 0, d1 * s4 + s5 - s6 >= 0, -(d1 * s4) - s5 + s6 + s7 - 1 >= 0)>(%arg34, %arg27)[%1, %30, %2, %0, %4, %39, %5, %3] -> (i32, i32, i32, i32, i32, f32) {
              %83 = arith.addi %75, %81 : i32
              %84 = arith.addi %77, %79 : i32
              %85:4 = scf.while (%arg41 = %arg35, %arg42 = %arg36, %arg43 = %c0_i32, %arg44 = %arg40) : (i32, i32, i32, f32) -> (i32, i32, i32, f32) {
                %86 = arith.cmpi slt, %arg43, %c4_i32 : i32
                %87 = arith.addi %69, %arg43 : i32
                %88 = arith.cmpi slt, %87, %61 : i32
                %89 = arith.andi %86, %88 : i1
                scf.condition(%89) %arg41, %arg42, %arg43, %arg44 : i32, i32, i32, f32
              } do {
              ^bb0(%arg41: i32, %arg42: i32, %arg43: i32, %arg44: f32):
                %86 = arith.addi %69, %arg43 : i32
                %87 = arith.muli %86, %arg6 : i32
                %88 = arith.muli %87, %arg7 : i32
                %89 = arith.addi %83, %88 : i32
                %90 = arith.muli %arg43, %arg11 : i32
                %91 = arith.muli %90, %arg12 : i32
                %92 = arith.addi %84, %91 : i32
                %93 = arith.index_cast %89 : i32 to index
                %94 = memref.load %arg0[%93] : memref<?xf32>
                %95 = arith.index_cast %92 : i32 to index
                %96 = memref.load %arg1[%95] : memref<?xf32>
                %97 = arith.mulf %94, %96 : f32
                %98 = arith.addf %arg44, %97 : f32
                %99 = arith.addi %arg43, %c1_i32 : i32
                scf.yield %92, %89, %99, %98 : i32, i32, i32, f32
              }
              affine.yield %85#0, %85#1, %85#2, %84, %83, %85#3 : i32, i32, i32, i32, i32, f32
            } else {
              affine.yield %arg35, %arg36, %arg37, %arg38, %arg39, %arg40 : i32, i32, i32, i32, i32, f32
            }
            affine.yield %82#0, %82#1, %82#2, %82#3, %82#4, %82#5 : i32, i32, i32, i32, i32, f32
          }
          affine.yield %78#0, %78#1, %78#2, %78#3, %78#4, %78#5 : i32, i32, i32, i32, i32, f32
        }
        affine.yield %70#0, %70#1, %70#2, %70#3, %70#4, %70#5 : i32, i32, i32, i32, i32, f32
      }
      affine.store %68#5, %arg3[symbol(%52) + symbol(%35)] : memref<?xf32>
    }
    return
  }
}
[ict-debug] driver.cc: After return 6, module: end

WrapAndReplaceBarrierPass::runOnOperation(): before execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %c4 = arith.constant 4 : index
    %c-1 = arith.constant -1 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c0_i32 = arith.constant 0 : i32
    %c4_i32 = arith.constant 4 : i32
    %c1_i32 = arith.constant 1 : i32
    %0 = arith.index_cast %arg7 : i32 to index
    %1 = arith.index_cast %arg18 : i32 to index
    %2 = arith.index_cast %arg16 : i32 to index
    %3 = arith.index_cast %arg6 : i32 to index
    %4 = arith.index_cast %arg17 : i32 to index
    %5 = arith.index_cast %arg15 : i32 to index
    %6 = arith.index_cast %arg19 : i32 to index
    %7 = arith.index_cast %arg5 : i32 to index
    %8 = arith.subi %c-1, %7 : index
    %9 = arith.cmpi slt, %7, %c0 : index
    %10 = arith.select %9, %8, %7 : index
    %11 = arith.divsi %10, %6 : index
    %12 = arith.subi %c-1, %11 : index
    %13 = arith.select %9, %12, %11 : index
    %14 = arith.divsi %arg5, %arg19 : i32
    %15 = arith.divsi %arg8, %arg19 : i32
    %16 = arith.index_cast %arg11 : i32 to index
    %17 = arith.index_cast %arg12 : i32 to index
    %18 = arith.index_cast %arg10 : i32 to index
    %19 = llvm.mlir.undef : i32
    %20 = gpu.block_id  x
    %21 = arith.index_cast %20 : index to i32
    %22 = gpu.block_dim  x
    %23 = arith.index_cast %22 : index to i32
    %24 = arith.muli %21, %23 : i32
    %25 = gpu.thread_id  x
    %26 = arith.index_cast %25 : index to i32
    %27 = arith.addi %24, %26 : i32
    %28 = arith.remsi %27, %arg10 : i32
    %29 = arith.muli %28, %arg14 : i32
    %30 = arith.index_cast %29 : i32 to index
    %31 = arith.index_cast %27 : i32 to index
    %32 = arith.remsi %31, %18 : index
    %33 = arith.addi %32, %18 : index
    %34 = arith.cmpi slt, %32, %c0 : index
    %35 = arith.select %34, %33, %32 : index
    %36 = arith.divsi %27, %arg10 : i32
    %37 = arith.remsi %36, %arg9 : i32
    %38 = arith.muli %37, %arg13 : i32
    %39 = arith.index_cast %38 : i32 to index
    %40 = arith.divsi %36, %arg9 : i32
    %41 = arith.remsi %40, %arg8 : i32
    %42 = arith.divsi %41, %15 : i32
    %43 = arith.muli %42, %14 : i32
    %44 = arith.index_cast %43 : i32 to index
    %45 = arith.index_cast %41 : i32 to index
    %46 = arith.divsi %40, %arg8 : i32
    %47 = arith.muli %46, %arg8 : i32
    %48 = arith.addi %47, %41 : i32
    %49 = arith.muli %48, %arg9 : i32
    %50 = arith.addi %49, %37 : i32
    %51 = arith.muli %50, %arg10 : i32
    %52 = arith.index_cast %51 : i32 to index
    %53 = arith.muli %arg4, %arg8 : i32
    %54 = arith.muli %53, %arg9 : i32
    %55 = arith.muli %54, %arg10 : i32
    %56 = arith.cmpi slt, %27, %55 : i32
    scf.if %56 {
      %57 = llvm.mlir.zero : !llvm.ptr
      %58 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %59 = llvm.icmp "ne" %58, %57 : !llvm.ptr
      %60 = scf.if %59 -> (f32) {
        %71 = memref.load %arg2[%45] : memref<?xf32>
        scf.yield %71 : f32
      } else {
        scf.yield %cst : f32
      }
      %61 = arith.addi %43, %14 : i32
      %62 = arith.subi %38, %arg15 : i32
      %63 = arith.subi %29, %arg16 : i32
      %64 = arith.muli %46, %arg5 : i32
      %65 = arith.muli %64, %arg6 : i32
      %66 = arith.muli %41, %14 : i32
      %67 = arith.muli %66, %arg11 : i32
      %68 = arith.addi %44, %13 : index
      %69:6 = scf.for %arg20 = %44 to %68 step %c4 iter_args(%arg21 = %19, %arg22 = %19, %arg23 = %19, %arg24 = %19, %arg25 = %19, %arg26 = %60) -> (i32, i32, i32, i32, i32, f32) {
        %71 = arith.index_cast %arg20 : index to i32
        %72:6 = scf.for %arg27 = %c0 to %16 step %c1 iter_args(%arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26) -> (i32, i32, i32, i32, i32, f32) {
          %73 = arith.index_cast %arg27 : index to i32
          %74 = arith.muli %73, %arg17 : i32
          %75 = arith.addi %62, %74 : i32
          %76 = arith.addi %65, %75 : i32
          %77 = arith.muli %76, %arg7 : i32
          %78 = arith.addi %67, %73 : i32
          %79 = arith.muli %78, %arg12 : i32
          %80:6 = scf.for %arg34 = %c0 to %17 step %c1 iter_args(%arg35 = %arg28, %arg36 = %arg29, %arg37 = %arg30, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33) -> (i32, i32, i32, i32, i32, f32) {
            %81 = arith.index_cast %arg34 : index to i32
            %82 = arith.muli %81, %arg18 : i32
            %83 = arith.addi %63, %82 : i32
            %84 = arith.muli %arg34, %1 : index
            %85 = arith.muli %84, %c-1 : index
            %86 = arith.subi %85, %30 : index
            %87 = arith.addi %86, %2 : index
            %88 = arith.addi %87, %0 : index
            %89 = arith.addi %88, %c-1 : index
            %90 = arith.cmpi sge, %89, %c0 : index
            %91 = arith.subi %30, %2 : index
            %92 = arith.addi %84, %91 : index
            %93 = arith.cmpi sge, %92, %c0 : index
            %94 = arith.andi %90, %93 : i1
            %95 = arith.muli %arg27, %4 : index
            %96 = arith.subi %39, %5 : index
            %97 = arith.addi %95, %96 : index
            %98 = arith.cmpi sge, %97, %c0 : index
            %99 = arith.andi %94, %98 : i1
            %100 = arith.muli %95, %c-1 : index
            %101 = arith.subi %100, %39 : index
            %102 = arith.addi %101, %5 : index
            %103 = arith.addi %102, %3 : index
            %104 = arith.addi %103, %c-1 : index
            %105 = arith.cmpi sge, %104, %c0 : index
            %106 = arith.andi %99, %105 : i1
            %107:6 = scf.if %106 -> (i32, i32, i32, i32, i32, f32) {
              %108 = arith.addi %77, %83 : i32
              %109 = arith.addi %79, %81 : i32
              %110:4 = scf.while (%arg41 = %arg35, %arg42 = %arg36, %arg43 = %c0_i32, %arg44 = %arg40) : (i32, i32, i32, f32) -> (i32, i32, i32, f32) {
                %111 = arith.cmpi slt, %arg43, %c4_i32 : i32
                %112 = arith.addi %71, %arg43 : i32
                %113 = arith.cmpi slt, %112, %61 : i32
                %114 = arith.andi %111, %113 : i1
                scf.condition(%114) %arg41, %arg42, %arg43, %arg44 : i32, i32, i32, f32
              } do {
              ^bb0(%arg41: i32, %arg42: i32, %arg43: i32, %arg44: f32):
                %111 = arith.addi %71, %arg43 : i32
                %112 = arith.muli %111, %arg6 : i32
                %113 = arith.muli %112, %arg7 : i32
                %114 = arith.addi %108, %113 : i32
                %115 = arith.muli %arg43, %arg11 : i32
                %116 = arith.muli %115, %arg12 : i32
                %117 = arith.addi %109, %116 : i32
                %118 = arith.index_cast %114 : i32 to index
                %119 = memref.load %arg0[%118] : memref<?xf32>
                %120 = arith.index_cast %117 : i32 to index
                %121 = memref.load %arg1[%120] : memref<?xf32>
                %122 = arith.mulf %119, %121 : f32
                %123 = arith.addf %arg44, %122 : f32
                %124 = arith.addi %arg43, %c1_i32 : i32
                scf.yield %117, %114, %124, %123 : i32, i32, i32, f32
              }
              scf.yield %110#0, %110#1, %110#2, %109, %108, %110#3 : i32, i32, i32, i32, i32, f32
            } else {
              scf.yield %arg35, %arg36, %arg37, %arg38, %arg39, %arg40 : i32, i32, i32, i32, i32, f32
            }
            scf.yield %107#0, %107#1, %107#2, %107#3, %107#4, %107#5 : i32, i32, i32, i32, i32, f32
          }
          scf.yield %80#0, %80#1, %80#2, %80#3, %80#4, %80#5 : i32, i32, i32, i32, i32, f32
        }
        scf.yield %72#0, %72#1, %72#2, %72#3, %72#4, %72#5 : i32, i32, i32, i32, i32, f32
      }
      %70 = arith.addi %52, %35 : index
      memref.store %69#5, %arg3[%70] : memref<?xf32>
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): before execute: end
WrapAndReplaceBarrierPass::runOnOperation(): after execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg20) = (%c0) to (%c32) step (%c1) {
      %c1_0 = arith.constant 1 : index
      %c4 = arith.constant 4 : index
      %c-1 = arith.constant -1 : index
      %c0_1 = arith.constant 0 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c0_i32 = arith.constant 0 : i32
      %c4_i32 = arith.constant 4 : i32
      %c1_i32 = arith.constant 1 : i32
      %0 = arith.index_cast %arg7 : i32 to index
      %1 = arith.index_cast %arg18 : i32 to index
      %2 = arith.index_cast %arg16 : i32 to index
      %3 = arith.index_cast %arg6 : i32 to index
      %4 = arith.index_cast %arg17 : i32 to index
      %5 = arith.index_cast %arg15 : i32 to index
      %6 = arith.index_cast %arg19 : i32 to index
      %7 = arith.index_cast %arg5 : i32 to index
      %8 = arith.subi %c-1, %7 : index
      %9 = arith.cmpi slt, %7, %c0_1 : index
      %10 = arith.select %9, %8, %7 : index
      %11 = arith.divsi %10, %6 : index
      %12 = arith.subi %c-1, %11 : index
      %13 = arith.select %9, %12, %11 : index
      %14 = arith.divsi %arg5, %arg19 : i32
      %15 = arith.divsi %arg8, %arg19 : i32
      %16 = arith.index_cast %arg11 : i32 to index
      %17 = arith.index_cast %arg12 : i32 to index
      %18 = arith.index_cast %arg10 : i32 to index
      %19 = llvm.mlir.undef : i32
      %20 = gpu.block_id  x
      %21 = arith.index_cast %20 : index to i32
      %22 = gpu.block_dim  x
      %23 = arith.index_cast %22 : index to i32
      %24 = arith.muli %21, %23 : i32
      %25 = arith.index_cast %arg20 : index to i32
      %26 = arith.addi %24, %25 : i32
      %27 = arith.remsi %26, %arg10 : i32
      %28 = arith.muli %27, %arg14 : i32
      %29 = arith.index_cast %28 : i32 to index
      %30 = arith.index_cast %26 : i32 to index
      %31 = arith.remsi %30, %18 : index
      %32 = arith.addi %31, %18 : index
      %33 = arith.cmpi slt, %31, %c0_1 : index
      %34 = arith.select %33, %32, %31 : index
      %35 = arith.divsi %26, %arg10 : i32
      %36 = arith.remsi %35, %arg9 : i32
      %37 = arith.muli %36, %arg13 : i32
      %38 = arith.index_cast %37 : i32 to index
      %39 = arith.divsi %35, %arg9 : i32
      %40 = arith.remsi %39, %arg8 : i32
      %41 = arith.divsi %40, %15 : i32
      %42 = arith.muli %41, %14 : i32
      %43 = arith.index_cast %42 : i32 to index
      %44 = arith.index_cast %40 : i32 to index
      %45 = arith.divsi %39, %arg8 : i32
      %46 = arith.muli %45, %arg8 : i32
      %47 = arith.addi %46, %40 : i32
      %48 = arith.muli %47, %arg9 : i32
      %49 = arith.addi %48, %36 : i32
      %50 = arith.muli %49, %arg10 : i32
      %51 = arith.index_cast %50 : i32 to index
      %52 = arith.muli %arg4, %arg8 : i32
      %53 = arith.muli %52, %arg9 : i32
      %54 = arith.muli %53, %arg10 : i32
      %55 = arith.cmpi slt, %26, %54 : i32
      scf.if %55 {
        %56 = llvm.mlir.zero : !llvm.ptr
        %57 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
        %58 = llvm.icmp "ne" %57, %56 : !llvm.ptr
        %59 = scf.if %58 -> (f32) {
          %70 = memref.load %arg2[%44] : memref<?xf32>
          scf.yield %70 : f32
        } else {
          scf.yield %cst : f32
        }
        %60 = arith.addi %42, %14 : i32
        %61 = arith.subi %37, %arg15 : i32
        %62 = arith.subi %28, %arg16 : i32
        %63 = arith.muli %45, %arg5 : i32
        %64 = arith.muli %63, %arg6 : i32
        %65 = arith.muli %40, %14 : i32
        %66 = arith.muli %65, %arg11 : i32
        %67 = arith.addi %43, %13 : index
        %68:6 = scf.for %arg21 = %43 to %67 step %c4 iter_args(%arg22 = %19, %arg23 = %19, %arg24 = %19, %arg25 = %19, %arg26 = %19, %arg27 = %59) -> (i32, i32, i32, i32, i32, f32) {
          %70 = arith.index_cast %arg21 : index to i32
          %71:6 = scf.for %arg28 = %c0_1 to %16 step %c1_0 iter_args(%arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26, %arg34 = %arg27) -> (i32, i32, i32, i32, i32, f32) {
            %72 = arith.index_cast %arg28 : index to i32
            %73 = arith.muli %72, %arg17 : i32
            %74 = arith.addi %61, %73 : i32
            %75 = arith.addi %64, %74 : i32
            %76 = arith.muli %75, %arg7 : i32
            %77 = arith.addi %66, %72 : i32
            %78 = arith.muli %77, %arg12 : i32
            %79:6 = scf.for %arg35 = %c0_1 to %17 step %c1_0 iter_args(%arg36 = %arg29, %arg37 = %arg30, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33, %arg41 = %arg34) -> (i32, i32, i32, i32, i32, f32) {
              %80 = arith.index_cast %arg35 : index to i32
              %81 = arith.muli %80, %arg18 : i32
              %82 = arith.addi %62, %81 : i32
              %83 = arith.muli %arg35, %1 : index
              %84 = arith.muli %83, %c-1 : index
              %85 = arith.subi %84, %29 : index
              %86 = arith.addi %85, %2 : index
              %87 = arith.addi %86, %0 : index
              %88 = arith.addi %87, %c-1 : index
              %89 = arith.cmpi sge, %88, %c0_1 : index
              %90 = arith.subi %29, %2 : index
              %91 = arith.addi %83, %90 : index
              %92 = arith.cmpi sge, %91, %c0_1 : index
              %93 = arith.andi %89, %92 : i1
              %94 = arith.muli %arg28, %4 : index
              %95 = arith.subi %38, %5 : index
              %96 = arith.addi %94, %95 : index
              %97 = arith.cmpi sge, %96, %c0_1 : index
              %98 = arith.andi %93, %97 : i1
              %99 = arith.muli %94, %c-1 : index
              %100 = arith.subi %99, %38 : index
              %101 = arith.addi %100, %5 : index
              %102 = arith.addi %101, %3 : index
              %103 = arith.addi %102, %c-1 : index
              %104 = arith.cmpi sge, %103, %c0_1 : index
              %105 = arith.andi %98, %104 : i1
              %106:6 = scf.if %105 -> (i32, i32, i32, i32, i32, f32) {
                %107 = arith.addi %76, %82 : i32
                %108 = arith.addi %78, %80 : i32
                %109:4 = scf.while (%arg42 = %arg36, %arg43 = %arg37, %arg44 = %c0_i32, %arg45 = %arg41) : (i32, i32, i32, f32) -> (i32, i32, i32, f32) {
                  %110 = arith.cmpi slt, %arg44, %c4_i32 : i32
                  %111 = arith.addi %70, %arg44 : i32
                  %112 = arith.cmpi slt, %111, %60 : i32
                  %113 = arith.andi %110, %112 : i1
                  scf.condition(%113) %arg42, %arg43, %arg44, %arg45 : i32, i32, i32, f32
                } do {
                ^bb0(%arg42: i32, %arg43: i32, %arg44: i32, %arg45: f32):
                  %110 = arith.addi %70, %arg44 : i32
                  %111 = arith.muli %110, %arg6 : i32
                  %112 = arith.muli %111, %arg7 : i32
                  %113 = arith.addi %107, %112 : i32
                  %114 = arith.muli %arg44, %arg11 : i32
                  %115 = arith.muli %114, %arg12 : i32
                  %116 = arith.addi %108, %115 : i32
                  %117 = arith.index_cast %113 : i32 to index
                  %118 = memref.load %arg0[%117] : memref<?xf32>
                  %119 = arith.index_cast %116 : i32 to index
                  %120 = memref.load %arg1[%119] : memref<?xf32>
                  %121 = arith.mulf %118, %120 : f32
                  %122 = arith.addf %arg45, %121 : f32
                  %123 = arith.addi %arg44, %c1_i32 : i32
                  scf.yield %116, %113, %123, %122 : i32, i32, i32, f32
                }
                scf.yield %109#0, %109#1, %109#2, %108, %107, %109#3 : i32, i32, i32, i32, i32, f32
              } else {
                scf.yield %arg36, %arg37, %arg38, %arg39, %arg40, %arg41 : i32, i32, i32, i32, i32, f32
              }
              scf.yield %106#0, %106#1, %106#2, %106#3, %106#4, %106#5 : i32, i32, i32, i32, i32, f32
            }
            scf.yield %79#0, %79#1, %79#2, %79#3, %79#4, %79#5 : i32, i32, i32, i32, i32, f32
          }
          scf.yield %71#0, %71#1, %71#2, %71#3, %71#4, %71#5 : i32, i32, i32, i32, i32, f32
        }
        %69 = arith.addi %51, %34 : index
        memref.store %68#5, %arg3[%69] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): after execute: end
[ict-debug] driver.cc: After return 7, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg20) = (%c0) to (%c32) step (%c1) {
      %c1_0 = arith.constant 1 : index
      %c4 = arith.constant 4 : index
      %c-1 = arith.constant -1 : index
      %c0_1 = arith.constant 0 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c0_i32 = arith.constant 0 : i32
      %c4_i32 = arith.constant 4 : i32
      %c1_i32 = arith.constant 1 : i32
      %0 = arith.index_cast %arg7 : i32 to index
      %1 = arith.index_cast %arg18 : i32 to index
      %2 = arith.index_cast %arg16 : i32 to index
      %3 = arith.index_cast %arg6 : i32 to index
      %4 = arith.index_cast %arg17 : i32 to index
      %5 = arith.index_cast %arg15 : i32 to index
      %6 = arith.index_cast %arg19 : i32 to index
      %7 = arith.index_cast %arg5 : i32 to index
      %8 = arith.subi %c-1, %7 : index
      %9 = arith.cmpi slt, %7, %c0_1 : index
      %10 = arith.select %9, %8, %7 : index
      %11 = arith.divsi %10, %6 : index
      %12 = arith.subi %c-1, %11 : index
      %13 = arith.select %9, %12, %11 : index
      %14 = arith.divsi %arg5, %arg19 : i32
      %15 = arith.divsi %arg8, %arg19 : i32
      %16 = arith.index_cast %arg11 : i32 to index
      %17 = arith.index_cast %arg12 : i32 to index
      %18 = arith.index_cast %arg10 : i32 to index
      %19 = llvm.mlir.undef : i32
      %20 = gpu.block_id  x
      %21 = arith.index_cast %20 : index to i32
      %22 = gpu.block_dim  x
      %23 = arith.index_cast %22 : index to i32
      %24 = arith.muli %21, %23 : i32
      %25 = arith.index_cast %arg20 : index to i32
      %26 = arith.addi %24, %25 : i32
      %27 = arith.remsi %26, %arg10 : i32
      %28 = arith.muli %27, %arg14 : i32
      %29 = arith.index_cast %28 : i32 to index
      %30 = arith.index_cast %26 : i32 to index
      %31 = arith.remsi %30, %18 : index
      %32 = arith.addi %31, %18 : index
      %33 = arith.cmpi slt, %31, %c0_1 : index
      %34 = arith.select %33, %32, %31 : index
      %35 = arith.divsi %26, %arg10 : i32
      %36 = arith.remsi %35, %arg9 : i32
      %37 = arith.muli %36, %arg13 : i32
      %38 = arith.index_cast %37 : i32 to index
      %39 = arith.divsi %35, %arg9 : i32
      %40 = arith.remsi %39, %arg8 : i32
      %41 = arith.divsi %40, %15 : i32
      %42 = arith.muli %41, %14 : i32
      %43 = arith.index_cast %42 : i32 to index
      %44 = arith.index_cast %40 : i32 to index
      %45 = arith.divsi %39, %arg8 : i32
      %46 = arith.muli %45, %arg8 : i32
      %47 = arith.addi %46, %40 : i32
      %48 = arith.muli %47, %arg9 : i32
      %49 = arith.addi %48, %36 : i32
      %50 = arith.muli %49, %arg10 : i32
      %51 = arith.index_cast %50 : i32 to index
      %52 = arith.muli %arg4, %arg8 : i32
      %53 = arith.muli %52, %arg9 : i32
      %54 = arith.muli %53, %arg10 : i32
      %55 = arith.cmpi slt, %26, %54 : i32
      scf.if %55 {
        %56 = llvm.mlir.zero : !llvm.ptr
        %57 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
        %58 = llvm.icmp "ne" %57, %56 : !llvm.ptr
        %59 = scf.if %58 -> (f32) {
          %70 = memref.load %arg2[%44] : memref<?xf32>
          scf.yield %70 : f32
        } else {
          scf.yield %cst : f32
        }
        %60 = arith.addi %42, %14 : i32
        %61 = arith.subi %37, %arg15 : i32
        %62 = arith.subi %28, %arg16 : i32
        %63 = arith.muli %45, %arg5 : i32
        %64 = arith.muli %63, %arg6 : i32
        %65 = arith.muli %40, %14 : i32
        %66 = arith.muli %65, %arg11 : i32
        %67 = arith.addi %43, %13 : index
        %68:6 = scf.for %arg21 = %43 to %67 step %c4 iter_args(%arg22 = %19, %arg23 = %19, %arg24 = %19, %arg25 = %19, %arg26 = %19, %arg27 = %59) -> (i32, i32, i32, i32, i32, f32) {
          %70 = arith.index_cast %arg21 : index to i32
          %71:6 = scf.for %arg28 = %c0_1 to %16 step %c1_0 iter_args(%arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26, %arg34 = %arg27) -> (i32, i32, i32, i32, i32, f32) {
            %72 = arith.index_cast %arg28 : index to i32
            %73 = arith.muli %72, %arg17 : i32
            %74 = arith.addi %61, %73 : i32
            %75 = arith.addi %64, %74 : i32
            %76 = arith.muli %75, %arg7 : i32
            %77 = arith.addi %66, %72 : i32
            %78 = arith.muli %77, %arg12 : i32
            %79:6 = scf.for %arg35 = %c0_1 to %17 step %c1_0 iter_args(%arg36 = %arg29, %arg37 = %arg30, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33, %arg41 = %arg34) -> (i32, i32, i32, i32, i32, f32) {
              %80 = arith.index_cast %arg35 : index to i32
              %81 = arith.muli %80, %arg18 : i32
              %82 = arith.addi %62, %81 : i32
              %83 = arith.muli %arg35, %1 : index
              %84 = arith.muli %83, %c-1 : index
              %85 = arith.subi %84, %29 : index
              %86 = arith.addi %85, %2 : index
              %87 = arith.addi %86, %0 : index
              %88 = arith.addi %87, %c-1 : index
              %89 = arith.cmpi sge, %88, %c0_1 : index
              %90 = arith.subi %29, %2 : index
              %91 = arith.addi %83, %90 : index
              %92 = arith.cmpi sge, %91, %c0_1 : index
              %93 = arith.andi %89, %92 : i1
              %94 = arith.muli %arg28, %4 : index
              %95 = arith.subi %38, %5 : index
              %96 = arith.addi %94, %95 : index
              %97 = arith.cmpi sge, %96, %c0_1 : index
              %98 = arith.andi %93, %97 : i1
              %99 = arith.muli %94, %c-1 : index
              %100 = arith.subi %99, %38 : index
              %101 = arith.addi %100, %5 : index
              %102 = arith.addi %101, %3 : index
              %103 = arith.addi %102, %c-1 : index
              %104 = arith.cmpi sge, %103, %c0_1 : index
              %105 = arith.andi %98, %104 : i1
              %106:6 = scf.if %105 -> (i32, i32, i32, i32, i32, f32) {
                %107 = arith.addi %76, %82 : i32
                %108 = arith.addi %78, %80 : i32
                %109:4 = scf.while (%arg42 = %arg36, %arg43 = %arg37, %arg44 = %c0_i32, %arg45 = %arg41) : (i32, i32, i32, f32) -> (i32, i32, i32, f32) {
                  %110 = arith.cmpi slt, %arg44, %c4_i32 : i32
                  %111 = arith.addi %70, %arg44 : i32
                  %112 = arith.cmpi slt, %111, %60 : i32
                  %113 = arith.andi %110, %112 : i1
                  scf.condition(%113) %arg42, %arg43, %arg44, %arg45 : i32, i32, i32, f32
                } do {
                ^bb0(%arg42: i32, %arg43: i32, %arg44: i32, %arg45: f32):
                  %110 = arith.addi %70, %arg44 : i32
                  %111 = arith.muli %110, %arg6 : i32
                  %112 = arith.muli %111, %arg7 : i32
                  %113 = arith.addi %107, %112 : i32
                  %114 = arith.muli %arg44, %arg11 : i32
                  %115 = arith.muli %114, %arg12 : i32
                  %116 = arith.addi %108, %115 : i32
                  %117 = arith.index_cast %113 : i32 to index
                  %118 = memref.load %arg0[%117] : memref<?xf32>
                  %119 = arith.index_cast %116 : i32 to index
                  %120 = memref.load %arg1[%119] : memref<?xf32>
                  %121 = arith.mulf %118, %120 : f32
                  %122 = arith.addf %arg45, %121 : f32
                  %123 = arith.addi %arg44, %c1_i32 : i32
                  scf.yield %116, %113, %123, %122 : i32, i32, i32, f32
                }
                scf.yield %109#0, %109#1, %109#2, %108, %107, %109#3 : i32, i32, i32, i32, i32, f32
              } else {
                scf.yield %arg36, %arg37, %arg38, %arg39, %arg40, %arg41 : i32, i32, i32, i32, i32, f32
              }
              scf.yield %106#0, %106#1, %106#2, %106#3, %106#4, %106#5 : i32, i32, i32, i32, i32, f32
            }
            scf.yield %79#0, %79#1, %79#2, %79#3, %79#4, %79#5 : i32, i32, i32, i32, i32, f32
          }
          scf.yield %71#0, %71#1, %71#2, %71#3, %71#4, %71#5 : i32, i32, i32, i32, i32, f32
        }
        %69 = arith.addi %51, %34 : index
        memref.store %68#5, %arg3[%69] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
}
[ict-debug] driver.cc: After return 7, module: end

[ict-debug] driver.cc: Before my pass process:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1_i32 = arith.constant 1 : i32
    %c4_i32 = arith.constant 4 : i32
    %c0_i32 = arith.constant 0 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %c-1 = arith.constant -1 : index
    %c4 = arith.constant 4 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %0 = arith.index_cast %arg7 : i32 to index
    %1 = arith.index_cast %arg18 : i32 to index
    %2 = arith.index_cast %arg16 : i32 to index
    %3 = arith.index_cast %arg6 : i32 to index
    %4 = arith.index_cast %arg17 : i32 to index
    %5 = arith.index_cast %arg15 : i32 to index
    %6 = arith.index_cast %arg19 : i32 to index
    %7 = arith.index_cast %arg5 : i32 to index
    %8 = arith.subi %c-1, %7 : index
    %9 = arith.cmpi slt, %7, %c0 : index
    %10 = arith.select %9, %8, %7 : index
    %11 = arith.index_cast %arg11 : i32 to index
    %12 = arith.index_cast %arg12 : i32 to index
    %13 = arith.index_cast %arg10 : i32 to index
    %14 = llvm.mlir.undef : i32
    %15 = gpu.block_id  x
    %16 = arith.index_cast %15 : index to i32
    %17 = gpu.block_dim  x
    %18 = arith.index_cast %17 : index to i32
    %19 = arith.muli %16, %18 : i32
    %20 = arith.muli %arg4, %arg8 : i32
    %21 = arith.muli %20, %arg9 : i32
    %22 = arith.muli %21, %arg10 : i32
    %23 = arith.divsi %10, %6 : index
    %24 = arith.subi %c-1, %23 : index
    %25 = arith.select %9, %24, %23 : index
    %26 = arith.divsi %arg5, %arg19 : i32
    %27 = arith.divsi %arg8, %arg19 : i32
    %28 = llvm.mlir.zero : !llvm.ptr
    %29 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
    %30 = llvm.icmp "ne" %29, %28 : !llvm.ptr
    scf.parallel (%arg20) = (%c0) to (%c32) step (%c1) {
      %31 = arith.index_cast %arg20 : index to i32
      %32 = arith.addi %19, %31 : i32
      %33 = arith.remsi %32, %arg10 : i32
      %34 = arith.muli %33, %arg14 : i32
      %35 = arith.index_cast %34 : i32 to index
      %36 = arith.index_cast %32 : i32 to index
      %37 = arith.remsi %36, %13 : index
      %38 = arith.addi %37, %13 : index
      %39 = arith.cmpi slt, %37, %c0 : index
      %40 = arith.select %39, %38, %37 : index
      %41 = arith.divsi %32, %arg10 : i32
      %42 = arith.remsi %41, %arg9 : i32
      %43 = arith.muli %42, %arg13 : i32
      %44 = arith.index_cast %43 : i32 to index
      %45 = arith.divsi %41, %arg9 : i32
      %46 = arith.remsi %45, %arg8 : i32
      %47 = arith.divsi %46, %27 : i32
      %48 = arith.muli %47, %26 : i32
      %49 = arith.index_cast %48 : i32 to index
      %50 = arith.index_cast %46 : i32 to index
      %51 = arith.divsi %45, %arg8 : i32
      %52 = arith.muli %51, %arg8 : i32
      %53 = arith.addi %52, %46 : i32
      %54 = arith.muli %53, %arg9 : i32
      %55 = arith.addi %54, %42 : i32
      %56 = arith.muli %55, %arg10 : i32
      %57 = arith.index_cast %56 : i32 to index
      %58 = arith.cmpi slt, %32, %22 : i32
      scf.if %58 {
        %59 = scf.if %30 -> (f32) {
          %72 = memref.load %arg2[%50] : memref<?xf32>
          scf.yield %72 : f32
        } else {
          scf.yield %cst : f32
        }
        %60 = arith.addi %48, %26 : i32
        %61 = arith.subi %43, %arg15 : i32
        %62 = arith.subi %34, %arg16 : i32
        %63 = arith.muli %51, %arg5 : i32
        %64 = arith.muli %63, %arg6 : i32
        %65 = arith.muli %46, %26 : i32
        %66 = arith.muli %65, %arg11 : i32
        %67 = arith.addi %49, %25 : index
        %68 = arith.subi %35, %2 : index
        %69 = arith.subi %44, %5 : index
        %70:6 = scf.for %arg21 = %49 to %67 step %c4 iter_args(%arg22 = %14, %arg23 = %14, %arg24 = %14, %arg25 = %14, %arg26 = %14, %arg27 = %59) -> (i32, i32, i32, i32, i32, f32) {
          %72 = arith.index_cast %arg21 : index to i32
          %73:6 = scf.for %arg28 = %c0 to %11 step %c1 iter_args(%arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26, %arg34 = %arg27) -> (i32, i32, i32, i32, i32, f32) {
            %74 = arith.index_cast %arg28 : index to i32
            %75 = arith.muli %74, %arg17 : i32
            %76 = arith.addi %61, %75 : i32
            %77 = arith.addi %64, %76 : i32
            %78 = arith.muli %77, %arg7 : i32
            %79 = arith.addi %66, %74 : i32
            %80 = arith.muli %79, %arg12 : i32
            %81 = arith.muli %arg28, %4 : index
            %82 = arith.addi %81, %69 : index
            %83 = arith.cmpi sge, %82, %c0 : index
            %84 = arith.muli %81, %c-1 : index
            %85 = arith.subi %84, %44 : index
            %86 = arith.addi %85, %5 : index
            %87 = arith.addi %86, %3 : index
            %88 = arith.addi %87, %c-1 : index
            %89 = arith.cmpi sge, %88, %c0 : index
            %90:6 = scf.for %arg35 = %c0 to %12 step %c1 iter_args(%arg36 = %arg29, %arg37 = %arg30, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33, %arg41 = %arg34) -> (i32, i32, i32, i32, i32, f32) {
              %91 = arith.index_cast %arg35 : index to i32
              %92 = arith.muli %91, %arg18 : i32
              %93 = arith.addi %62, %92 : i32
              %94 = arith.muli %arg35, %1 : index
              %95 = arith.muli %94, %c-1 : index
              %96 = arith.subi %95, %35 : index
              %97 = arith.addi %96, %2 : index
              %98 = arith.addi %97, %0 : index
              %99 = arith.addi %98, %c-1 : index
              %100 = arith.cmpi sge, %99, %c0 : index
              %101 = arith.addi %94, %68 : index
              %102 = arith.cmpi sge, %101, %c0 : index
              %103 = arith.andi %100, %102 : i1
              %104 = arith.andi %103, %83 : i1
              %105 = arith.andi %104, %89 : i1
              %106:6 = scf.if %105 -> (i32, i32, i32, i32, i32, f32) {
                %107 = arith.addi %78, %93 : i32
                %108 = arith.addi %80, %91 : i32
                %109:4 = scf.while (%arg42 = %arg36, %arg43 = %arg37, %arg44 = %c0_i32, %arg45 = %arg41) : (i32, i32, i32, f32) -> (i32, i32, i32, f32) {
                  %110 = arith.cmpi slt, %arg44, %c4_i32 : i32
                  %111 = arith.addi %72, %arg44 : i32
                  %112 = arith.cmpi slt, %111, %60 : i32
                  %113 = arith.andi %110, %112 : i1
                  scf.condition(%113) %arg42, %arg43, %arg44, %arg45 : i32, i32, i32, f32
                } do {
                ^bb0(%arg42: i32, %arg43: i32, %arg44: i32, %arg45: f32):
                  %110 = arith.addi %72, %arg44 : i32
                  %111 = arith.muli %110, %arg6 : i32
                  %112 = arith.muli %111, %arg7 : i32
                  %113 = arith.addi %107, %112 : i32
                  %114 = arith.muli %arg44, %arg11 : i32
                  %115 = arith.muli %114, %arg12 : i32
                  %116 = arith.addi %108, %115 : i32
                  %117 = arith.index_cast %113 : i32 to index
                  %118 = memref.load %arg0[%117] : memref<?xf32>
                  %119 = arith.index_cast %116 : i32 to index
                  %120 = memref.load %arg1[%119] : memref<?xf32>
                  %121 = arith.mulf %118, %120 : f32
                  %122 = arith.addf %arg45, %121 : f32
                  %123 = arith.addi %arg44, %c1_i32 : i32
                  scf.yield %116, %113, %123, %122 : i32, i32, i32, f32
                }
                scf.yield %109#0, %109#1, %109#2, %108, %107, %109#3 : i32, i32, i32, i32, i32, f32
              } else {
                scf.yield %arg36, %arg37, %arg38, %arg39, %arg40, %arg41 : i32, i32, i32, i32, i32, f32
              }
              scf.yield %106#0, %106#1, %106#2, %106#3, %106#4, %106#5 : i32, i32, i32, i32, i32, f32
            }
            scf.yield %90#0, %90#1, %90#2, %90#3, %90#4, %90#5 : i32, i32, i32, i32, i32, f32
          }
          scf.yield %73#0, %73#1, %73#2, %73#3, %73#4, %73#5 : i32, i32, i32, i32, i32, f32
        }
        %71 = arith.addi %57, %40 : index
        memref.store %70#5, %arg3[%71] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
}
[ict-debug] driver.cc: Before my pass process: end

[ict-debug] driver.cc: vectorizeSize = 1

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii_0 {
    gpu.func @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) {
      %c1_i32 = arith.constant 1 : i32
      %c4_i32 = arith.constant 4 : i32
      %c0_i32 = arith.constant 0 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c-1 = arith.constant -1 : index
      %c4 = arith.constant 4 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = arith.index_cast %arg7 : i32 to index
      %1 = arith.index_cast %arg18 : i32 to index
      %2 = arith.index_cast %arg16 : i32 to index
      %3 = arith.index_cast %arg6 : i32 to index
      %4 = arith.index_cast %arg17 : i32 to index
      %5 = arith.index_cast %arg15 : i32 to index
      %6 = arith.index_cast %arg19 : i32 to index
      %7 = arith.index_cast %arg5 : i32 to index
      %8 = arith.subi %c-1, %7 : index
      %9 = arith.cmpi slt, %7, %c0 : index
      %10 = arith.select %9, %8, %7 : index
      %11 = arith.index_cast %arg11 : i32 to index
      %12 = arith.index_cast %arg12 : i32 to index
      %13 = arith.index_cast %arg10 : i32 to index
      %14 = llvm.mlir.undef : i32
      %15 = gpu.block_id  x
      %16 = arith.index_cast %15 : index to i32
      %17 = gpu.block_dim  x
      %18 = arith.index_cast %17 : index to i32
      %19 = arith.muli %16, %18 : i32
      %20 = arith.muli %arg4, %arg8 : i32
      %21 = arith.muli %20, %arg9 : i32
      %22 = arith.muli %21, %arg10 : i32
      %23 = arith.divsi %10, %6 : index
      %24 = arith.subi %c-1, %23 : index
      %25 = arith.select %9, %24, %23 : index
      %26 = arith.divsi %arg5, %arg19 : i32
      %27 = arith.divsi %arg8, %arg19 : i32
      %28 = llvm.mlir.zero : !llvm.ptr
      %29 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %30 = llvm.icmp "ne" %29, %28 : !llvm.ptr
      scf.parallel (%arg20) = (%c0) to (%c32) step (%c1) {
        %31 = arith.index_cast %arg20 : index to i32
        %32 = arith.addi %19, %31 : i32
        %33 = arith.remsi %32, %arg10 : i32
        %34 = arith.muli %33, %arg14 : i32
        %35 = arith.index_cast %34 : i32 to index
        %36 = arith.index_cast %32 : i32 to index
        %37 = arith.remsi %36, %13 : index
        %38 = arith.addi %37, %13 : index
        %39 = arith.cmpi slt, %37, %c0 : index
        %40 = arith.select %39, %38, %37 : index
        %41 = arith.divsi %32, %arg10 : i32
        %42 = arith.remsi %41, %arg9 : i32
        %43 = arith.muli %42, %arg13 : i32
        %44 = arith.index_cast %43 : i32 to index
        %45 = arith.divsi %41, %arg9 : i32
        %46 = arith.remsi %45, %arg8 : i32
        %47 = arith.divsi %46, %27 : i32
        %48 = arith.muli %47, %26 : i32
        %49 = arith.index_cast %48 : i32 to index
        %50 = arith.index_cast %46 : i32 to index
        %51 = arith.divsi %45, %arg8 : i32
        %52 = arith.muli %51, %arg8 : i32
        %53 = arith.addi %52, %46 : i32
        %54 = arith.muli %53, %arg9 : i32
        %55 = arith.addi %54, %42 : i32
        %56 = arith.muli %55, %arg10 : i32
        %57 = arith.index_cast %56 : i32 to index
        %58 = arith.cmpi slt, %32, %22 : i32
        scf.if %58 {
          %59 = scf.if %30 -> (f32) {
            %72 = memref.load %arg2[%50] : memref<?xf32>
            scf.yield %72 : f32
          } else {
            scf.yield %cst : f32
          }
          %60 = arith.addi %48, %26 : i32
          %61 = arith.subi %43, %arg15 : i32
          %62 = arith.subi %34, %arg16 : i32
          %63 = arith.muli %51, %arg5 : i32
          %64 = arith.muli %63, %arg6 : i32
          %65 = arith.muli %46, %26 : i32
          %66 = arith.muli %65, %arg11 : i32
          %67 = arith.addi %49, %25 : index
          %68 = arith.subi %35, %2 : index
          %69 = arith.subi %44, %5 : index
          %70:6 = scf.for %arg21 = %49 to %67 step %c4 iter_args(%arg22 = %14, %arg23 = %14, %arg24 = %14, %arg25 = %14, %arg26 = %14, %arg27 = %59) -> (i32, i32, i32, i32, i32, f32) {
            %72 = arith.index_cast %arg21 : index to i32
            %73:6 = scf.for %arg28 = %c0 to %11 step %c1 iter_args(%arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26, %arg34 = %arg27) -> (i32, i32, i32, i32, i32, f32) {
              %74 = arith.index_cast %arg28 : index to i32
              %75 = arith.muli %74, %arg17 : i32
              %76 = arith.addi %61, %75 : i32
              %77 = arith.addi %64, %76 : i32
              %78 = arith.muli %77, %arg7 : i32
              %79 = arith.addi %66, %74 : i32
              %80 = arith.muli %79, %arg12 : i32
              %81 = arith.muli %arg28, %4 : index
              %82 = arith.addi %81, %69 : index
              %83 = arith.cmpi sge, %82, %c0 : index
              %84 = arith.muli %81, %c-1 : index
              %85 = arith.subi %84, %44 : index
              %86 = arith.addi %85, %5 : index
              %87 = arith.addi %86, %3 : index
              %88 = arith.addi %87, %c-1 : index
              %89 = arith.cmpi sge, %88, %c0 : index
              %90:6 = scf.for %arg35 = %c0 to %12 step %c1 iter_args(%arg36 = %arg29, %arg37 = %arg30, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33, %arg41 = %arg34) -> (i32, i32, i32, i32, i32, f32) {
                %91 = arith.index_cast %arg35 : index to i32
                %92 = arith.muli %91, %arg18 : i32
                %93 = arith.addi %62, %92 : i32
                %94 = arith.muli %arg35, %1 : index
                %95 = arith.muli %94, %c-1 : index
                %96 = arith.subi %95, %35 : index
                %97 = arith.addi %96, %2 : index
                %98 = arith.addi %97, %0 : index
                %99 = arith.addi %98, %c-1 : index
                %100 = arith.cmpi sge, %99, %c0 : index
                %101 = arith.addi %94, %68 : index
                %102 = arith.cmpi sge, %101, %c0 : index
                %103 = arith.andi %100, %102 : i1
                %104 = arith.andi %103, %83 : i1
                %105 = arith.andi %104, %89 : i1
                %106:6 = scf.if %105 -> (i32, i32, i32, i32, i32, f32) {
                  %107 = arith.addi %78, %93 : i32
                  %108 = arith.addi %80, %91 : i32
                  %109:4 = scf.while (%arg42 = %arg36, %arg43 = %arg37, %arg44 = %c0_i32, %arg45 = %arg41) : (i32, i32, i32, f32) -> (i32, i32, i32, f32) {
                    %110 = arith.cmpi slt, %arg44, %c4_i32 : i32
                    %111 = arith.addi %72, %arg44 : i32
                    %112 = arith.cmpi slt, %111, %60 : i32
                    %113 = arith.andi %110, %112 : i1
                    scf.condition(%113) %arg42, %arg43, %arg44, %arg45 : i32, i32, i32, f32
                  } do {
                  ^bb0(%arg42: i32, %arg43: i32, %arg44: i32, %arg45: f32):
                    %110 = arith.addi %72, %arg44 : i32
                    %111 = arith.muli %110, %arg6 : i32
                    %112 = arith.muli %111, %arg7 : i32
                    %113 = arith.addi %107, %112 : i32
                    %114 = arith.muli %arg44, %arg11 : i32
                    %115 = arith.muli %114, %arg12 : i32
                    %116 = arith.addi %108, %115 : i32
                    %117 = arith.index_cast %113 : i32 to index
                    %118 = memref.load %arg0[%117] : memref<?xf32>
                    %119 = arith.index_cast %116 : i32 to index
                    %120 = memref.load %arg1[%119] : memref<?xf32>
                    %121 = arith.mulf %118, %120 : f32
                    %122 = arith.addf %arg45, %121 : f32
                    %123 = arith.addi %arg44, %c1_i32 : i32
                    scf.yield %116, %113, %123, %122 : i32, i32, i32, f32
                  }
                  scf.yield %109#0, %109#1, %109#2, %108, %107, %109#3 : i32, i32, i32, i32, i32, f32
                } else {
                  scf.yield %arg36, %arg37, %arg38, %arg39, %arg40, %arg41 : i32, i32, i32, i32, i32, f32
                }
                scf.yield %106#0, %106#1, %106#2, %106#3, %106#4, %106#5 : i32, i32, i32, i32, i32, f32
              }
              scf.yield %90#0, %90#1, %90#2, %90#3, %90#4, %90#5 : i32, i32, i32, i32, i32, f32
            }
            scf.yield %73#0, %73#1, %73#2, %73#3, %73#4, %73#5 : i32, i32, i32, i32, i32, f32
          }
          %71 = arith.addi %57, %40 : index
          memref.store %70#5, %arg3[%71] : memref<?xf32>
        }
        scf.yield
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute: end

[ict-debug] ConvertPolygeistToNPU:convertScfParallelToScfFor(): replace gpu.block_dim op with thread loop bound

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii_0 {
    gpu.func @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) {
      %c1_i32 = arith.constant 1 : i32
      %c4_i32 = arith.constant 4 : i32
      %c0_i32 = arith.constant 0 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c-1 = arith.constant -1 : index
      %c4 = arith.constant 4 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = arith.index_cast %arg7 : i32 to index
      %1 = arith.index_cast %arg18 : i32 to index
      %2 = arith.index_cast %arg16 : i32 to index
      %3 = arith.index_cast %arg6 : i32 to index
      %4 = arith.index_cast %arg17 : i32 to index
      %5 = arith.index_cast %arg15 : i32 to index
      %6 = arith.index_cast %arg19 : i32 to index
      %7 = arith.index_cast %arg5 : i32 to index
      %8 = arith.subi %c-1, %7 : index
      %9 = arith.cmpi slt, %7, %c0 : index
      %10 = arith.select %9, %8, %7 : index
      %11 = arith.index_cast %arg11 : i32 to index
      %12 = arith.index_cast %arg12 : i32 to index
      %13 = arith.index_cast %arg10 : i32 to index
      %14 = llvm.mlir.undef : i32
      %15 = gpu.block_id  x
      %16 = arith.index_cast %15 : index to i32
      %c32_0 = arith.constant 32 : index
      %17 = arith.index_cast %c32_0 : index to i32
      %18 = arith.muli %16, %17 : i32
      %19 = arith.muli %arg4, %arg8 : i32
      %20 = arith.muli %19, %arg9 : i32
      %21 = arith.muli %20, %arg10 : i32
      %22 = arith.divsi %10, %6 : index
      %23 = arith.subi %c-1, %22 : index
      %24 = arith.select %9, %23, %22 : index
      %25 = arith.divsi %arg5, %arg19 : i32
      %26 = arith.divsi %arg8, %arg19 : i32
      %27 = llvm.mlir.zero : !llvm.ptr
      %28 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %29 = llvm.icmp "ne" %28, %27 : !llvm.ptr
      %c1_1 = arith.constant 1 : index
      scf.for %arg20 = %c0 to %c32 step %c1_1 {
        %30 = arith.index_cast %arg20 : index to i32
        %31 = arith.addi %18, %30 : i32
        %32 = arith.remsi %31, %arg10 : i32
        %33 = arith.muli %32, %arg14 : i32
        %34 = arith.index_cast %33 : i32 to index
        %35 = arith.index_cast %31 : i32 to index
        %36 = arith.remsi %35, %13 : index
        %37 = arith.addi %36, %13 : index
        %38 = arith.cmpi slt, %36, %c0 : index
        %39 = arith.select %38, %37, %36 : index
        %40 = arith.divsi %31, %arg10 : i32
        %41 = arith.remsi %40, %arg9 : i32
        %42 = arith.muli %41, %arg13 : i32
        %43 = arith.index_cast %42 : i32 to index
        %44 = arith.divsi %40, %arg9 : i32
        %45 = arith.remsi %44, %arg8 : i32
        %46 = arith.divsi %45, %26 : i32
        %47 = arith.muli %46, %25 : i32
        %48 = arith.index_cast %47 : i32 to index
        %49 = arith.index_cast %45 : i32 to index
        %50 = arith.divsi %44, %arg8 : i32
        %51 = arith.muli %50, %arg8 : i32
        %52 = arith.addi %51, %45 : i32
        %53 = arith.muli %52, %arg9 : i32
        %54 = arith.addi %53, %41 : i32
        %55 = arith.muli %54, %arg10 : i32
        %56 = arith.index_cast %55 : i32 to index
        %57 = arith.cmpi slt, %31, %21 : i32
        scf.if %57 {
          %58 = scf.if %29 -> (f32) {
            %71 = memref.load %arg2[%49] : memref<?xf32>
            scf.yield %71 : f32
          } else {
            scf.yield %cst : f32
          }
          %59 = arith.addi %47, %25 : i32
          %60 = arith.subi %42, %arg15 : i32
          %61 = arith.subi %33, %arg16 : i32
          %62 = arith.muli %50, %arg5 : i32
          %63 = arith.muli %62, %arg6 : i32
          %64 = arith.muli %45, %25 : i32
          %65 = arith.muli %64, %arg11 : i32
          %66 = arith.addi %48, %24 : index
          %67 = arith.subi %34, %2 : index
          %68 = arith.subi %43, %5 : index
          %69:6 = scf.for %arg21 = %48 to %66 step %c4 iter_args(%arg22 = %14, %arg23 = %14, %arg24 = %14, %arg25 = %14, %arg26 = %14, %arg27 = %58) -> (i32, i32, i32, i32, i32, f32) {
            %71 = arith.index_cast %arg21 : index to i32
            %72:6 = scf.for %arg28 = %c0 to %11 step %c1 iter_args(%arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26, %arg34 = %arg27) -> (i32, i32, i32, i32, i32, f32) {
              %73 = arith.index_cast %arg28 : index to i32
              %74 = arith.muli %73, %arg17 : i32
              %75 = arith.addi %60, %74 : i32
              %76 = arith.addi %63, %75 : i32
              %77 = arith.muli %76, %arg7 : i32
              %78 = arith.addi %65, %73 : i32
              %79 = arith.muli %78, %arg12 : i32
              %80 = arith.muli %arg28, %4 : index
              %81 = arith.addi %80, %68 : index
              %82 = arith.cmpi sge, %81, %c0 : index
              %83 = arith.muli %80, %c-1 : index
              %84 = arith.subi %83, %43 : index
              %85 = arith.addi %84, %5 : index
              %86 = arith.addi %85, %3 : index
              %87 = arith.addi %86, %c-1 : index
              %88 = arith.cmpi sge, %87, %c0 : index
              %89:6 = scf.for %arg35 = %c0 to %12 step %c1 iter_args(%arg36 = %arg29, %arg37 = %arg30, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33, %arg41 = %arg34) -> (i32, i32, i32, i32, i32, f32) {
                %90 = arith.index_cast %arg35 : index to i32
                %91 = arith.muli %90, %arg18 : i32
                %92 = arith.addi %61, %91 : i32
                %93 = arith.muli %arg35, %1 : index
                %94 = arith.muli %93, %c-1 : index
                %95 = arith.subi %94, %34 : index
                %96 = arith.addi %95, %2 : index
                %97 = arith.addi %96, %0 : index
                %98 = arith.addi %97, %c-1 : index
                %99 = arith.cmpi sge, %98, %c0 : index
                %100 = arith.addi %93, %67 : index
                %101 = arith.cmpi sge, %100, %c0 : index
                %102 = arith.andi %99, %101 : i1
                %103 = arith.andi %102, %82 : i1
                %104 = arith.andi %103, %88 : i1
                %105:6 = scf.if %104 -> (i32, i32, i32, i32, i32, f32) {
                  %106 = arith.addi %77, %92 : i32
                  %107 = arith.addi %79, %90 : i32
                  %108:4 = scf.while (%arg42 = %arg36, %arg43 = %arg37, %arg44 = %c0_i32, %arg45 = %arg41) : (i32, i32, i32, f32) -> (i32, i32, i32, f32) {
                    %109 = arith.cmpi slt, %arg44, %c4_i32 : i32
                    %110 = arith.addi %71, %arg44 : i32
                    %111 = arith.cmpi slt, %110, %59 : i32
                    %112 = arith.andi %109, %111 : i1
                    scf.condition(%112) %arg42, %arg43, %arg44, %arg45 : i32, i32, i32, f32
                  } do {
                  ^bb0(%arg42: i32, %arg43: i32, %arg44: i32, %arg45: f32):
                    %109 = arith.addi %71, %arg44 : i32
                    %110 = arith.muli %109, %arg6 : i32
                    %111 = arith.muli %110, %arg7 : i32
                    %112 = arith.addi %106, %111 : i32
                    %113 = arith.muli %arg44, %arg11 : i32
                    %114 = arith.muli %113, %arg12 : i32
                    %115 = arith.addi %107, %114 : i32
                    %116 = arith.index_cast %112 : i32 to index
                    %117 = memref.load %arg0[%116] : memref<?xf32>
                    %118 = arith.index_cast %115 : i32 to index
                    %119 = memref.load %arg1[%118] : memref<?xf32>
                    %120 = arith.mulf %117, %119 : f32
                    %121 = arith.addf %arg45, %120 : f32
                    %122 = arith.addi %arg44, %c1_i32 : i32
                    scf.yield %115, %112, %122, %121 : i32, i32, i32, f32
                  }
                  scf.yield %108#0, %108#1, %108#2, %107, %106, %108#3 : i32, i32, i32, i32, i32, f32
                } else {
                  scf.yield %arg36, %arg37, %arg38, %arg39, %arg40, %arg41 : i32, i32, i32, i32, i32, f32
                }
                scf.yield %105#0, %105#1, %105#2, %105#3, %105#4, %105#5 : i32, i32, i32, i32, i32, f32
              }
              scf.yield %89#0, %89#1, %89#2, %89#3, %89#4, %89#5 : i32, i32, i32, i32, i32, f32
            }
            scf.yield %72#0, %72#1, %72#2, %72#3, %72#4, %72#5 : i32, i32, i32, i32, i32, f32
          }
          %70 = arith.addi %56, %39 : index
          memref.store %69#5, %arg3[%70] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize: end

[ict-debug] CastLikeOpToNPULowering: process op: 

%0 = arith.index_cast %arg7 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%2 = arith.index_cast %arg18 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%4 = arith.index_cast %arg16 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%6 = arith.index_cast %arg6 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%8 = arith.index_cast %arg17 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%10 = arith.index_cast %arg15 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%12 = arith.index_cast %arg19 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%14 = arith.index_cast %arg5 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%19 = arith.index_cast %arg11 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%21 = arith.index_cast %arg12 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%23 = arith.index_cast %arg10 : i32 to index
[ict-debug] GPUBlockIdToNPULowering: process op: 

%26 = gpu.block_id  x
[ict-debug] CastLikeOpToNPULowering: process op: 

%28 = arith.index_cast %27 : index to i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%46 = arith.index_cast %arg20 : index to i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%51 = arith.index_cast %50 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%53 = arith.index_cast %48 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%62 = arith.index_cast %61 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%68 = arith.index_cast %67 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%70 = arith.index_cast %65 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%78 = arith.index_cast %77 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%95 = arith.index_cast %arg21 : index to i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%99 = arith.index_cast %arg28 : index to i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%118 = arith.index_cast %arg35 : index to i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%145 = arith.index_cast %141 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%148 = arith.index_cast %144 : i32 to index
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii_0 {
    gpu.func @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) {
      %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.ptr
      %c1_i32 = arith.constant 1 : i32
      %c4_i32 = arith.constant 4 : i32
      %c0_i32 = arith.constant 0 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c-1 = arith.constant -1 : index
      %c4 = arith.constant 4 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %1 = emitc.cast %arg7 : i32 to index
      %2 = emitc.cast %arg18 : i32 to index
      %3 = emitc.cast %arg16 : i32 to index
      %4 = emitc.cast %arg6 : i32 to index
      %5 = emitc.cast %arg17 : i32 to index
      %6 = emitc.cast %arg15 : i32 to index
      %7 = emitc.cast %arg19 : i32 to index
      %8 = emitc.cast %arg5 : i32 to index
      %9 = arith.subi %c-1, %8 : index
      %10 = arith.cmpi slt, %8, %c0 : index
      %11 = arith.select %10, %9, %8 : index
      %12 = emitc.cast %arg11 : i32 to index
      %13 = emitc.cast %arg12 : i32 to index
      %14 = emitc.cast %arg10 : i32 to index
      %15 = llvm.mlir.undef : i32
      %16 = "npu.block_id"() : () -> i64
      %17 = emitc.cast %16 : i64 to i32
      %c32_0 = arith.constant 32 : index
      %c32_i32 = arith.constant 32 : i32
      %18 = arith.muli %17, %c32_i32 : i32
      %19 = arith.muli %arg4, %arg8 : i32
      %20 = arith.muli %19, %arg9 : i32
      %21 = arith.muli %20, %arg10 : i32
      %22 = arith.divsi %11, %7 : index
      %23 = arith.subi %c-1, %22 : index
      %24 = arith.select %10, %23, %22 : index
      %25 = arith.divsi %arg5, %arg19 : i32
      %26 = arith.divsi %arg8, %arg19 : i32
      %27 = llvm.mlir.zero : !llvm.ptr
      %28 = llvm.bitcast %0 : !llvm.ptr to !llvm.ptr
      %29 = llvm.icmp "ne" %28, %27 : !llvm.ptr
      %c1_1 = arith.constant 1 : index
      scf.for %arg20 = %c0 to %c32 step %c1_1 {
        %30 = builtin.unrealized_conversion_cast %arg20 : index to i64
        %31 = emitc.cast %30 : i64 to i32
        %32 = arith.addi %18, %31 : i32
        %33 = arith.remsi %32, %arg10 : i32
        %34 = arith.muli %33, %arg14 : i32
        %35 = emitc.cast %34 : i32 to index
        %36 = emitc.cast %32 : i32 to index
        %37 = arith.remsi %36, %14 : index
        %38 = arith.addi %37, %14 : index
        %39 = arith.cmpi slt, %37, %c0 : index
        %40 = arith.select %39, %38, %37 : index
        %41 = arith.divsi %32, %arg10 : i32
        %42 = arith.remsi %41, %arg9 : i32
        %43 = arith.muli %42, %arg13 : i32
        %44 = emitc.cast %43 : i32 to index
        %45 = arith.divsi %41, %arg9 : i32
        %46 = arith.remsi %45, %arg8 : i32
        %47 = arith.divsi %46, %26 : i32
        %48 = arith.muli %47, %25 : i32
        %49 = emitc.cast %48 : i32 to index
        %50 = emitc.cast %46 : i32 to index
        %51 = arith.divsi %45, %arg8 : i32
        %52 = arith.muli %51, %arg8 : i32
        %53 = arith.addi %52, %46 : i32
        %54 = arith.muli %53, %arg9 : i32
        %55 = arith.addi %54, %42 : i32
        %56 = arith.muli %55, %arg10 : i32
        %57 = emitc.cast %56 : i32 to index
        %58 = arith.cmpi slt, %32, %21 : i32
        scf.if %58 {
          %59 = scf.if %29 -> (f32) {
            %72 = memref.load %arg2[%50] : memref<?xf32>
            scf.yield %72 : f32
          } else {
            scf.yield %cst : f32
          }
          %60 = arith.addi %48, %25 : i32
          %61 = arith.subi %43, %arg15 : i32
          %62 = arith.subi %34, %arg16 : i32
          %63 = arith.muli %51, %arg5 : i32
          %64 = arith.muli %63, %arg6 : i32
          %65 = arith.muli %46, %25 : i32
          %66 = arith.muli %65, %arg11 : i32
          %67 = arith.addi %49, %24 : index
          %68 = arith.subi %35, %3 : index
          %69 = arith.subi %44, %6 : index
          %70:6 = scf.for %arg21 = %49 to %67 step %c4 iter_args(%arg22 = %15, %arg23 = %15, %arg24 = %15, %arg25 = %15, %arg26 = %15, %arg27 = %59) -> (i32, i32, i32, i32, i32, f32) {
            %72 = builtin.unrealized_conversion_cast %arg21 : index to i64
            %73 = emitc.cast %72 : i64 to i32
            %74:6 = scf.for %arg28 = %c0 to %12 step %c1 iter_args(%arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26, %arg34 = %arg27) -> (i32, i32, i32, i32, i32, f32) {
              %75 = builtin.unrealized_conversion_cast %arg28 : index to i64
              %76 = emitc.cast %75 : i64 to i32
              %77 = arith.muli %76, %arg17 : i32
              %78 = arith.addi %61, %77 : i32
              %79 = arith.addi %64, %78 : i32
              %80 = arith.muli %79, %arg7 : i32
              %81 = arith.addi %66, %76 : i32
              %82 = arith.muli %81, %arg12 : i32
              %83 = arith.muli %arg28, %5 : index
              %84 = arith.addi %83, %69 : index
              %85 = arith.cmpi sge, %84, %c0 : index
              %86 = arith.muli %83, %c-1 : index
              %87 = arith.subi %86, %44 : index
              %88 = arith.addi %87, %6 : index
              %89 = arith.addi %88, %4 : index
              %90 = arith.addi %89, %c-1 : index
              %91 = arith.cmpi sge, %90, %c0 : index
              %92:6 = scf.for %arg35 = %c0 to %13 step %c1 iter_args(%arg36 = %arg29, %arg37 = %arg30, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33, %arg41 = %arg34) -> (i32, i32, i32, i32, i32, f32) {
                %93 = builtin.unrealized_conversion_cast %arg35 : index to i64
                %94 = emitc.cast %93 : i64 to i32
                %95 = arith.muli %94, %arg18 : i32
                %96 = arith.addi %62, %95 : i32
                %97 = arith.muli %arg35, %2 : index
                %98 = arith.muli %97, %c-1 : index
                %99 = arith.subi %98, %35 : index
                %100 = arith.addi %99, %3 : index
                %101 = arith.addi %100, %1 : index
                %102 = arith.addi %101, %c-1 : index
                %103 = arith.cmpi sge, %102, %c0 : index
                %104 = arith.addi %97, %68 : index
                %105 = arith.cmpi sge, %104, %c0 : index
                %106 = arith.andi %103, %105 : i1
                %107 = arith.andi %106, %85 : i1
                %108 = arith.andi %107, %91 : i1
                %109:6 = scf.if %108 -> (i32, i32, i32, i32, i32, f32) {
                  %110 = arith.addi %80, %96 : i32
                  %111 = arith.addi %82, %94 : i32
                  %112:4 = scf.while (%arg42 = %arg36, %arg43 = %arg37, %arg44 = %c0_i32, %arg45 = %arg41) : (i32, i32, i32, f32) -> (i32, i32, i32, f32) {
                    %113 = arith.cmpi slt, %arg44, %c4_i32 : i32
                    %114 = arith.addi %73, %arg44 : i32
                    %115 = arith.cmpi slt, %114, %60 : i32
                    %116 = arith.andi %113, %115 : i1
                    scf.condition(%116) %arg42, %arg43, %arg44, %arg45 : i32, i32, i32, f32
                  } do {
                  ^bb0(%arg42: i32, %arg43: i32, %arg44: i32, %arg45: f32):
                    %113 = arith.addi %73, %arg44 : i32
                    %114 = arith.muli %113, %arg6 : i32
                    %115 = arith.muli %114, %arg7 : i32
                    %116 = arith.addi %110, %115 : i32
                    %117 = arith.muli %arg44, %arg11 : i32
                    %118 = arith.muli %117, %arg12 : i32
                    %119 = arith.addi %111, %118 : i32
                    %120 = emitc.cast %116 : i32 to index
                    %121 = memref.load %arg0[%120] : memref<?xf32>
                    %122 = emitc.cast %119 : i32 to index
                    %123 = memref.load %arg1[%122] : memref<?xf32>
                    %124 = emitc.mul %121, %123 : (f32, f32) -> f32
                    %125 = emitc.add %arg45, %124 : (f32, f32) -> f32
                    %126 = arith.addi %arg44, %c1_i32 : i32
                    scf.yield %119, %116, %126, %125 : i32, i32, i32, f32
                  }
                  scf.yield %112#0, %112#1, %112#2, %111, %110, %112#3 : i32, i32, i32, i32, i32, f32
                } else {
                  scf.yield %arg36, %arg37, %arg38, %arg39, %arg40, %arg41 : i32, i32, i32, i32, i32, f32
                }
                scf.yield %109#0, %109#1, %109#2, %109#3, %109#4, %109#5 : i32, i32, i32, i32, i32, f32
              }
              scf.yield %92#0, %92#1, %92#2, %92#3, %92#4, %92#5 : i32, i32, i32, i32, i32, f32
            }
            scf.yield %74#0, %74#1, %74#2, %74#3, %74#4, %74#5 : i32, i32, i32, i32, i32, f32
          }
          %71 = arith.addi %57, %40 : index
          memref.store %70#5, %arg3[%71] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU: end

[ict-debug] driver.cc: Before convert to EmitC dialect:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii_0 {
    gpu.func @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) {
      %c32_i32 = arith.constant 32 : i32
      %c32 = arith.constant 32 : index
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %c4 = arith.constant 4 : index
      %c-1 = arith.constant -1 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c0_i32 = arith.constant 0 : i32
      %c4_i32 = arith.constant 4 : i32
      %c1_i32 = arith.constant 1 : i32
      %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.ptr
      %1 = emitc.cast %arg7 : i32 to index
      %2 = emitc.cast %arg18 : i32 to index
      %3 = emitc.cast %arg16 : i32 to index
      %4 = emitc.cast %arg6 : i32 to index
      %5 = emitc.cast %arg17 : i32 to index
      %6 = emitc.cast %arg15 : i32 to index
      %7 = emitc.cast %arg19 : i32 to index
      %8 = emitc.cast %arg5 : i32 to index
      %9 = arith.subi %c-1, %8 : index
      %10 = arith.cmpi slt, %8, %c0 : index
      %11 = arith.select %10, %9, %8 : index
      %12 = emitc.cast %arg11 : i32 to index
      %13 = emitc.cast %arg12 : i32 to index
      %14 = emitc.cast %arg10 : i32 to index
      %15 = llvm.mlir.undef : i32
      %16 = "npu.block_id"() : () -> i64
      %17 = emitc.cast %16 : i64 to i32
      %18 = arith.muli %17, %c32_i32 : i32
      %19 = arith.muli %arg4, %arg8 : i32
      %20 = arith.muli %19, %arg9 : i32
      %21 = arith.muli %20, %arg10 : i32
      %22 = arith.divsi %11, %7 : index
      %23 = arith.subi %c-1, %22 : index
      %24 = arith.select %10, %23, %22 : index
      %25 = arith.divsi %arg5, %arg19 : i32
      %26 = arith.divsi %arg8, %arg19 : i32
      %27 = llvm.mlir.zero : !llvm.ptr
      %28 = llvm.icmp "ne" %0, %27 : !llvm.ptr
      scf.for %arg20 = %c0 to %c32 step %c1 {
        %29 = builtin.unrealized_conversion_cast %arg20 : index to i64
        %30 = emitc.cast %29 : i64 to i32
        %31 = arith.addi %18, %30 : i32
        %32 = arith.remsi %31, %arg10 : i32
        %33 = arith.muli %32, %arg14 : i32
        %34 = emitc.cast %33 : i32 to index
        %35 = emitc.cast %31 : i32 to index
        %36 = arith.remsi %35, %14 : index
        %37 = arith.addi %36, %14 : index
        %38 = arith.cmpi slt, %36, %c0 : index
        %39 = arith.select %38, %37, %36 : index
        %40 = arith.divsi %31, %arg10 : i32
        %41 = arith.remsi %40, %arg9 : i32
        %42 = arith.muli %41, %arg13 : i32
        %43 = emitc.cast %42 : i32 to index
        %44 = arith.divsi %40, %arg9 : i32
        %45 = arith.remsi %44, %arg8 : i32
        %46 = arith.divsi %45, %26 : i32
        %47 = arith.muli %46, %25 : i32
        %48 = emitc.cast %47 : i32 to index
        %49 = emitc.cast %45 : i32 to index
        %50 = arith.divsi %44, %arg8 : i32
        %51 = arith.muli %50, %arg8 : i32
        %52 = arith.addi %51, %45 : i32
        %53 = arith.muli %52, %arg9 : i32
        %54 = arith.addi %53, %41 : i32
        %55 = arith.muli %54, %arg10 : i32
        %56 = emitc.cast %55 : i32 to index
        %57 = arith.cmpi slt, %31, %21 : i32
        scf.if %57 {
          %58 = scf.if %28 -> (f32) {
            %71 = memref.load %arg2[%49] : memref<?xf32>
            scf.yield %71 : f32
          } else {
            scf.yield %cst : f32
          }
          %59 = arith.addi %47, %25 : i32
          %60 = arith.subi %42, %arg15 : i32
          %61 = arith.subi %33, %arg16 : i32
          %62 = arith.muli %50, %arg5 : i32
          %63 = arith.muli %62, %arg6 : i32
          %64 = arith.muli %45, %25 : i32
          %65 = arith.muli %64, %arg11 : i32
          %66 = arith.addi %48, %24 : index
          %67 = arith.subi %34, %3 : index
          %68 = arith.subi %43, %6 : index
          %69:6 = scf.for %arg21 = %48 to %66 step %c4 iter_args(%arg22 = %15, %arg23 = %15, %arg24 = %15, %arg25 = %15, %arg26 = %15, %arg27 = %58) -> (i32, i32, i32, i32, i32, f32) {
            %71 = builtin.unrealized_conversion_cast %arg21 : index to i64
            %72 = emitc.cast %71 : i64 to i32
            %73:6 = scf.for %arg28 = %c0 to %12 step %c1 iter_args(%arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26, %arg34 = %arg27) -> (i32, i32, i32, i32, i32, f32) {
              %74 = builtin.unrealized_conversion_cast %arg28 : index to i64
              %75 = emitc.cast %74 : i64 to i32
              %76 = arith.muli %75, %arg17 : i32
              %77 = arith.addi %60, %76 : i32
              %78 = arith.addi %63, %77 : i32
              %79 = arith.muli %78, %arg7 : i32
              %80 = arith.addi %65, %75 : i32
              %81 = arith.muli %80, %arg12 : i32
              %82 = arith.muli %arg28, %5 : index
              %83 = arith.addi %82, %68 : index
              %84 = arith.cmpi sge, %83, %c0 : index
              %85 = arith.muli %82, %c-1 : index
              %86 = arith.subi %85, %43 : index
              %87 = arith.addi %86, %6 : index
              %88 = arith.addi %87, %4 : index
              %89 = arith.addi %88, %c-1 : index
              %90 = arith.cmpi sge, %89, %c0 : index
              %91:6 = scf.for %arg35 = %c0 to %13 step %c1 iter_args(%arg36 = %arg29, %arg37 = %arg30, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33, %arg41 = %arg34) -> (i32, i32, i32, i32, i32, f32) {
                %92 = builtin.unrealized_conversion_cast %arg35 : index to i64
                %93 = emitc.cast %92 : i64 to i32
                %94 = arith.muli %93, %arg18 : i32
                %95 = arith.addi %61, %94 : i32
                %96 = arith.muli %arg35, %2 : index
                %97 = arith.muli %96, %c-1 : index
                %98 = arith.subi %97, %34 : index
                %99 = arith.addi %98, %3 : index
                %100 = arith.addi %99, %1 : index
                %101 = arith.addi %100, %c-1 : index
                %102 = arith.cmpi sge, %101, %c0 : index
                %103 = arith.addi %96, %67 : index
                %104 = arith.cmpi sge, %103, %c0 : index
                %105 = arith.andi %102, %104 : i1
                %106 = arith.andi %105, %84 : i1
                %107 = arith.andi %106, %90 : i1
                %108:6 = scf.if %107 -> (i32, i32, i32, i32, i32, f32) {
                  %109 = arith.addi %79, %95 : i32
                  %110 = arith.addi %81, %93 : i32
                  %111:4 = scf.while (%arg42 = %arg36, %arg43 = %arg37, %arg44 = %c0_i32, %arg45 = %arg41) : (i32, i32, i32, f32) -> (i32, i32, i32, f32) {
                    %112 = arith.cmpi slt, %arg44, %c4_i32 : i32
                    %113 = arith.addi %72, %arg44 : i32
                    %114 = arith.cmpi slt, %113, %59 : i32
                    %115 = arith.andi %112, %114 : i1
                    scf.condition(%115) %arg42, %arg43, %arg44, %arg45 : i32, i32, i32, f32
                  } do {
                  ^bb0(%arg42: i32, %arg43: i32, %arg44: i32, %arg45: f32):
                    %112 = arith.addi %72, %arg44 : i32
                    %113 = arith.muli %112, %arg6 : i32
                    %114 = arith.muli %113, %arg7 : i32
                    %115 = arith.addi %109, %114 : i32
                    %116 = arith.muli %arg44, %arg11 : i32
                    %117 = arith.muli %116, %arg12 : i32
                    %118 = arith.addi %110, %117 : i32
                    %119 = emitc.cast %115 : i32 to index
                    %120 = memref.load %arg0[%119] : memref<?xf32>
                    %121 = emitc.cast %118 : i32 to index
                    %122 = memref.load %arg1[%121] : memref<?xf32>
                    %123 = emitc.mul %120, %122 : (f32, f32) -> f32
                    %124 = emitc.add %arg45, %123 : (f32, f32) -> f32
                    %125 = arith.addi %arg44, %c1_i32 : i32
                    scf.yield %118, %115, %125, %124 : i32, i32, i32, f32
                  }
                  scf.yield %111#0, %111#1, %111#2, %110, %109, %111#3 : i32, i32, i32, i32, i32, f32
                } else {
                  scf.yield %arg36, %arg37, %arg38, %arg39, %arg40, %arg41 : i32, i32, i32, i32, i32, f32
                }
                scf.yield %108#0, %108#1, %108#2, %108#3, %108#4, %108#5 : i32, i32, i32, i32, i32, f32
              }
              scf.yield %91#0, %91#1, %91#2, %91#3, %91#4, %91#5 : i32, i32, i32, i32, i32, f32
            }
            scf.yield %73#0, %73#1, %73#2, %73#3, %73#4, %73#5 : i32, i32, i32, i32, i32, f32
          }
          %70 = arith.addi %56, %39 : index
          memref.store %69#5, %arg3[%70] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: Before convert to EmitC dialect: end

[ict-debug] driver.cc: After convert to EmitC dialect:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii_0 {
    gpu.func @_Z18conv2d_cuda_kernelPKfS0_S0_Pfiiiiiiiiiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32, %arg12: i32, %arg13: i32, %arg14: i32, %arg15: i32, %arg16: i32, %arg17: i32, %arg18: i32, %arg19: i32) {
      %c32_i32 = arith.constant 32 : i32
      %c32 = arith.constant 32 : index
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %c4 = arith.constant 4 : index
      %c-1 = arith.constant -1 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c0_i32 = arith.constant 0 : i32
      %c4_i32 = arith.constant 4 : i32
      %c1_i32 = arith.constant 1 : i32
      %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.ptr
      %1 = emitc.cast %arg7 : i32 to index
      %2 = emitc.cast %arg18 : i32 to index
      %3 = emitc.cast %arg16 : i32 to index
      %4 = emitc.cast %arg6 : i32 to index
      %5 = emitc.cast %arg17 : i32 to index
      %6 = emitc.cast %arg15 : i32 to index
      %7 = emitc.cast %arg19 : i32 to index
      %8 = emitc.cast %arg5 : i32 to index
      %9 = arith.subi %c-1, %8 : index
      %10 = arith.cmpi slt, %8, %c0 : index
      %11 = arith.select %10, %9, %8 : index
      %12 = emitc.cast %arg11 : i32 to index
      %13 = emitc.cast %arg12 : i32 to index
      %14 = emitc.cast %arg10 : i32 to index
      %15 = llvm.mlir.undef : i32
      %16 = "npu.block_id"() : () -> i64
      %17 = emitc.cast %16 : i64 to i32
      %18 = arith.muli %17, %c32_i32 : i32
      %19 = arith.muli %arg4, %arg8 : i32
      %20 = arith.muli %19, %arg9 : i32
      %21 = arith.muli %20, %arg10 : i32
      %22 = arith.divsi %11, %7 : index
      %23 = arith.subi %c-1, %22 : index
      %24 = arith.select %10, %23, %22 : index
      %25 = arith.divsi %arg5, %arg19 : i32
      %26 = arith.divsi %arg8, %arg19 : i32
      %27 = llvm.mlir.zero : !llvm.ptr
      %28 = llvm.icmp "ne" %0, %27 : !llvm.ptr
      scf.for %arg20 = %c0 to %c32 step %c1 {
        %29 = builtin.unrealized_conversion_cast %arg20 : index to i64
        %30 = emitc.cast %29 : i64 to i32
        %31 = arith.addi %18, %30 : i32
        %32 = arith.remsi %31, %arg10 : i32
        %33 = arith.muli %32, %arg14 : i32
        %34 = emitc.cast %33 : i32 to index
        %35 = emitc.cast %31 : i32 to index
        %36 = arith.remsi %35, %14 : index
        %37 = arith.addi %36, %14 : index
        %38 = arith.cmpi slt, %36, %c0 : index
        %39 = arith.select %38, %37, %36 : index
        %40 = arith.divsi %31, %arg10 : i32
        %41 = arith.remsi %40, %arg9 : i32
        %42 = arith.muli %41, %arg13 : i32
        %43 = emitc.cast %42 : i32 to index
        %44 = arith.divsi %40, %arg9 : i32
        %45 = arith.remsi %44, %arg8 : i32
        %46 = arith.divsi %45, %26 : i32
        %47 = arith.muli %46, %25 : i32
        %48 = emitc.cast %47 : i32 to index
        %49 = emitc.cast %45 : i32 to index
        %50 = arith.divsi %44, %arg8 : i32
        %51 = arith.muli %50, %arg8 : i32
        %52 = arith.addi %51, %45 : i32
        %53 = arith.muli %52, %arg9 : i32
        %54 = arith.addi %53, %41 : i32
        %55 = arith.muli %54, %arg10 : i32
        %56 = emitc.cast %55 : i32 to index
        %57 = arith.cmpi slt, %31, %21 : i32
        emitc.if %57 {
          %58 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> f32
          emitc.if %28 {
            %71 = memref.load %arg2[%49] : memref<?xf32>
            emitc.assign %71 : f32 to %58 : f32
          } else {
            emitc.assign %cst : f32 to %58 : f32
          }
          %59 = arith.addi %47, %25 : i32
          %60 = arith.subi %42, %arg15 : i32
          %61 = arith.subi %33, %arg16 : i32
          %62 = arith.muli %50, %arg5 : i32
          %63 = arith.muli %62, %arg6 : i32
          %64 = arith.muli %45, %25 : i32
          %65 = arith.muli %64, %arg11 : i32
          %66 = arith.addi %48, %24 : index
          %67 = arith.subi %34, %3 : index
          %68 = arith.subi %43, %6 : index
          %69:6 = scf.for %arg21 = %48 to %66 step %c4 iter_args(%arg22 = %15, %arg23 = %15, %arg24 = %15, %arg25 = %15, %arg26 = %15, %arg27 = %58) -> (i32, i32, i32, i32, i32, f32) {
            %71 = builtin.unrealized_conversion_cast %arg21 : index to i64
            %72 = emitc.cast %71 : i64 to i32
            %73:6 = scf.for %arg28 = %c0 to %12 step %c1 iter_args(%arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26, %arg34 = %arg27) -> (i32, i32, i32, i32, i32, f32) {
              %74 = builtin.unrealized_conversion_cast %arg28 : index to i64
              %75 = emitc.cast %74 : i64 to i32
              %76 = arith.muli %75, %arg17 : i32
              %77 = arith.addi %60, %76 : i32
              %78 = arith.addi %63, %77 : i32
              %79 = arith.muli %78, %arg7 : i32
              %80 = arith.addi %65, %75 : i32
              %81 = arith.muli %80, %arg12 : i32
              %82 = arith.muli %arg28, %5 : index
              %83 = arith.addi %82, %68 : index
              %84 = arith.cmpi sge, %83, %c0 : index
              %85 = arith.muli %82, %c-1 : index
              %86 = arith.subi %85, %43 : index
              %87 = arith.addi %86, %6 : index
              %88 = arith.addi %87, %4 : index
              %89 = arith.addi %88, %c-1 : index
              %90 = arith.cmpi sge, %89, %c0 : index
              %91:6 = scf.for %arg35 = %c0 to %13 step %c1 iter_args(%arg36 = %arg29, %arg37 = %arg30, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33, %arg41 = %arg34) -> (i32, i32, i32, i32, i32, f32) {
                %92 = builtin.unrealized_conversion_cast %arg35 : index to i64
                %93 = emitc.cast %92 : i64 to i32
                %94 = arith.muli %93, %arg18 : i32
                %95 = arith.addi %61, %94 : i32
                %96 = arith.muli %arg35, %2 : index
                %97 = arith.muli %96, %c-1 : index
                %98 = arith.subi %97, %34 : index
                %99 = arith.addi %98, %3 : index
                %100 = arith.addi %99, %1 : index
                %101 = arith.addi %100, %c-1 : index
                %102 = arith.cmpi sge, %101, %c0 : index
                %103 = arith.addi %96, %67 : index
                %104 = arith.cmpi sge, %103, %c0 : index
                %105 = arith.andi %102, %104 : i1
                %106 = arith.andi %105, %84 : i1
                %107 = arith.andi %106, %90 : i1
                %108 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> i32
                %109 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> i32
                %110 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> i32
                %111 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> i32
                %112 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> i32
                %113 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> f32
                emitc.if %107 {
                  %114 = arith.addi %79, %95 : i32
                  %115 = arith.addi %81, %93 : i32
                  %116:4 = scf.while (%arg42 = %arg36, %arg43 = %arg37, %arg44 = %c0_i32, %arg45 = %arg41) : (i32, i32, i32, f32) -> (i32, i32, i32, f32) {
                    %117 = arith.cmpi slt, %arg44, %c4_i32 : i32
                    %118 = arith.addi %72, %arg44 : i32
                    %119 = arith.cmpi slt, %118, %59 : i32
                    %120 = arith.andi %117, %119 : i1
                    scf.condition(%120) %arg42, %arg43, %arg44, %arg45 : i32, i32, i32, f32
                  } do {
                  ^bb0(%arg42: i32, %arg43: i32, %arg44: i32, %arg45: f32):
                    %117 = arith.addi %72, %arg44 : i32
                    %118 = arith.muli %117, %arg6 : i32
                    %119 = arith.muli %118, %arg7 : i32
                    %120 = arith.addi %114, %119 : i32
                    %121 = arith.muli %arg44, %arg11 : i32
                    %122 = arith.muli %121, %arg12 : i32
                    %123 = arith.addi %115, %122 : i32
                    %124 = emitc.cast %120 : i32 to index
                    %125 = memref.load %arg0[%124] : memref<?xf32>
                    %126 = emitc.cast %123 : i32 to index
                    %127 = memref.load %arg1[%126] : memref<?xf32>
                    %128 = emitc.mul %125, %127 : (f32, f32) -> f32
                    %129 = emitc.add %arg45, %128 : (f32, f32) -> f32
                    %130 = arith.addi %arg44, %c1_i32 : i32
                    scf.yield %123, %120, %130, %129 : i32, i32, i32, f32
                  }
                  emitc.assign %116#0 : i32 to %108 : i32
                  emitc.assign %116#1 : i32 to %109 : i32
                  emitc.assign %116#2 : i32 to %110 : i32
                  emitc.assign %115 : i32 to %111 : i32
                  emitc.assign %114 : i32 to %112 : i32
                  emitc.assign %116#3 : f32 to %113 : f32
                } else {
                  emitc.assign %arg36 : i32 to %108 : i32
                  emitc.assign %arg37 : i32 to %109 : i32
                  emitc.assign %arg38 : i32 to %110 : i32
                  emitc.assign %arg39 : i32 to %111 : i32
                  emitc.assign %arg40 : i32 to %112 : i32
                  emitc.assign %arg41 : f32 to %113 : f32
                }
                scf.yield %108, %109, %110, %111, %112, %113 : i32, i32, i32, i32, i32, f32
              }
              scf.yield %91#0, %91#1, %91#2, %91#3, %91#4, %91#5 : i32, i32, i32, i32, i32, f32
            }
            scf.yield %73#0, %73#1, %73#2, %73#3, %73#4, %73#5 : i32, i32, i32, i32, i32, f32
          }
          %70 = arith.addi %56, %39 : index
          memref.store %69#5, %arg3[%70] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: After convert to EmitC dialect: end

loc("./cuda_ops/56_conv_standard_2D__asymmetric_input__asymmetric_kernel.cu":62:5): error: 'llvm.mlir.undef' op unable to find printer for op
[ict-debug] driver.cc: After emitc::translateToCpp:

