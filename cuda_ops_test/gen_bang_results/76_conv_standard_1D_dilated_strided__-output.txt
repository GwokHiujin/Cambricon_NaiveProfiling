warning: CUDA version 12.1 is only partially supported
warning: CUDA version 12.1 is only partially supported
[ict-debug] driver.cc: After return 5, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z28__device_stub__conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    call @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6, %arg7, %arg8, %arg9, %arg10, %arg11) : (memref<?xf32>, memref<?xf32>, memref<?xf32>, memref<?xf32>, i32, i32, i32, i32, i32, i32, i32, i32) -> ()
    return
  }
  func.func private @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c-1_i32 = arith.constant -1 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %0 = arith.index_cast %arg6 : i32 to index
    %1 = arith.index_cast %arg11 : i32 to index
    %2 = arith.muli %arg5, %arg6 : i32
    %3 = arith.index_cast %arg8 : i32 to index
    %4 = arith.muli %arg5, %arg8 : i32
    %5 = arith.index_cast %arg6 : i32 to index
    %6 = arith.index_cast %arg11 : i32 to index
    %7 = arith.muli %arg5, %arg6 : i32
    %8 = arith.index_cast %arg8 : i32 to index
    %9 = arith.muli %arg5, %arg8 : i32
    %10 = arith.index_cast %arg5 : i32 to index
    %11 = arith.index_cast %arg8 : i32 to index
    %12 = arith.index_cast %arg9 : i32 to index
    %13 = arith.muli %arg7, %arg9 : i32
    %14 = gpu.block_id  x
    %15 = arith.index_cast %14 : index to i32
    %16 = gpu.block_dim  x
    %17 = arith.index_cast %16 : index to i32
    %18 = arith.muli %15, %17 : i32
    %19 = gpu.thread_id  x
    %20 = arith.index_cast %19 : index to i32
    %21 = arith.addi %18, %20 : i32
    %22 = arith.remsi %21, %arg9 : i32
    %23 = arith.muli %22, %arg10 : i32
    %24 = arith.index_cast %23 : i32 to index
    %25 = arith.index_cast %23 : i32 to index
    %26 = arith.index_cast %21 : i32 to index
    %27 = arith.divsi %21, %arg9 : i32
    %28 = arith.remsi %27, %arg7 : i32
    %29 = arith.muli %28, %4 : i32
    %30 = arith.index_cast %29 : i32 to index
    %31 = arith.muli %28, %9 : i32
    %32 = arith.index_cast %31 : i32 to index
    %33 = arith.index_cast %28 : i32 to index
    %34 = arith.muli %28, %arg9 : i32
    %35 = arith.index_cast %34 : i32 to index
    %36 = arith.divsi %27, %arg7 : i32
    %37 = arith.muli %36, %2 : i32
    %38 = arith.index_cast %37 : i32 to index
    %39 = arith.muli %36, %7 : i32
    %40 = arith.index_cast %39 : i32 to index
    %41 = arith.muli %36, %13 : i32
    %42 = arith.index_cast %41 : i32 to index
    %43 = arith.muli %arg4, %arg7 : i32
    %44 = arith.muli %43, %arg9 : i32
    %45 = arith.cmpi slt, %21, %44 : i32
    scf.if %45 {
      %46 = arith.addi %arg8, %c-1_i32 : i32
      %47 = arith.muli %46, %arg11 : i32
      %48 = arith.addi %23, %47 : i32
      %49 = arith.cmpi slt, %48, %arg6 : i32
      %50 = scf.if %49 -> (f32) {
        %55 = affine.for %arg12 = 0 to %10 iter_args(%arg13 = %cst) -> (f32) {
          %56 = affine.for %arg14 = 0 to %11 iter_args(%arg15 = %arg13) -> (f32) {
            %57 = affine.load %arg0[%arg14 * symbol(%1) + %arg12 * symbol(%0) + symbol(%24) + symbol(%38)] : memref<?xf32>
            %58 = affine.load %arg1[%arg14 + %arg12 * symbol(%3) + symbol(%30)] : memref<?xf32>
            %59 = arith.mulf %57, %58 : f32
            %60 = arith.addf %arg15, %59 : f32
            affine.yield %60 : f32
          }
          affine.yield %56 : f32
        }
        scf.yield %55 : f32
      } else {
        %55 = affine.for %arg12 = 0 to %10 iter_args(%arg13 = %cst) -> (f32) {
          %56 = affine.for %arg14 = 0 to %11 iter_args(%arg15 = %arg13) -> (f32) {
            %57 = arith.index_cast %arg14 : index to i32
            %58 = arith.muli %57, %arg11 : i32
            %59 = arith.addi %23, %58 : i32
            %60 = arith.cmpi slt, %59, %arg6 : i32
            %61 = arith.extui %60 : i1 to i32
            %62 = arith.sitofp %61 : i32 to f32
            %63 = affine.load %arg0[%arg14 * symbol(%6) + symbol(%25) + %arg12 * symbol(%5) + symbol(%40)] : memref<?xf32>
            %64 = arith.mulf %62, %63 : f32
            %65 = affine.load %arg1[%arg14 + %arg12 * symbol(%8) + symbol(%32)] : memref<?xf32>
            %66 = arith.mulf %64, %65 : f32
            %67 = arith.addf %arg15, %66 : f32
            affine.yield %67 : f32
          }
          affine.yield %56 : f32
        }
        scf.yield %55 : f32
      }
      %51 = llvm.mlir.zero : !llvm.ptr
      %52 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %53 = llvm.icmp "ne" %52, %51 : !llvm.ptr
      %54 = scf.if %53 -> (f32) {
        %55 = affine.load %arg2[symbol(%33)] : memref<?xf32>
        %56 = arith.addf %50, %55 : f32
        scf.yield %56 : f32
      } else {
        scf.yield %50 : f32
      }
      affine.store %54, %arg3[symbol(%42) + symbol(%35) + symbol(%26) mod symbol(%12)] : memref<?xf32>
    }
    return
  }
}
[ict-debug] driver.cc: After return 5, module: end

[ict-debug] driver.cc: After return 6, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c-1_i32 = arith.constant -1 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %0 = arith.index_cast %arg6 : i32 to index
    %1 = arith.index_cast %arg11 : i32 to index
    %2 = arith.muli %arg5, %arg6 : i32
    %3 = arith.index_cast %arg8 : i32 to index
    %4 = arith.muli %arg5, %arg8 : i32
    %5 = arith.index_cast %arg5 : i32 to index
    %6 = arith.index_cast %arg9 : i32 to index
    %7 = arith.muli %arg7, %arg9 : i32
    %8 = gpu.block_id  x
    %9 = arith.index_cast %8 : index to i32
    %10 = gpu.block_dim  x
    %11 = arith.index_cast %10 : index to i32
    %12 = arith.muli %9, %11 : i32
    %13 = gpu.thread_id  x
    %14 = arith.index_cast %13 : index to i32
    %15 = arith.addi %12, %14 : i32
    %16 = arith.remsi %15, %arg9 : i32
    %17 = arith.muli %16, %arg10 : i32
    %18 = arith.index_cast %17 : i32 to index
    %19 = arith.index_cast %15 : i32 to index
    %20 = arith.remsi %19, %6 : index
    %21 = arith.addi %20, %6 : index
    %22 = arith.cmpi slt, %20, %c0 : index
    %23 = arith.select %22, %21, %20 : index
    %24 = arith.divsi %15, %arg9 : i32
    %25 = arith.remsi %24, %arg7 : i32
    %26 = arith.muli %25, %4 : i32
    %27 = arith.index_cast %26 : i32 to index
    %28 = arith.index_cast %25 : i32 to index
    %29 = arith.muli %25, %arg9 : i32
    %30 = arith.index_cast %29 : i32 to index
    %31 = arith.divsi %24, %arg7 : i32
    %32 = arith.muli %31, %2 : i32
    %33 = arith.index_cast %32 : i32 to index
    %34 = arith.muli %31, %7 : i32
    %35 = arith.index_cast %34 : i32 to index
    %36 = arith.muli %arg4, %arg7 : i32
    %37 = arith.muli %36, %arg9 : i32
    %38 = arith.cmpi slt, %15, %37 : i32
    scf.if %38 {
      %39 = arith.addi %arg8, %c-1_i32 : i32
      %40 = arith.muli %39, %arg11 : i32
      %41 = arith.addi %17, %40 : i32
      %42 = arith.cmpi slt, %41, %arg6 : i32
      %43 = scf.if %42 -> (f32) {
        %48 = affine.for %arg12 = 0 to %5 iter_args(%arg13 = %cst) -> (f32) {
          %49 = affine.for %arg14 = 0 to %3 iter_args(%arg15 = %arg13) -> (f32) {
            %50 = affine.load %arg0[%arg14 * symbol(%1) + %arg12 * symbol(%0) + symbol(%18) + symbol(%33)] : memref<?xf32>
            %51 = affine.load %arg1[%arg14 + %arg12 * symbol(%3) + symbol(%27)] : memref<?xf32>
            %52 = arith.mulf %50, %51 : f32
            %53 = arith.addf %arg15, %52 : f32
            affine.yield %53 : f32
          }
          affine.yield %49 : f32
        }
        scf.yield %48 : f32
      } else {
        %48 = affine.for %arg12 = 0 to %5 iter_args(%arg13 = %cst) -> (f32) {
          %49 = affine.for %arg14 = 0 to %3 iter_args(%arg15 = %arg13) -> (f32) {
            %50 = arith.index_cast %arg14 : index to i32
            %51 = arith.muli %50, %arg11 : i32
            %52 = arith.addi %17, %51 : i32
            %53 = arith.cmpi slt, %52, %arg6 : i32
            %54 = arith.extui %53 : i1 to i32
            %55 = arith.sitofp %54 : i32 to f32
            %56 = affine.load %arg0[%arg12 * symbol(%0) + %arg14 * symbol(%1) + symbol(%18) + symbol(%33)] : memref<?xf32>
            %57 = arith.mulf %55, %56 : f32
            %58 = affine.load %arg1[%arg14 + %arg12 * symbol(%3) + symbol(%27)] : memref<?xf32>
            %59 = arith.mulf %57, %58 : f32
            %60 = arith.addf %arg15, %59 : f32
            affine.yield %60 : f32
          }
          affine.yield %49 : f32
        }
        scf.yield %48 : f32
      }
      %44 = llvm.mlir.zero : !llvm.ptr
      %45 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %46 = llvm.icmp "ne" %45, %44 : !llvm.ptr
      %47 = scf.if %46 -> (f32) {
        %48 = affine.load %arg2[symbol(%28)] : memref<?xf32>
        %49 = arith.addf %43, %48 : f32
        scf.yield %49 : f32
      } else {
        scf.yield %43 : f32
      }
      affine.store %47, %arg3[symbol(%35) + symbol(%30) + symbol(%23)] : memref<?xf32>
    }
    return
  }
}
[ict-debug] driver.cc: After return 6, module: end

WrapAndReplaceBarrierPass::runOnOperation(): before execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %c-1_i32 = arith.constant -1 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %0 = arith.index_cast %arg6 : i32 to index
    %1 = arith.index_cast %arg11 : i32 to index
    %2 = arith.muli %arg5, %arg6 : i32
    %3 = arith.index_cast %arg8 : i32 to index
    %4 = arith.muli %arg5, %arg8 : i32
    %5 = arith.index_cast %arg5 : i32 to index
    %6 = arith.index_cast %arg9 : i32 to index
    %7 = arith.muli %arg7, %arg9 : i32
    %8 = gpu.block_id  x
    %9 = arith.index_cast %8 : index to i32
    %10 = gpu.block_dim  x
    %11 = arith.index_cast %10 : index to i32
    %12 = arith.muli %9, %11 : i32
    %13 = gpu.thread_id  x
    %14 = arith.index_cast %13 : index to i32
    %15 = arith.addi %12, %14 : i32
    %16 = arith.remsi %15, %arg9 : i32
    %17 = arith.muli %16, %arg10 : i32
    %18 = arith.index_cast %17 : i32 to index
    %19 = arith.index_cast %15 : i32 to index
    %20 = arith.remsi %19, %6 : index
    %21 = arith.addi %20, %6 : index
    %22 = arith.cmpi slt, %20, %c0 : index
    %23 = arith.select %22, %21, %20 : index
    %24 = arith.divsi %15, %arg9 : i32
    %25 = arith.remsi %24, %arg7 : i32
    %26 = arith.muli %25, %4 : i32
    %27 = arith.index_cast %26 : i32 to index
    %28 = arith.index_cast %25 : i32 to index
    %29 = arith.muli %25, %arg9 : i32
    %30 = arith.index_cast %29 : i32 to index
    %31 = arith.divsi %24, %arg7 : i32
    %32 = arith.muli %31, %2 : i32
    %33 = arith.index_cast %32 : i32 to index
    %34 = arith.muli %31, %7 : i32
    %35 = arith.index_cast %34 : i32 to index
    %36 = arith.muli %arg4, %arg7 : i32
    %37 = arith.muli %36, %arg9 : i32
    %38 = arith.cmpi slt, %15, %37 : i32
    scf.if %38 {
      %39 = arith.addi %arg8, %c-1_i32 : i32
      %40 = arith.muli %39, %arg11 : i32
      %41 = arith.addi %17, %40 : i32
      %42 = arith.cmpi slt, %41, %arg6 : i32
      %43 = scf.if %42 -> (f32) {
        %50 = scf.for %arg12 = %c0 to %5 step %c1 iter_args(%arg13 = %cst) -> (f32) {
          %51 = scf.for %arg14 = %c0 to %3 step %c1 iter_args(%arg15 = %arg13) -> (f32) {
            %52 = arith.muli %arg14, %1 : index
            %53 = arith.muli %arg12, %0 : index
            %54 = arith.addi %52, %53 : index
            %55 = arith.addi %54, %18 : index
            %56 = arith.addi %55, %33 : index
            %57 = memref.load %arg0[%56] : memref<?xf32>
            %58 = arith.muli %arg12, %3 : index
            %59 = arith.addi %arg14, %58 : index
            %60 = arith.addi %59, %27 : index
            %61 = memref.load %arg1[%60] : memref<?xf32>
            %62 = arith.mulf %57, %61 : f32
            %63 = arith.addf %arg15, %62 : f32
            scf.yield %63 : f32
          }
          scf.yield %51 : f32
        }
        scf.yield %50 : f32
      } else {
        %50 = scf.for %arg12 = %c0 to %5 step %c1 iter_args(%arg13 = %cst) -> (f32) {
          %51 = scf.for %arg14 = %c0 to %3 step %c1 iter_args(%arg15 = %arg13) -> (f32) {
            %52 = arith.index_cast %arg14 : index to i32
            %53 = arith.muli %52, %arg11 : i32
            %54 = arith.addi %17, %53 : i32
            %55 = arith.cmpi slt, %54, %arg6 : i32
            %56 = arith.extui %55 : i1 to i32
            %57 = arith.sitofp %56 : i32 to f32
            %58 = arith.muli %arg12, %0 : index
            %59 = arith.muli %arg14, %1 : index
            %60 = arith.addi %58, %59 : index
            %61 = arith.addi %60, %18 : index
            %62 = arith.addi %61, %33 : index
            %63 = memref.load %arg0[%62] : memref<?xf32>
            %64 = arith.mulf %57, %63 : f32
            %65 = arith.muli %arg12, %3 : index
            %66 = arith.addi %arg14, %65 : index
            %67 = arith.addi %66, %27 : index
            %68 = memref.load %arg1[%67] : memref<?xf32>
            %69 = arith.mulf %64, %68 : f32
            %70 = arith.addf %arg15, %69 : f32
            scf.yield %70 : f32
          }
          scf.yield %51 : f32
        }
        scf.yield %50 : f32
      }
      %44 = llvm.mlir.zero : !llvm.ptr
      %45 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %46 = llvm.icmp "ne" %45, %44 : !llvm.ptr
      %47 = scf.if %46 -> (f32) {
        %50 = memref.load %arg2[%28] : memref<?xf32>
        %51 = arith.addf %43, %50 : f32
        scf.yield %51 : f32
      } else {
        scf.yield %43 : f32
      }
      %48 = arith.addi %35, %30 : index
      %49 = arith.addi %48, %23 : index
      memref.store %47, %arg3[%49] : memref<?xf32>
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): before execute: end
WrapAndReplaceBarrierPass::runOnOperation(): after execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg12) = (%c0) to (%c32) step (%c1) {
      %c1_0 = arith.constant 1 : index
      %c0_1 = arith.constant 0 : index
      %c-1_i32 = arith.constant -1 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %0 = arith.index_cast %arg6 : i32 to index
      %1 = arith.index_cast %arg11 : i32 to index
      %2 = arith.muli %arg5, %arg6 : i32
      %3 = arith.index_cast %arg8 : i32 to index
      %4 = arith.muli %arg5, %arg8 : i32
      %5 = arith.index_cast %arg5 : i32 to index
      %6 = arith.index_cast %arg9 : i32 to index
      %7 = arith.muli %arg7, %arg9 : i32
      %8 = gpu.block_id  x
      %9 = arith.index_cast %8 : index to i32
      %10 = gpu.block_dim  x
      %11 = arith.index_cast %10 : index to i32
      %12 = arith.muli %9, %11 : i32
      %13 = arith.index_cast %arg12 : index to i32
      %14 = arith.addi %12, %13 : i32
      %15 = arith.remsi %14, %arg9 : i32
      %16 = arith.muli %15, %arg10 : i32
      %17 = arith.index_cast %16 : i32 to index
      %18 = arith.index_cast %14 : i32 to index
      %19 = arith.remsi %18, %6 : index
      %20 = arith.addi %19, %6 : index
      %21 = arith.cmpi slt, %19, %c0_1 : index
      %22 = arith.select %21, %20, %19 : index
      %23 = arith.divsi %14, %arg9 : i32
      %24 = arith.remsi %23, %arg7 : i32
      %25 = arith.muli %24, %4 : i32
      %26 = arith.index_cast %25 : i32 to index
      %27 = arith.index_cast %24 : i32 to index
      %28 = arith.muli %24, %arg9 : i32
      %29 = arith.index_cast %28 : i32 to index
      %30 = arith.divsi %23, %arg7 : i32
      %31 = arith.muli %30, %2 : i32
      %32 = arith.index_cast %31 : i32 to index
      %33 = arith.muli %30, %7 : i32
      %34 = arith.index_cast %33 : i32 to index
      %35 = arith.muli %arg4, %arg7 : i32
      %36 = arith.muli %35, %arg9 : i32
      %37 = arith.cmpi slt, %14, %36 : i32
      scf.if %37 {
        %38 = arith.addi %arg8, %c-1_i32 : i32
        %39 = arith.muli %38, %arg11 : i32
        %40 = arith.addi %16, %39 : i32
        %41 = arith.cmpi slt, %40, %arg6 : i32
        %42 = scf.if %41 -> (f32) {
          %49 = scf.for %arg13 = %c0_1 to %5 step %c1_0 iter_args(%arg14 = %cst) -> (f32) {
            %50 = scf.for %arg15 = %c0_1 to %3 step %c1_0 iter_args(%arg16 = %arg14) -> (f32) {
              %51 = arith.muli %arg15, %1 : index
              %52 = arith.muli %arg13, %0 : index
              %53 = arith.addi %51, %52 : index
              %54 = arith.addi %53, %17 : index
              %55 = arith.addi %54, %32 : index
              %56 = memref.load %arg0[%55] : memref<?xf32>
              %57 = arith.muli %arg13, %3 : index
              %58 = arith.addi %arg15, %57 : index
              %59 = arith.addi %58, %26 : index
              %60 = memref.load %arg1[%59] : memref<?xf32>
              %61 = arith.mulf %56, %60 : f32
              %62 = arith.addf %arg16, %61 : f32
              scf.yield %62 : f32
            }
            scf.yield %50 : f32
          }
          scf.yield %49 : f32
        } else {
          %49 = scf.for %arg13 = %c0_1 to %5 step %c1_0 iter_args(%arg14 = %cst) -> (f32) {
            %50 = scf.for %arg15 = %c0_1 to %3 step %c1_0 iter_args(%arg16 = %arg14) -> (f32) {
              %51 = arith.index_cast %arg15 : index to i32
              %52 = arith.muli %51, %arg11 : i32
              %53 = arith.addi %16, %52 : i32
              %54 = arith.cmpi slt, %53, %arg6 : i32
              %55 = arith.extui %54 : i1 to i32
              %56 = arith.sitofp %55 : i32 to f32
              %57 = arith.muli %arg13, %0 : index
              %58 = arith.muli %arg15, %1 : index
              %59 = arith.addi %57, %58 : index
              %60 = arith.addi %59, %17 : index
              %61 = arith.addi %60, %32 : index
              %62 = memref.load %arg0[%61] : memref<?xf32>
              %63 = arith.mulf %56, %62 : f32
              %64 = arith.muli %arg13, %3 : index
              %65 = arith.addi %arg15, %64 : index
              %66 = arith.addi %65, %26 : index
              %67 = memref.load %arg1[%66] : memref<?xf32>
              %68 = arith.mulf %63, %67 : f32
              %69 = arith.addf %arg16, %68 : f32
              scf.yield %69 : f32
            }
            scf.yield %50 : f32
          }
          scf.yield %49 : f32
        }
        %43 = llvm.mlir.zero : !llvm.ptr
        %44 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
        %45 = llvm.icmp "ne" %44, %43 : !llvm.ptr
        %46 = scf.if %45 -> (f32) {
          %49 = memref.load %arg2[%27] : memref<?xf32>
          %50 = arith.addf %42, %49 : f32
          scf.yield %50 : f32
        } else {
          scf.yield %42 : f32
        }
        %47 = arith.addi %34, %29 : index
        %48 = arith.addi %47, %22 : index
        memref.store %46, %arg3[%48] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): after execute: end
[ict-debug] driver.cc: After return 7, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg12) = (%c0) to (%c32) step (%c1) {
      %c1_0 = arith.constant 1 : index
      %c0_1 = arith.constant 0 : index
      %c-1_i32 = arith.constant -1 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %0 = arith.index_cast %arg6 : i32 to index
      %1 = arith.index_cast %arg11 : i32 to index
      %2 = arith.muli %arg5, %arg6 : i32
      %3 = arith.index_cast %arg8 : i32 to index
      %4 = arith.muli %arg5, %arg8 : i32
      %5 = arith.index_cast %arg5 : i32 to index
      %6 = arith.index_cast %arg9 : i32 to index
      %7 = arith.muli %arg7, %arg9 : i32
      %8 = gpu.block_id  x
      %9 = arith.index_cast %8 : index to i32
      %10 = gpu.block_dim  x
      %11 = arith.index_cast %10 : index to i32
      %12 = arith.muli %9, %11 : i32
      %13 = arith.index_cast %arg12 : index to i32
      %14 = arith.addi %12, %13 : i32
      %15 = arith.remsi %14, %arg9 : i32
      %16 = arith.muli %15, %arg10 : i32
      %17 = arith.index_cast %16 : i32 to index
      %18 = arith.index_cast %14 : i32 to index
      %19 = arith.remsi %18, %6 : index
      %20 = arith.addi %19, %6 : index
      %21 = arith.cmpi slt, %19, %c0_1 : index
      %22 = arith.select %21, %20, %19 : index
      %23 = arith.divsi %14, %arg9 : i32
      %24 = arith.remsi %23, %arg7 : i32
      %25 = arith.muli %24, %4 : i32
      %26 = arith.index_cast %25 : i32 to index
      %27 = arith.index_cast %24 : i32 to index
      %28 = arith.muli %24, %arg9 : i32
      %29 = arith.index_cast %28 : i32 to index
      %30 = arith.divsi %23, %arg7 : i32
      %31 = arith.muli %30, %2 : i32
      %32 = arith.index_cast %31 : i32 to index
      %33 = arith.muli %30, %7 : i32
      %34 = arith.index_cast %33 : i32 to index
      %35 = arith.muli %arg4, %arg7 : i32
      %36 = arith.muli %35, %arg9 : i32
      %37 = arith.cmpi slt, %14, %36 : i32
      scf.if %37 {
        %38 = arith.addi %arg8, %c-1_i32 : i32
        %39 = arith.muli %38, %arg11 : i32
        %40 = arith.addi %16, %39 : i32
        %41 = arith.cmpi slt, %40, %arg6 : i32
        %42 = scf.if %41 -> (f32) {
          %49 = scf.for %arg13 = %c0_1 to %5 step %c1_0 iter_args(%arg14 = %cst) -> (f32) {
            %50 = scf.for %arg15 = %c0_1 to %3 step %c1_0 iter_args(%arg16 = %arg14) -> (f32) {
              %51 = arith.muli %arg15, %1 : index
              %52 = arith.muli %arg13, %0 : index
              %53 = arith.addi %51, %52 : index
              %54 = arith.addi %53, %17 : index
              %55 = arith.addi %54, %32 : index
              %56 = memref.load %arg0[%55] : memref<?xf32>
              %57 = arith.muli %arg13, %3 : index
              %58 = arith.addi %arg15, %57 : index
              %59 = arith.addi %58, %26 : index
              %60 = memref.load %arg1[%59] : memref<?xf32>
              %61 = arith.mulf %56, %60 : f32
              %62 = arith.addf %arg16, %61 : f32
              scf.yield %62 : f32
            }
            scf.yield %50 : f32
          }
          scf.yield %49 : f32
        } else {
          %49 = scf.for %arg13 = %c0_1 to %5 step %c1_0 iter_args(%arg14 = %cst) -> (f32) {
            %50 = scf.for %arg15 = %c0_1 to %3 step %c1_0 iter_args(%arg16 = %arg14) -> (f32) {
              %51 = arith.index_cast %arg15 : index to i32
              %52 = arith.muli %51, %arg11 : i32
              %53 = arith.addi %16, %52 : i32
              %54 = arith.cmpi slt, %53, %arg6 : i32
              %55 = arith.extui %54 : i1 to i32
              %56 = arith.sitofp %55 : i32 to f32
              %57 = arith.muli %arg13, %0 : index
              %58 = arith.muli %arg15, %1 : index
              %59 = arith.addi %57, %58 : index
              %60 = arith.addi %59, %17 : index
              %61 = arith.addi %60, %32 : index
              %62 = memref.load %arg0[%61] : memref<?xf32>
              %63 = arith.mulf %56, %62 : f32
              %64 = arith.muli %arg13, %3 : index
              %65 = arith.addi %arg15, %64 : index
              %66 = arith.addi %65, %26 : index
              %67 = memref.load %arg1[%66] : memref<?xf32>
              %68 = arith.mulf %63, %67 : f32
              %69 = arith.addf %arg16, %68 : f32
              scf.yield %69 : f32
            }
            scf.yield %50 : f32
          }
          scf.yield %49 : f32
        }
        %43 = llvm.mlir.zero : !llvm.ptr
        %44 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
        %45 = llvm.icmp "ne" %44, %43 : !llvm.ptr
        %46 = scf.if %45 -> (f32) {
          %49 = memref.load %arg2[%27] : memref<?xf32>
          %50 = arith.addf %42, %49 : f32
          scf.yield %50 : f32
        } else {
          scf.yield %42 : f32
        }
        %47 = arith.addi %34, %29 : index
        %48 = arith.addi %47, %22 : index
        memref.store %46, %arg3[%48] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
}
[ict-debug] driver.cc: After return 7, module: end

[ict-debug] driver.cc: Before my pass process:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %cst = arith.constant 0.000000e+00 : f32
    %c-1_i32 = arith.constant -1 : i32
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %0 = arith.index_cast %arg6 : i32 to index
    %1 = arith.index_cast %arg11 : i32 to index
    %2 = arith.muli %arg5, %arg6 : i32
    %3 = arith.index_cast %arg8 : i32 to index
    %4 = arith.muli %arg5, %arg8 : i32
    %5 = arith.index_cast %arg5 : i32 to index
    %6 = arith.index_cast %arg9 : i32 to index
    %7 = arith.muli %arg7, %arg9 : i32
    %8 = gpu.block_id  x
    %9 = arith.index_cast %8 : index to i32
    %10 = gpu.block_dim  x
    %11 = arith.index_cast %10 : index to i32
    %12 = arith.muli %9, %11 : i32
    %13 = arith.muli %arg4, %arg7 : i32
    %14 = arith.muli %13, %arg9 : i32
    %15 = arith.addi %arg8, %c-1_i32 : i32
    %16 = arith.muli %15, %arg11 : i32
    %17 = llvm.mlir.zero : !llvm.ptr
    %18 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
    %19 = llvm.icmp "ne" %18, %17 : !llvm.ptr
    scf.parallel (%arg12) = (%c0) to (%c32) step (%c1) {
      %20 = arith.index_cast %arg12 : index to i32
      %21 = arith.addi %12, %20 : i32
      %22 = arith.remsi %21, %arg9 : i32
      %23 = arith.muli %22, %arg10 : i32
      %24 = arith.index_cast %23 : i32 to index
      %25 = arith.index_cast %21 : i32 to index
      %26 = arith.remsi %25, %6 : index
      %27 = arith.addi %26, %6 : index
      %28 = arith.cmpi slt, %26, %c0 : index
      %29 = arith.select %28, %27, %26 : index
      %30 = arith.divsi %21, %arg9 : i32
      %31 = arith.remsi %30, %arg7 : i32
      %32 = arith.muli %31, %4 : i32
      %33 = arith.index_cast %32 : i32 to index
      %34 = arith.index_cast %31 : i32 to index
      %35 = arith.muli %31, %arg9 : i32
      %36 = arith.index_cast %35 : i32 to index
      %37 = arith.divsi %30, %arg7 : i32
      %38 = arith.muli %37, %2 : i32
      %39 = arith.index_cast %38 : i32 to index
      %40 = arith.muli %37, %7 : i32
      %41 = arith.index_cast %40 : i32 to index
      %42 = arith.cmpi slt, %21, %14 : i32
      scf.if %42 {
        %43 = arith.addi %23, %16 : i32
        %44 = arith.cmpi slt, %43, %arg6 : i32
        %45 = scf.if %44 -> (f32) {
          %49 = scf.for %arg13 = %c0 to %5 step %c1 iter_args(%arg14 = %cst) -> (f32) {
            %50 = arith.muli %arg13, %0 : index
            %51 = arith.muli %arg13, %3 : index
            %52 = scf.for %arg15 = %c0 to %3 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
              %53 = arith.muli %arg15, %1 : index
              %54 = arith.addi %53, %50 : index
              %55 = arith.addi %54, %24 : index
              %56 = arith.addi %55, %39 : index
              %57 = memref.load %arg0[%56] : memref<?xf32>
              %58 = arith.addi %arg15, %51 : index
              %59 = arith.addi %58, %33 : index
              %60 = memref.load %arg1[%59] : memref<?xf32>
              %61 = arith.mulf %57, %60 : f32
              %62 = arith.addf %arg16, %61 : f32
              scf.yield %62 : f32
            }
            scf.yield %52 : f32
          }
          scf.yield %49 : f32
        } else {
          %49 = scf.for %arg13 = %c0 to %5 step %c1 iter_args(%arg14 = %cst) -> (f32) {
            %50 = arith.muli %arg13, %0 : index
            %51 = arith.muli %arg13, %3 : index
            %52 = scf.for %arg15 = %c0 to %3 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
              %53 = arith.index_cast %arg15 : index to i32
              %54 = arith.muli %53, %arg11 : i32
              %55 = arith.addi %23, %54 : i32
              %56 = arith.cmpi slt, %55, %arg6 : i32
              %57 = arith.extui %56 : i1 to i32
              %58 = arith.sitofp %57 : i32 to f32
              %59 = arith.muli %arg15, %1 : index
              %60 = arith.addi %50, %59 : index
              %61 = arith.addi %60, %24 : index
              %62 = arith.addi %61, %39 : index
              %63 = memref.load %arg0[%62] : memref<?xf32>
              %64 = arith.mulf %58, %63 : f32
              %65 = arith.addi %arg15, %51 : index
              %66 = arith.addi %65, %33 : index
              %67 = memref.load %arg1[%66] : memref<?xf32>
              %68 = arith.mulf %64, %67 : f32
              %69 = arith.addf %arg16, %68 : f32
              scf.yield %69 : f32
            }
            scf.yield %52 : f32
          }
          scf.yield %49 : f32
        }
        %46 = scf.if %19 -> (f32) {
          %49 = memref.load %arg2[%34] : memref<?xf32>
          %50 = arith.addf %45, %49 : f32
          scf.yield %50 : f32
        } else {
          scf.yield %45 : f32
        }
        %47 = arith.addi %41, %36 : index
        %48 = arith.addi %47, %29 : index
        memref.store %46, %arg3[%48] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
}
[ict-debug] driver.cc: Before my pass process: end

[ict-debug] driver.cc: vectorizeSize = 1

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii_0 {
    gpu.func @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) {
      %cst = arith.constant 0.000000e+00 : f32
      %c-1_i32 = arith.constant -1 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = arith.index_cast %arg6 : i32 to index
      %1 = arith.index_cast %arg11 : i32 to index
      %2 = arith.muli %arg5, %arg6 : i32
      %3 = arith.index_cast %arg8 : i32 to index
      %4 = arith.muli %arg5, %arg8 : i32
      %5 = arith.index_cast %arg5 : i32 to index
      %6 = arith.index_cast %arg9 : i32 to index
      %7 = arith.muli %arg7, %arg9 : i32
      %8 = gpu.block_id  x
      %9 = arith.index_cast %8 : index to i32
      %10 = gpu.block_dim  x
      %11 = arith.index_cast %10 : index to i32
      %12 = arith.muli %9, %11 : i32
      %13 = arith.muli %arg4, %arg7 : i32
      %14 = arith.muli %13, %arg9 : i32
      %15 = arith.addi %arg8, %c-1_i32 : i32
      %16 = arith.muli %15, %arg11 : i32
      %17 = llvm.mlir.zero : !llvm.ptr
      %18 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %19 = llvm.icmp "ne" %18, %17 : !llvm.ptr
      scf.parallel (%arg12) = (%c0) to (%c32) step (%c1) {
        %20 = arith.index_cast %arg12 : index to i32
        %21 = arith.addi %12, %20 : i32
        %22 = arith.remsi %21, %arg9 : i32
        %23 = arith.muli %22, %arg10 : i32
        %24 = arith.index_cast %23 : i32 to index
        %25 = arith.index_cast %21 : i32 to index
        %26 = arith.remsi %25, %6 : index
        %27 = arith.addi %26, %6 : index
        %28 = arith.cmpi slt, %26, %c0 : index
        %29 = arith.select %28, %27, %26 : index
        %30 = arith.divsi %21, %arg9 : i32
        %31 = arith.remsi %30, %arg7 : i32
        %32 = arith.muli %31, %4 : i32
        %33 = arith.index_cast %32 : i32 to index
        %34 = arith.index_cast %31 : i32 to index
        %35 = arith.muli %31, %arg9 : i32
        %36 = arith.index_cast %35 : i32 to index
        %37 = arith.divsi %30, %arg7 : i32
        %38 = arith.muli %37, %2 : i32
        %39 = arith.index_cast %38 : i32 to index
        %40 = arith.muli %37, %7 : i32
        %41 = arith.index_cast %40 : i32 to index
        %42 = arith.cmpi slt, %21, %14 : i32
        scf.if %42 {
          %43 = arith.addi %23, %16 : i32
          %44 = arith.cmpi slt, %43, %arg6 : i32
          %45 = scf.if %44 -> (f32) {
            %49 = scf.for %arg13 = %c0 to %5 step %c1 iter_args(%arg14 = %cst) -> (f32) {
              %50 = arith.muli %arg13, %0 : index
              %51 = arith.muli %arg13, %3 : index
              %52 = scf.for %arg15 = %c0 to %3 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
                %53 = arith.muli %arg15, %1 : index
                %54 = arith.addi %53, %50 : index
                %55 = arith.addi %54, %24 : index
                %56 = arith.addi %55, %39 : index
                %57 = memref.load %arg0[%56] : memref<?xf32>
                %58 = arith.addi %arg15, %51 : index
                %59 = arith.addi %58, %33 : index
                %60 = memref.load %arg1[%59] : memref<?xf32>
                %61 = arith.mulf %57, %60 : f32
                %62 = arith.addf %arg16, %61 : f32
                scf.yield %62 : f32
              }
              scf.yield %52 : f32
            }
            scf.yield %49 : f32
          } else {
            %49 = scf.for %arg13 = %c0 to %5 step %c1 iter_args(%arg14 = %cst) -> (f32) {
              %50 = arith.muli %arg13, %0 : index
              %51 = arith.muli %arg13, %3 : index
              %52 = scf.for %arg15 = %c0 to %3 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
                %53 = arith.index_cast %arg15 : index to i32
                %54 = arith.muli %53, %arg11 : i32
                %55 = arith.addi %23, %54 : i32
                %56 = arith.cmpi slt, %55, %arg6 : i32
                %57 = arith.extui %56 : i1 to i32
                %58 = arith.sitofp %57 : i32 to f32
                %59 = arith.muli %arg15, %1 : index
                %60 = arith.addi %50, %59 : index
                %61 = arith.addi %60, %24 : index
                %62 = arith.addi %61, %39 : index
                %63 = memref.load %arg0[%62] : memref<?xf32>
                %64 = arith.mulf %58, %63 : f32
                %65 = arith.addi %arg15, %51 : index
                %66 = arith.addi %65, %33 : index
                %67 = memref.load %arg1[%66] : memref<?xf32>
                %68 = arith.mulf %64, %67 : f32
                %69 = arith.addf %arg16, %68 : f32
                scf.yield %69 : f32
              }
              scf.yield %52 : f32
            }
            scf.yield %49 : f32
          }
          %46 = scf.if %19 -> (f32) {
            %49 = memref.load %arg2[%34] : memref<?xf32>
            %50 = arith.addf %45, %49 : f32
            scf.yield %50 : f32
          } else {
            scf.yield %45 : f32
          }
          %47 = arith.addi %41, %36 : index
          %48 = arith.addi %47, %29 : index
          memref.store %46, %arg3[%48] : memref<?xf32>
        }
        scf.yield
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute: end

[ict-debug] ConvertPolygeistToNPU:convertScfParallelToScfFor(): replace gpu.block_dim op with thread loop bound

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii_0 {
    gpu.func @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) {
      %cst = arith.constant 0.000000e+00 : f32
      %c-1_i32 = arith.constant -1 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = arith.index_cast %arg6 : i32 to index
      %1 = arith.index_cast %arg11 : i32 to index
      %2 = arith.muli %arg5, %arg6 : i32
      %3 = arith.index_cast %arg8 : i32 to index
      %4 = arith.muli %arg5, %arg8 : i32
      %5 = arith.index_cast %arg5 : i32 to index
      %6 = arith.index_cast %arg9 : i32 to index
      %7 = arith.muli %arg7, %arg9 : i32
      %8 = gpu.block_id  x
      %9 = arith.index_cast %8 : index to i32
      %c32_0 = arith.constant 32 : index
      %10 = arith.index_cast %c32_0 : index to i32
      %11 = arith.muli %9, %10 : i32
      %12 = arith.muli %arg4, %arg7 : i32
      %13 = arith.muli %12, %arg9 : i32
      %14 = arith.addi %arg8, %c-1_i32 : i32
      %15 = arith.muli %14, %arg11 : i32
      %16 = llvm.mlir.zero : !llvm.ptr
      %17 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %18 = llvm.icmp "ne" %17, %16 : !llvm.ptr
      %c1_1 = arith.constant 1 : index
      scf.for %arg12 = %c0 to %c32 step %c1_1 {
        %19 = arith.index_cast %arg12 : index to i32
        %20 = arith.addi %11, %19 : i32
        %21 = arith.remsi %20, %arg9 : i32
        %22 = arith.muli %21, %arg10 : i32
        %23 = arith.index_cast %22 : i32 to index
        %24 = arith.index_cast %20 : i32 to index
        %25 = arith.remsi %24, %6 : index
        %26 = arith.addi %25, %6 : index
        %27 = arith.cmpi slt, %25, %c0 : index
        %28 = arith.select %27, %26, %25 : index
        %29 = arith.divsi %20, %arg9 : i32
        %30 = arith.remsi %29, %arg7 : i32
        %31 = arith.muli %30, %4 : i32
        %32 = arith.index_cast %31 : i32 to index
        %33 = arith.index_cast %30 : i32 to index
        %34 = arith.muli %30, %arg9 : i32
        %35 = arith.index_cast %34 : i32 to index
        %36 = arith.divsi %29, %arg7 : i32
        %37 = arith.muli %36, %2 : i32
        %38 = arith.index_cast %37 : i32 to index
        %39 = arith.muli %36, %7 : i32
        %40 = arith.index_cast %39 : i32 to index
        %41 = arith.cmpi slt, %20, %13 : i32
        scf.if %41 {
          %42 = arith.addi %22, %15 : i32
          %43 = arith.cmpi slt, %42, %arg6 : i32
          %44 = scf.if %43 -> (f32) {
            %48 = scf.for %arg13 = %c0 to %5 step %c1 iter_args(%arg14 = %cst) -> (f32) {
              %49 = arith.muli %arg13, %0 : index
              %50 = arith.muli %arg13, %3 : index
              %51 = scf.for %arg15 = %c0 to %3 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
                %52 = arith.muli %arg15, %1 : index
                %53 = arith.addi %52, %49 : index
                %54 = arith.addi %53, %23 : index
                %55 = arith.addi %54, %38 : index
                %56 = memref.load %arg0[%55] : memref<?xf32>
                %57 = arith.addi %arg15, %50 : index
                %58 = arith.addi %57, %32 : index
                %59 = memref.load %arg1[%58] : memref<?xf32>
                %60 = arith.mulf %56, %59 : f32
                %61 = arith.addf %arg16, %60 : f32
                scf.yield %61 : f32
              }
              scf.yield %51 : f32
            }
            scf.yield %48 : f32
          } else {
            %48 = scf.for %arg13 = %c0 to %5 step %c1 iter_args(%arg14 = %cst) -> (f32) {
              %49 = arith.muli %arg13, %0 : index
              %50 = arith.muli %arg13, %3 : index
              %51 = scf.for %arg15 = %c0 to %3 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
                %52 = arith.index_cast %arg15 : index to i32
                %53 = arith.muli %52, %arg11 : i32
                %54 = arith.addi %22, %53 : i32
                %55 = arith.cmpi slt, %54, %arg6 : i32
                %56 = arith.extui %55 : i1 to i32
                %57 = arith.sitofp %56 : i32 to f32
                %58 = arith.muli %arg15, %1 : index
                %59 = arith.addi %49, %58 : index
                %60 = arith.addi %59, %23 : index
                %61 = arith.addi %60, %38 : index
                %62 = memref.load %arg0[%61] : memref<?xf32>
                %63 = arith.mulf %57, %62 : f32
                %64 = arith.addi %arg15, %50 : index
                %65 = arith.addi %64, %32 : index
                %66 = memref.load %arg1[%65] : memref<?xf32>
                %67 = arith.mulf %63, %66 : f32
                %68 = arith.addf %arg16, %67 : f32
                scf.yield %68 : f32
              }
              scf.yield %51 : f32
            }
            scf.yield %48 : f32
          }
          %45 = scf.if %18 -> (f32) {
            %48 = memref.load %arg2[%33] : memref<?xf32>
            %49 = arith.addf %44, %48 : f32
            scf.yield %49 : f32
          } else {
            scf.yield %44 : f32
          }
          %46 = arith.addi %40, %35 : index
          %47 = arith.addi %46, %28 : index
          memref.store %45, %arg3[%47] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize: end

[ict-debug] CastLikeOpToNPULowering: process op: 

%0 = arith.index_cast %arg6 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%2 = arith.index_cast %arg11 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%5 = arith.index_cast %arg8 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%8 = arith.index_cast %arg5 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%10 = arith.index_cast %arg9 : i32 to index
[ict-debug] GPUBlockIdToNPULowering: process op: 

%13 = gpu.block_id  x
[ict-debug] CastLikeOpToNPULowering: process op: 

%15 = arith.index_cast %14 : index to i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%29 = arith.index_cast %arg12 : index to i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%34 = arith.index_cast %33 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%36 = arith.index_cast %31 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%45 = arith.index_cast %44 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%47 = arith.index_cast %43 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%50 = arith.index_cast %49 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%54 = arith.index_cast %53 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%57 = arith.index_cast %56 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%71 = arith.index_cast %arg15 : index to i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%76 = arith.extui %75 : i1 to i32
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii_0 {
    gpu.func @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) {
      %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.ptr
      %cst = arith.constant 0.000000e+00 : f32
      %c-1_i32 = arith.constant -1 : i32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %1 = emitc.cast %arg6 : i32 to index
      %2 = emitc.cast %arg11 : i32 to index
      %3 = arith.muli %arg5, %arg6 : i32
      %4 = emitc.cast %arg8 : i32 to index
      %5 = arith.muli %arg5, %arg8 : i32
      %6 = emitc.cast %arg5 : i32 to index
      %7 = emitc.cast %arg9 : i32 to index
      %8 = arith.muli %arg7, %arg9 : i32
      %9 = "npu.block_id"() : () -> i64
      %10 = emitc.cast %9 : i64 to i32
      %c32_0 = arith.constant 32 : index
      %c32_i32 = arith.constant 32 : i32
      %11 = arith.muli %10, %c32_i32 : i32
      %12 = arith.muli %arg4, %arg7 : i32
      %13 = arith.muli %12, %arg9 : i32
      %14 = arith.addi %arg8, %c-1_i32 : i32
      %15 = arith.muli %14, %arg11 : i32
      %16 = llvm.mlir.zero : !llvm.ptr
      %17 = llvm.bitcast %0 : !llvm.ptr to !llvm.ptr
      %18 = llvm.icmp "ne" %17, %16 : !llvm.ptr
      %c1_1 = arith.constant 1 : index
      scf.for %arg12 = %c0 to %c32 step %c1_1 {
        %19 = builtin.unrealized_conversion_cast %arg12 : index to i64
        %20 = emitc.cast %19 : i64 to i32
        %21 = arith.addi %11, %20 : i32
        %22 = arith.remsi %21, %arg9 : i32
        %23 = arith.muli %22, %arg10 : i32
        %24 = emitc.cast %23 : i32 to index
        %25 = emitc.cast %21 : i32 to index
        %26 = arith.remsi %25, %7 : index
        %27 = arith.addi %26, %7 : index
        %28 = arith.cmpi slt, %26, %c0 : index
        %29 = arith.select %28, %27, %26 : index
        %30 = arith.divsi %21, %arg9 : i32
        %31 = arith.remsi %30, %arg7 : i32
        %32 = arith.muli %31, %5 : i32
        %33 = emitc.cast %32 : i32 to index
        %34 = emitc.cast %31 : i32 to index
        %35 = arith.muli %31, %arg9 : i32
        %36 = emitc.cast %35 : i32 to index
        %37 = arith.divsi %30, %arg7 : i32
        %38 = arith.muli %37, %3 : i32
        %39 = emitc.cast %38 : i32 to index
        %40 = arith.muli %37, %8 : i32
        %41 = emitc.cast %40 : i32 to index
        %42 = arith.cmpi slt, %21, %13 : i32
        scf.if %42 {
          %43 = arith.addi %23, %15 : i32
          %44 = arith.cmpi slt, %43, %arg6 : i32
          %45 = scf.if %44 -> (f32) {
            %49 = scf.for %arg13 = %c0 to %6 step %c1 iter_args(%arg14 = %cst) -> (f32) {
              %50 = arith.muli %arg13, %1 : index
              %51 = arith.muli %arg13, %4 : index
              %52 = scf.for %arg15 = %c0 to %4 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
                %53 = arith.muli %arg15, %2 : index
                %54 = arith.addi %53, %50 : index
                %55 = arith.addi %54, %24 : index
                %56 = arith.addi %55, %39 : index
                %57 = memref.load %arg0[%56] : memref<?xf32>
                %58 = arith.addi %arg15, %51 : index
                %59 = arith.addi %58, %33 : index
                %60 = memref.load %arg1[%59] : memref<?xf32>
                %61 = emitc.mul %57, %60 : (f32, f32) -> f32
                %62 = emitc.add %arg16, %61 : (f32, f32) -> f32
                scf.yield %62 : f32
              }
              scf.yield %52 : f32
            }
            scf.yield %49 : f32
          } else {
            %49 = scf.for %arg13 = %c0 to %6 step %c1 iter_args(%arg14 = %cst) -> (f32) {
              %50 = arith.muli %arg13, %1 : index
              %51 = arith.muli %arg13, %4 : index
              %52 = scf.for %arg15 = %c0 to %4 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
                %53 = builtin.unrealized_conversion_cast %arg15 : index to i64
                %54 = emitc.cast %53 : i64 to i32
                %55 = arith.muli %54, %arg11 : i32
                %56 = arith.addi %23, %55 : i32
                %57 = arith.cmpi slt, %56, %arg6 : i32
                %58 = emitc.cast %57 : i1 to i32
                %59 = arith.sitofp %58 : i32 to f32
                %60 = arith.muli %arg15, %2 : index
                %61 = arith.addi %50, %60 : index
                %62 = arith.addi %61, %24 : index
                %63 = arith.addi %62, %39 : index
                %64 = memref.load %arg0[%63] : memref<?xf32>
                %65 = emitc.mul %59, %64 : (f32, f32) -> f32
                %66 = arith.addi %arg15, %51 : index
                %67 = arith.addi %66, %33 : index
                %68 = memref.load %arg1[%67] : memref<?xf32>
                %69 = emitc.mul %65, %68 : (f32, f32) -> f32
                %70 = emitc.add %arg16, %69 : (f32, f32) -> f32
                scf.yield %70 : f32
              }
              scf.yield %52 : f32
            }
            scf.yield %49 : f32
          }
          %46 = scf.if %18 -> (f32) {
            %49 = memref.load %arg2[%34] : memref<?xf32>
            %50 = emitc.add %45, %49 : (f32, f32) -> f32
            scf.yield %50 : f32
          } else {
            scf.yield %45 : f32
          }
          %47 = arith.addi %41, %36 : index
          %48 = arith.addi %47, %29 : index
          memref.store %46, %arg3[%48] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU: end

[ict-debug] driver.cc: Before convert to EmitC dialect:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii_0 {
    gpu.func @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) {
      %c32_i32 = arith.constant 32 : i32
      %c32 = arith.constant 32 : index
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %c-1_i32 = arith.constant -1 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.ptr
      %1 = emitc.cast %arg6 : i32 to index
      %2 = emitc.cast %arg11 : i32 to index
      %3 = arith.muli %arg5, %arg6 : i32
      %4 = emitc.cast %arg8 : i32 to index
      %5 = arith.muli %arg5, %arg8 : i32
      %6 = emitc.cast %arg5 : i32 to index
      %7 = emitc.cast %arg9 : i32 to index
      %8 = arith.muli %arg7, %arg9 : i32
      %9 = "npu.block_id"() : () -> i64
      %10 = emitc.cast %9 : i64 to i32
      %11 = arith.muli %10, %c32_i32 : i32
      %12 = arith.muli %arg4, %arg7 : i32
      %13 = arith.muli %12, %arg9 : i32
      %14 = arith.addi %arg8, %c-1_i32 : i32
      %15 = arith.muli %14, %arg11 : i32
      %16 = llvm.mlir.zero : !llvm.ptr
      %17 = llvm.icmp "ne" %0, %16 : !llvm.ptr
      scf.for %arg12 = %c0 to %c32 step %c1 {
        %18 = builtin.unrealized_conversion_cast %arg12 : index to i64
        %19 = emitc.cast %18 : i64 to i32
        %20 = arith.addi %11, %19 : i32
        %21 = arith.remsi %20, %arg9 : i32
        %22 = arith.muli %21, %arg10 : i32
        %23 = emitc.cast %22 : i32 to index
        %24 = emitc.cast %20 : i32 to index
        %25 = arith.remsi %24, %7 : index
        %26 = arith.addi %25, %7 : index
        %27 = arith.cmpi slt, %25, %c0 : index
        %28 = arith.select %27, %26, %25 : index
        %29 = arith.divsi %20, %arg9 : i32
        %30 = arith.remsi %29, %arg7 : i32
        %31 = arith.muli %30, %5 : i32
        %32 = emitc.cast %31 : i32 to index
        %33 = emitc.cast %30 : i32 to index
        %34 = arith.muli %30, %arg9 : i32
        %35 = emitc.cast %34 : i32 to index
        %36 = arith.divsi %29, %arg7 : i32
        %37 = arith.muli %36, %3 : i32
        %38 = emitc.cast %37 : i32 to index
        %39 = arith.muli %36, %8 : i32
        %40 = emitc.cast %39 : i32 to index
        %41 = arith.cmpi slt, %20, %13 : i32
        scf.if %41 {
          %42 = arith.addi %22, %15 : i32
          %43 = arith.cmpi slt, %42, %arg6 : i32
          %44 = scf.if %43 -> (f32) {
            %48 = scf.for %arg13 = %c0 to %6 step %c1 iter_args(%arg14 = %cst) -> (f32) {
              %49 = arith.muli %arg13, %1 : index
              %50 = arith.muli %arg13, %4 : index
              %51 = scf.for %arg15 = %c0 to %4 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
                %52 = arith.muli %arg15, %2 : index
                %53 = arith.addi %52, %49 : index
                %54 = arith.addi %53, %23 : index
                %55 = arith.addi %54, %38 : index
                %56 = memref.load %arg0[%55] : memref<?xf32>
                %57 = arith.addi %arg15, %50 : index
                %58 = arith.addi %57, %32 : index
                %59 = memref.load %arg1[%58] : memref<?xf32>
                %60 = emitc.mul %56, %59 : (f32, f32) -> f32
                %61 = emitc.add %arg16, %60 : (f32, f32) -> f32
                scf.yield %61 : f32
              }
              scf.yield %51 : f32
            }
            scf.yield %48 : f32
          } else {
            %48 = scf.for %arg13 = %c0 to %6 step %c1 iter_args(%arg14 = %cst) -> (f32) {
              %49 = arith.muli %arg13, %1 : index
              %50 = arith.muli %arg13, %4 : index
              %51 = scf.for %arg15 = %c0 to %4 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
                %52 = builtin.unrealized_conversion_cast %arg15 : index to i64
                %53 = emitc.cast %52 : i64 to i32
                %54 = arith.muli %53, %arg11 : i32
                %55 = arith.addi %22, %54 : i32
                %56 = arith.cmpi slt, %55, %arg6 : i32
                %57 = emitc.cast %56 : i1 to i32
                %58 = arith.sitofp %57 : i32 to f32
                %59 = arith.muli %arg15, %2 : index
                %60 = arith.addi %49, %59 : index
                %61 = arith.addi %60, %23 : index
                %62 = arith.addi %61, %38 : index
                %63 = memref.load %arg0[%62] : memref<?xf32>
                %64 = emitc.mul %58, %63 : (f32, f32) -> f32
                %65 = arith.addi %arg15, %50 : index
                %66 = arith.addi %65, %32 : index
                %67 = memref.load %arg1[%66] : memref<?xf32>
                %68 = emitc.mul %64, %67 : (f32, f32) -> f32
                %69 = emitc.add %arg16, %68 : (f32, f32) -> f32
                scf.yield %69 : f32
              }
              scf.yield %51 : f32
            }
            scf.yield %48 : f32
          }
          %45 = scf.if %17 -> (f32) {
            %48 = memref.load %arg2[%33] : memref<?xf32>
            %49 = emitc.add %44, %48 : (f32, f32) -> f32
            scf.yield %49 : f32
          } else {
            scf.yield %44 : f32
          }
          %46 = arith.addi %40, %35 : index
          %47 = arith.addi %46, %28 : index
          memref.store %45, %arg3[%47] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: Before convert to EmitC dialect: end

[ict-debug] driver.cc: After convert to EmitC dialect:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii_0 {
    gpu.func @_Z13conv1d_kernelPKfS0_S0_Pfiiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32, %arg11: i32) {
      %c32_i32 = arith.constant 32 : i32
      %c32 = arith.constant 32 : index
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %c-1_i32 = arith.constant -1 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.ptr
      %1 = emitc.cast %arg6 : i32 to index
      %2 = emitc.cast %arg11 : i32 to index
      %3 = arith.muli %arg5, %arg6 : i32
      %4 = emitc.cast %arg8 : i32 to index
      %5 = arith.muli %arg5, %arg8 : i32
      %6 = emitc.cast %arg5 : i32 to index
      %7 = emitc.cast %arg9 : i32 to index
      %8 = arith.muli %arg7, %arg9 : i32
      %9 = "npu.block_id"() : () -> i64
      %10 = emitc.cast %9 : i64 to i32
      %11 = arith.muli %10, %c32_i32 : i32
      %12 = arith.muli %arg4, %arg7 : i32
      %13 = arith.muli %12, %arg9 : i32
      %14 = arith.addi %arg8, %c-1_i32 : i32
      %15 = arith.muli %14, %arg11 : i32
      %16 = llvm.mlir.zero : !llvm.ptr
      %17 = llvm.icmp "ne" %0, %16 : !llvm.ptr
      scf.for %arg12 = %c0 to %c32 step %c1 {
        %18 = builtin.unrealized_conversion_cast %arg12 : index to i64
        %19 = emitc.cast %18 : i64 to i32
        %20 = arith.addi %11, %19 : i32
        %21 = arith.remsi %20, %arg9 : i32
        %22 = arith.muli %21, %arg10 : i32
        %23 = emitc.cast %22 : i32 to index
        %24 = emitc.cast %20 : i32 to index
        %25 = arith.remsi %24, %7 : index
        %26 = arith.addi %25, %7 : index
        %27 = arith.cmpi slt, %25, %c0 : index
        %28 = arith.select %27, %26, %25 : index
        %29 = arith.divsi %20, %arg9 : i32
        %30 = arith.remsi %29, %arg7 : i32
        %31 = arith.muli %30, %5 : i32
        %32 = emitc.cast %31 : i32 to index
        %33 = emitc.cast %30 : i32 to index
        %34 = arith.muli %30, %arg9 : i32
        %35 = emitc.cast %34 : i32 to index
        %36 = arith.divsi %29, %arg7 : i32
        %37 = arith.muli %36, %3 : i32
        %38 = emitc.cast %37 : i32 to index
        %39 = arith.muli %36, %8 : i32
        %40 = emitc.cast %39 : i32 to index
        %41 = arith.cmpi slt, %20, %13 : i32
        emitc.if %41 {
          %42 = arith.addi %22, %15 : i32
          %43 = arith.cmpi slt, %42, %arg6 : i32
          %44 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> f32
          emitc.if %43 {
            %48 = scf.for %arg13 = %c0 to %6 step %c1 iter_args(%arg14 = %cst) -> (f32) {
              %49 = arith.muli %arg13, %1 : index
              %50 = arith.muli %arg13, %4 : index
              %51 = scf.for %arg15 = %c0 to %4 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
                %52 = arith.muli %arg15, %2 : index
                %53 = arith.addi %52, %49 : index
                %54 = arith.addi %53, %23 : index
                %55 = arith.addi %54, %38 : index
                %56 = memref.load %arg0[%55] : memref<?xf32>
                %57 = arith.addi %arg15, %50 : index
                %58 = arith.addi %57, %32 : index
                %59 = memref.load %arg1[%58] : memref<?xf32>
                %60 = emitc.mul %56, %59 : (f32, f32) -> f32
                %61 = emitc.add %arg16, %60 : (f32, f32) -> f32
                scf.yield %61 : f32
              }
              scf.yield %51 : f32
            }
            emitc.assign %48 : f32 to %44 : f32
          } else {
            %48 = scf.for %arg13 = %c0 to %6 step %c1 iter_args(%arg14 = %cst) -> (f32) {
              %49 = arith.muli %arg13, %1 : index
              %50 = arith.muli %arg13, %4 : index
              %51 = scf.for %arg15 = %c0 to %4 step %c1 iter_args(%arg16 = %arg14) -> (f32) {
                %52 = builtin.unrealized_conversion_cast %arg15 : index to i64
                %53 = emitc.cast %52 : i64 to i32
                %54 = arith.muli %53, %arg11 : i32
                %55 = arith.addi %22, %54 : i32
                %56 = arith.cmpi slt, %55, %arg6 : i32
                %57 = emitc.cast %56 : i1 to i32
                %58 = arith.sitofp %57 : i32 to f32
                %59 = arith.muli %arg15, %2 : index
                %60 = arith.addi %49, %59 : index
                %61 = arith.addi %60, %23 : index
                %62 = arith.addi %61, %38 : index
                %63 = memref.load %arg0[%62] : memref<?xf32>
                %64 = emitc.mul %58, %63 : (f32, f32) -> f32
                %65 = arith.addi %arg15, %50 : index
                %66 = arith.addi %65, %32 : index
                %67 = memref.load %arg1[%66] : memref<?xf32>
                %68 = emitc.mul %64, %67 : (f32, f32) -> f32
                %69 = emitc.add %arg16, %68 : (f32, f32) -> f32
                scf.yield %69 : f32
              }
              scf.yield %51 : f32
            }
            emitc.assign %48 : f32 to %44 : f32
          }
          %45 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> f32
          emitc.if %17 {
            %48 = memref.load %arg2[%33] : memref<?xf32>
            %49 = emitc.add %44, %48 : (f32, f32) -> f32
            emitc.assign %49 : f32 to %45 : f32
          } else {
            emitc.assign %44 : f32 to %45 : f32
          }
          %46 = arith.addi %40, %35 : index
          %47 = arith.addi %46, %28 : index
          memref.store %45, %arg3[%47] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: After convert to EmitC dialect: end

loc("./cuda_ops/76_conv_standard_1D_dilated_strided__.cu":64:17): error: 'llvm.mlir.zero' op unable to find printer for op
[ict-debug] driver.cc: After emitc::translateToCpp:

