warning: CUDA version 12.1 is only partially supported
warning: CUDA version 12.1 is only partially supported
[ict-debug] driver.cc: After return 5, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z45__device_stub__conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    call @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6, %arg7, %arg8, %arg9, %arg10) : (memref<?xf32>, memref<?xf32>, memref<?xf32>, memref<?xf32>, i32, i32, i32, i32, i32, i32, i32) -> ()
    return
  }
  func.func private @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %cst = arith.constant 0.000000e+00 : f32
    %c0_i32 = arith.constant 0 : i32
    %true = arith.constant true
    %c1 = arith.constant 1 : index
    %0 = arith.index_cast %arg8 : i32 to index
    %1 = arith.index_cast %arg10 : i32 to index
    %2 = arith.index_cast %arg9 : i32 to index
    %3 = arith.index_cast %arg8 : i32 to index
    %4 = arith.index_cast %arg10 : i32 to index
    %5 = arith.index_cast %arg9 : i32 to index
    %6 = arith.index_cast %arg5 : i32 to index
    %7 = arith.index_cast %arg7 : i32 to index
    %8 = llvm.mlir.undef : i32
    %alloca = memref.alloca() : memref<1xf32, 5>
    %9 = gpu.block_id  x
    %10 = arith.index_cast %9 : index to i32
    %11 = gpu.block_id  y
    %12 = arith.index_cast %11 : index to i32
    %13 = arith.muli %arg4, %arg7 : i32
    %14 = gpu.thread_id  x
    %15 = gpu.grid_dim  y
    %16 = arith.index_cast %15 : index to i32
    %17 = arith.muli %16, %arg7 : i32
    %18 = arith.muli %12, %arg7 : i32
    %19 = gpu.block_dim  x
    %20 = arith.index_cast %13 : i32 to index
    %21 = arith.subi %20, %14 : index
    %22 = arith.subi %19, %c1 : index
    %23 = arith.addi %22, %21 : index
    %24 = arith.divui %23, %19 : index
    affine.for %arg11 = 0 to %24 {
      %48 = arith.muli %arg11, %19 : index
      %49 = arith.divui %48, %19 : index
      %50 = arith.muli %49, %19 : index
      %51 = arith.addi %14, %50 : index
      %52 = arith.index_cast %51 : index to i32
      %53 = arith.divsi %52, %arg7 : i32
      %54 = arith.remsi %52, %arg7 : i32
      %55 = arith.muli %53, %17 : i32
      %56 = arith.addi %55, %18 : i32
      %57 = arith.addi %56, %54 : i32
      %58 = arith.index_cast %57 : i32 to index
      %59 = memref.load %arg1[%58] : memref<?xf32>
      affine.store %59, %alloca[%arg11 * symbol(%19) + symbol(%14)] : memref<1xf32, 5>
    }
    nvvm.barrier0
    %25 = gpu.thread_id  x
    %26 = arith.index_cast %arg7 : i32 to index
    %27 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
    %28 = llvm.mlir.zero : !llvm.ptr
    %29 = llvm.icmp "ne" %27, %28 : !llvm.ptr
    %30 = gpu.grid_dim  y
    %31 = arith.index_cast %30 : index to i32
    %32 = arith.muli %31, %arg6 : i32
    %33 = arith.muli %10, %32 : i32
    %34 = arith.muli %12, %arg6 : i32
    %35 = arith.addi %33, %34 : i32
    %36 = arith.index_cast %35 : i32 to index
    %37 = gpu.block_dim  x
    %38 = arith.index_cast %arg6 : i32 to index
    %39 = arith.index_cast %arg4 : i32 to index
    %40 = arith.muli %arg4, %arg5 : i32
    %41 = arith.muli %10, %40 : i32
    %42 = arith.index_cast %41 : i32 to index
    %43 = arith.subi %38, %25 : index
    %44 = arith.subi %37, %c1 : index
    %45 = arith.addi %44, %43 : index
    %46 = arith.divui %45, %37 : index
    %47:3 = affine.for %arg11 = 0 to %46 iter_args(%arg12 = %8, %arg13 = %8, %arg14 = %8) -> (i32, i32, i32) {
      %48 = arith.muli %arg11, %37 : index
      %49 = arith.divui %48, %37 : index
      %50 = arith.muli %49, %37 : index
      %51 = arith.addi %25, %50 : index
      %52 = arith.index_cast %51 : index to i32
      %53 = arith.addi %52, %arg9 : i32
      %54:4 = affine.for %arg15 = 0 to %26 iter_args(%arg16 = %arg12, %arg17 = %arg13, %arg18 = %arg14, %arg19 = %cst) -> (i32, i32, i32, f32) {
        %56 = arith.index_cast %arg15 : index to i32
        %57 = arith.muli %56, %arg10 : i32
        %58 = arith.subi %53, %57 : i32
        %59 = arith.remsi %58, %arg8 : i32
        %60 = arith.cmpi eq, %59, %c0_i32 : i32
        %61:4 = scf.if %60 -> (i32, i32, i32, f32) {
          %62 = arith.divsi %58, %arg8 : i32
          %63 = affine.if affine_set<(d0, d1)[s0, s1, s2, s3, s4] : (-((-(d0 * s3) + s0 + s2 + d1 * s1) floordiv s4) - 1 >= 0)>(%arg15, %arg11)[%25, %37, %2, %1, %0] -> i1 {
            affine.yield %true : i1
          } else {
            %66 = arith.cmpi sge, %62, %arg5 : i32
            affine.yield %66 : i1
          }
          %64 = arith.select %63, %arg17, %arg4 : i32
          %65:2 = scf.if %63 -> (i32, f32) {
            scf.yield %arg16, %arg19 : i32, f32
          } else {
            %66:2 = affine.for %arg20 = 0 to %39 iter_args(%arg21 = %arg19, %arg22 = %arg16) -> (f32, i32) {
              %67 = arith.index_cast %arg20 : index to i32
              %68 = arith.muli %67, %arg5 : i32
              %69 = arith.addi %41, %68 : i32
              %70 = arith.addi %69, %62 : i32
              %71 = affine.load %arg0[%arg20 * symbol(%6) + symbol(%42) + (-(%arg15 * symbol(%4)) + symbol(%25) + symbol(%5) + %arg11 * symbol(%37)) floordiv symbol(%3)] : memref<?xf32>
              %72 = affine.load %alloca[%arg15 + %arg20 * symbol(%7)] : memref<1xf32, 5>
              %73 = arith.mulf %71, %72 : f32
              %74 = arith.addf %arg21, %73 : f32
              affine.yield %74, %70 : f32, i32
            }
            scf.yield %66#1, %66#0 : i32, f32
          }
          scf.yield %62, %65#0, %64, %65#1 : i32, i32, i32, f32
        } else {
          scf.yield %arg18, %arg16, %arg17, %arg19 : i32, i32, i32, f32
        }
        affine.yield %61#1, %61#2, %61#0, %61#3 : i32, i32, i32, f32
      }
      %55 = scf.if %29 -> (f32) {
        %56 = affine.load %arg2[symbol(%11)] : memref<?xf32>
        %57 = arith.addf %54#3, %56 : f32
        scf.yield %57 : f32
      } else {
        scf.yield %54#3 : f32
      }
      affine.store %55, %arg3[%arg11 * symbol(%37) + symbol(%36) + symbol(%25)] : memref<?xf32>
      affine.yield %54#0, %54#1, %54#2 : i32, i32, i32
    }
    return
  }
}
[ict-debug] driver.cc: After return 5, module: end

[ict-debug] driver.cc: After return 6, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c-1 = arith.constant -1 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c0_i32 = arith.constant 0 : i32
    %true = arith.constant true
    %c1 = arith.constant 1 : index
    %0 = arith.index_cast %arg8 : i32 to index
    %1 = arith.index_cast %arg10 : i32 to index
    %2 = arith.index_cast %arg9 : i32 to index
    %3 = arith.index_cast %arg5 : i32 to index
    %4 = arith.index_cast %arg7 : i32 to index
    %5 = llvm.mlir.undef : i32
    %alloca = memref.alloca() : memref<1xf32, 5>
    %6 = gpu.block_id  x
    %7 = arith.index_cast %6 : index to i32
    %8 = gpu.block_id  y
    %9 = arith.index_cast %8 : index to i32
    %10 = arith.muli %arg4, %arg7 : i32
    %11 = gpu.thread_id  x
    %12 = gpu.grid_dim  y
    %13 = arith.index_cast %12 : index to i32
    %14 = arith.muli %13, %arg7 : i32
    %15 = arith.muli %9, %arg7 : i32
    %16 = gpu.block_dim  x
    %17 = arith.index_cast %10 : i32 to index
    %18 = arith.subi %17, %11 : index
    %19 = arith.subi %16, %c1 : index
    %20 = arith.addi %19, %18 : index
    %21 = arith.divui %20, %16 : index
    affine.for %arg11 = 0 to %21 {
      %40 = arith.muli %arg11, %16 : index
      %41 = arith.addi %11, %40 : index
      %42 = arith.index_cast %41 : index to i32
      %43 = arith.divsi %42, %arg7 : i32
      %44 = arith.remsi %42, %arg7 : i32
      %45 = arith.muli %43, %14 : i32
      %46 = arith.addi %45, %15 : i32
      %47 = arith.addi %46, %44 : i32
      %48 = arith.index_cast %47 : i32 to index
      %49 = memref.load %arg1[%48] : memref<?xf32>
      affine.store %49, %alloca[%arg11 * symbol(%16) + symbol(%11)] : memref<1xf32, 5>
    }
    nvvm.barrier0
    %22 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
    %23 = llvm.mlir.zero : !llvm.ptr
    %24 = llvm.icmp "ne" %22, %23 : !llvm.ptr
    %25 = arith.muli %13, %arg6 : i32
    %26 = arith.muli %7, %25 : i32
    %27 = arith.muli %9, %arg6 : i32
    %28 = arith.addi %26, %27 : i32
    %29 = arith.index_cast %28 : i32 to index
    %30 = arith.index_cast %arg6 : i32 to index
    %31 = arith.index_cast %arg4 : i32 to index
    %32 = arith.muli %arg4, %arg5 : i32
    %33 = arith.muli %7, %32 : i32
    %34 = arith.index_cast %33 : i32 to index
    %35 = arith.subi %30, %11 : index
    %36 = arith.addi %19, %35 : index
    %37 = arith.divui %36, %16 : index
    %38 = arith.addi %11, %2 : index
    %39:3 = affine.for %arg11 = 0 to %37 iter_args(%arg12 = %5, %arg13 = %5, %arg14 = %5) -> (i32, i32, i32) {
      %40 = arith.muli %arg11, %16 : index
      %41 = arith.addi %11, %40 : index
      %42 = arith.index_cast %41 : index to i32
      %43 = arith.addi %42, %arg9 : i32
      %44:4 = affine.for %arg15 = 0 to %4 iter_args(%arg16 = %arg12, %arg17 = %arg13, %arg18 = %arg14, %arg19 = %cst) -> (i32, i32, i32, f32) {
        %46 = arith.index_cast %arg15 : index to i32
        %47 = arith.muli %46, %arg10 : i32
        %48 = arith.subi %43, %47 : i32
        %49 = arith.remsi %48, %arg8 : i32
        %50 = arith.cmpi eq, %49, %c0_i32 : i32
        %51:4 = scf.if %50 -> (i32, i32, i32, f32) {
          %52 = arith.divsi %48, %arg8 : i32
          %53 = arith.muli %arg15, %1 : index
          %54 = arith.subi %38, %53 : index
          %55 = arith.addi %54, %40 : index
          %56 = arith.cmpi slt, %55, %c0 : index
          %57 = arith.subi %c-1, %55 : index
          %58 = arith.select %56, %57, %55 : index
          %59 = arith.divsi %58, %0 : index
          %60 = arith.subi %c-1, %59 : index
          %61 = arith.select %56, %60, %59 : index
          %62 = arith.subi %c-1, %61 : index
          %63 = arith.cmpi sge, %62, %c0 : index
          %64 = scf.if %63 -> (i1) {
            scf.yield %true : i1
          } else {
            %67 = arith.cmpi sge, %52, %arg5 : i32
            scf.yield %67 : i1
          }
          %65 = arith.select %64, %arg17, %arg4 : i32
          %66:2 = scf.if %64 -> (i32, f32) {
            scf.yield %arg16, %arg19 : i32, f32
          } else {
            %67:2 = affine.for %arg20 = 0 to %31 iter_args(%arg21 = %arg19, %arg22 = %arg16) -> (f32, i32) {
              %68 = arith.index_cast %arg20 : index to i32
              %69 = arith.muli %68, %arg5 : i32
              %70 = arith.addi %33, %69 : i32
              %71 = arith.addi %70, %52 : i32
              %72 = arith.muli %arg20, %3 : index
              %73 = arith.addi %72, %34 : index
              %74 = arith.addi %73, %61 : index
              %75 = memref.load %arg0[%74] : memref<?xf32>
              %76 = affine.load %alloca[%arg15 + %arg20 * symbol(%4)] : memref<1xf32, 5>
              %77 = arith.mulf %75, %76 : f32
              %78 = arith.addf %arg21, %77 : f32
              affine.yield %78, %71 : f32, i32
            }
            scf.yield %67#1, %67#0 : i32, f32
          }
          scf.yield %52, %66#0, %65, %66#1 : i32, i32, i32, f32
        } else {
          scf.yield %arg18, %arg16, %arg17, %arg19 : i32, i32, i32, f32
        }
        affine.yield %51#1, %51#2, %51#0, %51#3 : i32, i32, i32, f32
      }
      %45 = scf.if %24 -> (f32) {
        %46 = affine.load %arg2[symbol(%8)] : memref<?xf32>
        %47 = arith.addf %44#3, %46 : f32
        scf.yield %47 : f32
      } else {
        scf.yield %44#3 : f32
      }
      affine.store %45, %arg3[%arg11 * symbol(%16) + symbol(%29) + symbol(%11)] : memref<?xf32>
      affine.yield %44#0, %44#1, %44#2 : i32, i32, i32
    }
    return
  }
}
[ict-debug] driver.cc: After return 6, module: end

WrapAndReplaceBarrierPass::runOnOperation(): before execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c-1 = arith.constant -1 : index
    %c0 = arith.constant 0 : index
    %cst = arith.constant 0.000000e+00 : f32
    %c0_i32 = arith.constant 0 : i32
    %true = arith.constant true
    %c1 = arith.constant 1 : index
    %0 = arith.index_cast %arg8 : i32 to index
    %1 = arith.index_cast %arg10 : i32 to index
    %2 = arith.index_cast %arg9 : i32 to index
    %3 = arith.index_cast %arg5 : i32 to index
    %4 = arith.index_cast %arg7 : i32 to index
    %5 = llvm.mlir.undef : i32
    %alloca = memref.alloca() : memref<1xf32, 5>
    %6 = gpu.block_id  x
    %7 = arith.index_cast %6 : index to i32
    %8 = gpu.block_id  y
    %9 = arith.index_cast %8 : index to i32
    %10 = arith.muli %arg4, %arg7 : i32
    %11 = gpu.thread_id  x
    %12 = gpu.grid_dim  y
    %13 = arith.index_cast %12 : index to i32
    %14 = arith.muli %13, %arg7 : i32
    %15 = arith.muli %9, %arg7 : i32
    %16 = gpu.block_dim  x
    %17 = arith.index_cast %10 : i32 to index
    %18 = arith.subi %17, %11 : index
    %19 = arith.subi %16, %c1 : index
    %20 = arith.addi %19, %18 : index
    %21 = arith.divui %20, %16 : index
    scf.for %arg11 = %c0 to %21 step %c1 {
      %40 = arith.muli %arg11, %16 : index
      %41 = arith.addi %11, %40 : index
      %42 = arith.index_cast %41 : index to i32
      %43 = arith.divsi %42, %arg7 : i32
      %44 = arith.remsi %42, %arg7 : i32
      %45 = arith.muli %43, %14 : i32
      %46 = arith.addi %45, %15 : i32
      %47 = arith.addi %46, %44 : i32
      %48 = arith.index_cast %47 : i32 to index
      %49 = memref.load %arg1[%48] : memref<?xf32>
      %50 = arith.addi %40, %11 : index
      memref.store %49, %alloca[%50] : memref<1xf32, 5>
    }
    nvvm.barrier0
    %22 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
    %23 = llvm.mlir.zero : !llvm.ptr
    %24 = llvm.icmp "ne" %22, %23 : !llvm.ptr
    %25 = arith.muli %13, %arg6 : i32
    %26 = arith.muli %7, %25 : i32
    %27 = arith.muli %9, %arg6 : i32
    %28 = arith.addi %26, %27 : i32
    %29 = arith.index_cast %28 : i32 to index
    %30 = arith.index_cast %arg6 : i32 to index
    %31 = arith.index_cast %arg4 : i32 to index
    %32 = arith.muli %arg4, %arg5 : i32
    %33 = arith.muli %7, %32 : i32
    %34 = arith.index_cast %33 : i32 to index
    %35 = arith.subi %30, %11 : index
    %36 = arith.addi %19, %35 : index
    %37 = arith.divui %36, %16 : index
    %38 = arith.addi %11, %2 : index
    %39:3 = scf.for %arg11 = %c0 to %37 step %c1 iter_args(%arg12 = %5, %arg13 = %5, %arg14 = %5) -> (i32, i32, i32) {
      %40 = arith.muli %arg11, %16 : index
      %41 = arith.addi %11, %40 : index
      %42 = arith.index_cast %41 : index to i32
      %43 = arith.addi %42, %arg9 : i32
      %44:4 = scf.for %arg15 = %c0 to %4 step %c1 iter_args(%arg16 = %arg12, %arg17 = %arg13, %arg18 = %arg14, %arg19 = %cst) -> (i32, i32, i32, f32) {
        %48 = arith.index_cast %arg15 : index to i32
        %49 = arith.muli %48, %arg10 : i32
        %50 = arith.subi %43, %49 : i32
        %51 = arith.remsi %50, %arg8 : i32
        %52 = arith.cmpi eq, %51, %c0_i32 : i32
        %53:4 = scf.if %52 -> (i32, i32, i32, f32) {
          %54 = arith.divsi %50, %arg8 : i32
          %55 = arith.muli %arg15, %1 : index
          %56 = arith.subi %38, %55 : index
          %57 = arith.addi %56, %40 : index
          %58 = arith.cmpi slt, %57, %c0 : index
          %59 = arith.subi %c-1, %57 : index
          %60 = arith.select %58, %59, %57 : index
          %61 = arith.divsi %60, %0 : index
          %62 = arith.subi %c-1, %61 : index
          %63 = arith.select %58, %62, %61 : index
          %64 = arith.subi %c-1, %63 : index
          %65 = arith.cmpi sge, %64, %c0 : index
          %66 = scf.if %65 -> (i1) {
            scf.yield %true : i1
          } else {
            %69 = arith.cmpi sge, %54, %arg5 : i32
            scf.yield %69 : i1
          }
          %67 = arith.select %66, %arg17, %arg4 : i32
          %68:2 = scf.if %66 -> (i32, f32) {
            scf.yield %arg16, %arg19 : i32, f32
          } else {
            %69:2 = scf.for %arg20 = %c0 to %31 step %c1 iter_args(%arg21 = %arg19, %arg22 = %arg16) -> (f32, i32) {
              %70 = arith.index_cast %arg20 : index to i32
              %71 = arith.muli %70, %arg5 : i32
              %72 = arith.addi %33, %71 : i32
              %73 = arith.addi %72, %54 : i32
              %74 = arith.muli %arg20, %3 : index
              %75 = arith.addi %74, %34 : index
              %76 = arith.addi %75, %63 : index
              %77 = memref.load %arg0[%76] : memref<?xf32>
              %78 = arith.muli %arg20, %4 : index
              %79 = arith.addi %arg15, %78 : index
              %80 = memref.load %alloca[%79] : memref<1xf32, 5>
              %81 = arith.mulf %77, %80 : f32
              %82 = arith.addf %arg21, %81 : f32
              scf.yield %82, %73 : f32, i32
            }
            scf.yield %69#1, %69#0 : i32, f32
          }
          scf.yield %54, %68#0, %67, %68#1 : i32, i32, i32, f32
        } else {
          scf.yield %arg18, %arg16, %arg17, %arg19 : i32, i32, i32, f32
        }
        scf.yield %53#1, %53#2, %53#0, %53#3 : i32, i32, i32, f32
      }
      %45 = scf.if %24 -> (f32) {
        %48 = memref.load %arg2[%8] : memref<?xf32>
        %49 = arith.addf %44#3, %48 : f32
        scf.yield %49 : f32
      } else {
        scf.yield %44#3 : f32
      }
      %46 = arith.addi %40, %29 : index
      %47 = arith.addi %46, %11 : index
      memref.store %45, %arg3[%47] : memref<?xf32>
      scf.yield %44#0, %44#1, %44#2 : i32, i32, i32
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): before execute: end
WrapAndReplaceBarrierPass::runOnOperation(): after execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    scf.parallel (%arg11) = (%c0) to (%c32) step (%c1) {
      %c-1 = arith.constant -1 : index
      %c0_0 = arith.constant 0 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %c1_1 = arith.constant 1 : index
      %0 = arith.index_cast %arg8 : i32 to index
      %1 = arith.index_cast %arg10 : i32 to index
      %2 = arith.index_cast %arg9 : i32 to index
      %3 = arith.index_cast %arg5 : i32 to index
      %4 = arith.index_cast %arg7 : i32 to index
      %5 = llvm.mlir.undef : i32
      %6 = gpu.block_id  x
      %7 = arith.index_cast %6 : index to i32
      %8 = gpu.block_id  y
      %9 = arith.index_cast %8 : index to i32
      %10 = arith.muli %arg4, %arg7 : i32
      %11 = gpu.grid_dim  y
      %12 = arith.index_cast %11 : index to i32
      %13 = arith.muli %12, %arg7 : i32
      %14 = arith.muli %9, %arg7 : i32
      %15 = gpu.block_dim  x
      %16 = arith.index_cast %10 : i32 to index
      %17 = arith.subi %16, %arg11 : index
      %18 = arith.subi %15, %c1_1 : index
      %19 = arith.addi %18, %17 : index
      %20 = arith.divui %19, %15 : index
      scf.for %arg12 = %c0_0 to %20 step %c1_1 {
        %39 = arith.muli %arg12, %15 : index
        %40 = arith.addi %arg11, %39 : index
        %41 = arith.index_cast %40 : index to i32
        %42 = arith.divsi %41, %arg7 : i32
        %43 = arith.remsi %41, %arg7 : i32
        %44 = arith.muli %42, %13 : i32
        %45 = arith.addi %44, %14 : i32
        %46 = arith.addi %45, %43 : i32
        %47 = arith.index_cast %46 : i32 to index
        %48 = memref.load %arg1[%47] : memref<?xf32>
        %49 = arith.addi %39, %arg11 : index
        memref.store %48, %alloca[%49] : memref<1xf32, 5>
      }
      "polygeist.barrier"(%arg11) : (index) -> ()
      %21 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %22 = llvm.mlir.zero : !llvm.ptr
      %23 = llvm.icmp "ne" %21, %22 : !llvm.ptr
      %24 = arith.muli %12, %arg6 : i32
      %25 = arith.muli %7, %24 : i32
      %26 = arith.muli %9, %arg6 : i32
      %27 = arith.addi %25, %26 : i32
      %28 = arith.index_cast %27 : i32 to index
      %29 = arith.index_cast %arg6 : i32 to index
      %30 = arith.index_cast %arg4 : i32 to index
      %31 = arith.muli %arg4, %arg5 : i32
      %32 = arith.muli %7, %31 : i32
      %33 = arith.index_cast %32 : i32 to index
      %34 = arith.subi %29, %arg11 : index
      %35 = arith.addi %18, %34 : index
      %36 = arith.divui %35, %15 : index
      %37 = arith.addi %arg11, %2 : index
      %38:3 = scf.for %arg12 = %c0_0 to %36 step %c1_1 iter_args(%arg13 = %5, %arg14 = %5, %arg15 = %5) -> (i32, i32, i32) {
        %39 = arith.muli %arg12, %15 : index
        %40 = arith.addi %arg11, %39 : index
        %41 = arith.index_cast %40 : index to i32
        %42 = arith.addi %41, %arg9 : i32
        %43:4 = scf.for %arg16 = %c0_0 to %4 step %c1_1 iter_args(%arg17 = %arg13, %arg18 = %arg14, %arg19 = %arg15, %arg20 = %cst) -> (i32, i32, i32, f32) {
          %47 = arith.index_cast %arg16 : index to i32
          %48 = arith.muli %47, %arg10 : i32
          %49 = arith.subi %42, %48 : i32
          %50 = arith.remsi %49, %arg8 : i32
          %51 = arith.cmpi eq, %50, %c0_i32 : i32
          %52:4 = scf.if %51 -> (i32, i32, i32, f32) {
            %53 = arith.divsi %49, %arg8 : i32
            %54 = arith.muli %arg16, %1 : index
            %55 = arith.subi %37, %54 : index
            %56 = arith.addi %55, %39 : index
            %57 = arith.cmpi slt, %56, %c0_0 : index
            %58 = arith.subi %c-1, %56 : index
            %59 = arith.select %57, %58, %56 : index
            %60 = arith.divsi %59, %0 : index
            %61 = arith.subi %c-1, %60 : index
            %62 = arith.select %57, %61, %60 : index
            %63 = arith.subi %c-1, %62 : index
            %64 = arith.cmpi sge, %63, %c0_0 : index
            %65 = scf.if %64 -> (i1) {
              scf.yield %true : i1
            } else {
              %68 = arith.cmpi sge, %53, %arg5 : i32
              scf.yield %68 : i1
            }
            %66 = arith.select %65, %arg18, %arg4 : i32
            %67:2 = scf.if %65 -> (i32, f32) {
              scf.yield %arg17, %arg20 : i32, f32
            } else {
              %68:2 = scf.for %arg21 = %c0_0 to %30 step %c1_1 iter_args(%arg22 = %arg20, %arg23 = %arg17) -> (f32, i32) {
                %69 = arith.index_cast %arg21 : index to i32
                %70 = arith.muli %69, %arg5 : i32
                %71 = arith.addi %32, %70 : i32
                %72 = arith.addi %71, %53 : i32
                %73 = arith.muli %arg21, %3 : index
                %74 = arith.addi %73, %33 : index
                %75 = arith.addi %74, %62 : index
                %76 = memref.load %arg0[%75] : memref<?xf32>
                %77 = arith.muli %arg21, %4 : index
                %78 = arith.addi %arg16, %77 : index
                %79 = memref.load %alloca[%78] : memref<1xf32, 5>
                %80 = arith.mulf %76, %79 : f32
                %81 = arith.addf %arg22, %80 : f32
                scf.yield %81, %72 : f32, i32
              }
              scf.yield %68#1, %68#0 : i32, f32
            }
            scf.yield %53, %67#0, %66, %67#1 : i32, i32, i32, f32
          } else {
            scf.yield %arg19, %arg17, %arg18, %arg20 : i32, i32, i32, f32
          }
          scf.yield %52#1, %52#2, %52#0, %52#3 : i32, i32, i32, f32
        }
        %44 = scf.if %23 -> (f32) {
          %47 = memref.load %arg2[%8] : memref<?xf32>
          %48 = arith.addf %43#3, %47 : f32
          scf.yield %48 : f32
        } else {
          scf.yield %43#3 : f32
        }
        %45 = arith.addi %39, %28 : index
        %46 = arith.addi %45, %arg11 : index
        memref.store %44, %arg3[%46] : memref<?xf32>
        scf.yield %43#0, %43#1, %43#2 : i32, i32, i32
      }
      scf.yield
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): after execute: end
[ict-debug] driver.cc: After return 7, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    scf.parallel (%arg11) = (%c0) to (%c32) step (%c1) {
      %c-1 = arith.constant -1 : index
      %c0_0 = arith.constant 0 : index
      %cst = arith.constant 0.000000e+00 : f32
      %c0_i32 = arith.constant 0 : i32
      %true = arith.constant true
      %c1_1 = arith.constant 1 : index
      %0 = arith.index_cast %arg8 : i32 to index
      %1 = arith.index_cast %arg10 : i32 to index
      %2 = arith.index_cast %arg9 : i32 to index
      %3 = arith.index_cast %arg5 : i32 to index
      %4 = arith.index_cast %arg7 : i32 to index
      %5 = llvm.mlir.undef : i32
      %6 = gpu.block_id  x
      %7 = arith.index_cast %6 : index to i32
      %8 = gpu.block_id  y
      %9 = arith.index_cast %8 : index to i32
      %10 = arith.muli %arg4, %arg7 : i32
      %11 = gpu.grid_dim  y
      %12 = arith.index_cast %11 : index to i32
      %13 = arith.muli %12, %arg7 : i32
      %14 = arith.muli %9, %arg7 : i32
      %15 = gpu.block_dim  x
      %16 = arith.index_cast %10 : i32 to index
      %17 = arith.subi %16, %arg11 : index
      %18 = arith.subi %15, %c1_1 : index
      %19 = arith.addi %18, %17 : index
      %20 = arith.divui %19, %15 : index
      scf.for %arg12 = %c0_0 to %20 step %c1_1 {
        %39 = arith.muli %arg12, %15 : index
        %40 = arith.addi %arg11, %39 : index
        %41 = arith.index_cast %40 : index to i32
        %42 = arith.divsi %41, %arg7 : i32
        %43 = arith.remsi %41, %arg7 : i32
        %44 = arith.muli %42, %13 : i32
        %45 = arith.addi %44, %14 : i32
        %46 = arith.addi %45, %43 : i32
        %47 = arith.index_cast %46 : i32 to index
        %48 = memref.load %arg1[%47] : memref<?xf32>
        %49 = arith.addi %39, %arg11 : index
        memref.store %48, %alloca[%49] : memref<1xf32, 5>
      }
      "polygeist.barrier"(%arg11) : (index) -> ()
      %21 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %22 = llvm.mlir.zero : !llvm.ptr
      %23 = llvm.icmp "ne" %21, %22 : !llvm.ptr
      %24 = arith.muli %12, %arg6 : i32
      %25 = arith.muli %7, %24 : i32
      %26 = arith.muli %9, %arg6 : i32
      %27 = arith.addi %25, %26 : i32
      %28 = arith.index_cast %27 : i32 to index
      %29 = arith.index_cast %arg6 : i32 to index
      %30 = arith.index_cast %arg4 : i32 to index
      %31 = arith.muli %arg4, %arg5 : i32
      %32 = arith.muli %7, %31 : i32
      %33 = arith.index_cast %32 : i32 to index
      %34 = arith.subi %29, %arg11 : index
      %35 = arith.addi %18, %34 : index
      %36 = arith.divui %35, %15 : index
      %37 = arith.addi %arg11, %2 : index
      %38:3 = scf.for %arg12 = %c0_0 to %36 step %c1_1 iter_args(%arg13 = %5, %arg14 = %5, %arg15 = %5) -> (i32, i32, i32) {
        %39 = arith.muli %arg12, %15 : index
        %40 = arith.addi %arg11, %39 : index
        %41 = arith.index_cast %40 : index to i32
        %42 = arith.addi %41, %arg9 : i32
        %43:4 = scf.for %arg16 = %c0_0 to %4 step %c1_1 iter_args(%arg17 = %arg13, %arg18 = %arg14, %arg19 = %arg15, %arg20 = %cst) -> (i32, i32, i32, f32) {
          %47 = arith.index_cast %arg16 : index to i32
          %48 = arith.muli %47, %arg10 : i32
          %49 = arith.subi %42, %48 : i32
          %50 = arith.remsi %49, %arg8 : i32
          %51 = arith.cmpi eq, %50, %c0_i32 : i32
          %52:4 = scf.if %51 -> (i32, i32, i32, f32) {
            %53 = arith.divsi %49, %arg8 : i32
            %54 = arith.muli %arg16, %1 : index
            %55 = arith.subi %37, %54 : index
            %56 = arith.addi %55, %39 : index
            %57 = arith.cmpi slt, %56, %c0_0 : index
            %58 = arith.subi %c-1, %56 : index
            %59 = arith.select %57, %58, %56 : index
            %60 = arith.divsi %59, %0 : index
            %61 = arith.subi %c-1, %60 : index
            %62 = arith.select %57, %61, %60 : index
            %63 = arith.subi %c-1, %62 : index
            %64 = arith.cmpi sge, %63, %c0_0 : index
            %65 = scf.if %64 -> (i1) {
              scf.yield %true : i1
            } else {
              %68 = arith.cmpi sge, %53, %arg5 : i32
              scf.yield %68 : i1
            }
            %66 = arith.select %65, %arg18, %arg4 : i32
            %67:2 = scf.if %65 -> (i32, f32) {
              scf.yield %arg17, %arg20 : i32, f32
            } else {
              %68:2 = scf.for %arg21 = %c0_0 to %30 step %c1_1 iter_args(%arg22 = %arg20, %arg23 = %arg17) -> (f32, i32) {
                %69 = arith.index_cast %arg21 : index to i32
                %70 = arith.muli %69, %arg5 : i32
                %71 = arith.addi %32, %70 : i32
                %72 = arith.addi %71, %53 : i32
                %73 = arith.muli %arg21, %3 : index
                %74 = arith.addi %73, %33 : index
                %75 = arith.addi %74, %62 : index
                %76 = memref.load %arg0[%75] : memref<?xf32>
                %77 = arith.muli %arg21, %4 : index
                %78 = arith.addi %arg16, %77 : index
                %79 = memref.load %alloca[%78] : memref<1xf32, 5>
                %80 = arith.mulf %76, %79 : f32
                %81 = arith.addf %arg22, %80 : f32
                scf.yield %81, %72 : f32, i32
              }
              scf.yield %68#1, %68#0 : i32, f32
            }
            scf.yield %53, %67#0, %66, %67#1 : i32, i32, i32, f32
          } else {
            scf.yield %arg19, %arg17, %arg18, %arg20 : i32, i32, i32, f32
          }
          scf.yield %52#1, %52#2, %52#0, %52#3 : i32, i32, i32, f32
        }
        %44 = scf.if %23 -> (f32) {
          %47 = memref.load %arg2[%8] : memref<?xf32>
          %48 = arith.addf %43#3, %47 : f32
          scf.yield %48 : f32
        } else {
          scf.yield %43#3 : f32
        }
        %45 = arith.addi %39, %28 : index
        %46 = arith.addi %45, %arg11 : index
        memref.store %44, %arg3[%46] : memref<?xf32>
        scf.yield %43#0, %43#1, %43#2 : i32, i32, i32
      }
      scf.yield
    }
    return
  }
}
[ict-debug] driver.cc: After return 7, module: end

[ict-debug] driver.cc: Before my pass process:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %true = arith.constant true
    %c0_i32 = arith.constant 0 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %c-1 = arith.constant -1 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    %0 = gpu.block_id  y
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.muli %arg4, %arg7 : i32
    %3 = gpu.grid_dim  y
    %4 = arith.index_cast %3 : index to i32
    %5 = arith.muli %4, %arg7 : i32
    %6 = arith.muli %1, %arg7 : i32
    %7 = gpu.block_dim  x
    %8 = arith.index_cast %2 : i32 to index
    %9 = arith.subi %7, %c1 : index
    scf.parallel (%arg11) = (%c0) to (%c32) step (%c1) {
      %37 = arith.subi %8, %arg11 : index
      %38 = arith.addi %9, %37 : index
      %39 = arith.divui %38, %7 : index
      scf.for %arg12 = %c0 to %39 step %c1 {
        %40 = arith.muli %arg12, %7 : index
        %41 = arith.addi %arg11, %40 : index
        %42 = arith.index_cast %41 : index to i32
        %43 = arith.divsi %42, %arg7 : i32
        %44 = arith.remsi %42, %arg7 : i32
        %45 = arith.muli %43, %5 : i32
        %46 = arith.addi %45, %6 : i32
        %47 = arith.addi %46, %44 : i32
        %48 = arith.index_cast %47 : i32 to index
        %49 = memref.load %arg1[%48] : memref<?xf32>
        %50 = arith.addi %40, %arg11 : index
        memref.store %49, %alloca[%50] : memref<1xf32, 5>
      }
      scf.yield
    }
    %10 = gpu.block_dim  x
    %11 = arith.subi %10, %c1 : index
    %12 = gpu.grid_dim  y
    %13 = arith.index_cast %12 : index to i32
    %14 = gpu.block_id  y
    %15 = arith.index_cast %14 : index to i32
    %16 = gpu.block_id  x
    %17 = arith.index_cast %16 : index to i32
    %18 = llvm.mlir.undef : i32
    %19 = arith.index_cast %arg7 : i32 to index
    %20 = arith.index_cast %arg5 : i32 to index
    %21 = arith.index_cast %arg9 : i32 to index
    %22 = arith.index_cast %arg10 : i32 to index
    %23 = arith.index_cast %arg8 : i32 to index
    %24 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
    %25 = llvm.mlir.zero : !llvm.ptr
    %26 = llvm.icmp "ne" %24, %25 : !llvm.ptr
    %27 = arith.muli %13, %arg6 : i32
    %28 = arith.muli %17, %27 : i32
    %29 = arith.muli %15, %arg6 : i32
    %30 = arith.addi %28, %29 : i32
    %31 = arith.index_cast %30 : i32 to index
    %32 = arith.index_cast %arg6 : i32 to index
    %33 = arith.index_cast %arg4 : i32 to index
    %34 = arith.muli %arg4, %arg5 : i32
    %35 = arith.muli %17, %34 : i32
    %36 = arith.index_cast %35 : i32 to index
    scf.parallel (%arg11) = (%c0) to (%c32) step (%c1) {
      %37 = arith.subi %32, %arg11 : index
      %38 = arith.addi %11, %37 : index
      %39 = arith.divui %38, %10 : index
      %40 = arith.addi %arg11, %21 : index
      %41:3 = scf.for %arg12 = %c0 to %39 step %c1 iter_args(%arg13 = %18, %arg14 = %18, %arg15 = %18) -> (i32, i32, i32) {
        %42 = arith.muli %arg12, %10 : index
        %43 = arith.addi %arg11, %42 : index
        %44 = arith.index_cast %43 : index to i32
        %45 = arith.addi %44, %arg9 : i32
        %46:4 = scf.for %arg16 = %c0 to %19 step %c1 iter_args(%arg17 = %arg13, %arg18 = %arg14, %arg19 = %arg15, %arg20 = %cst) -> (i32, i32, i32, f32) {
          %50 = arith.index_cast %arg16 : index to i32
          %51 = arith.muli %50, %arg10 : i32
          %52 = arith.subi %45, %51 : i32
          %53 = arith.remsi %52, %arg8 : i32
          %54 = arith.cmpi eq, %53, %c0_i32 : i32
          %55:4 = scf.if %54 -> (i32, i32, i32, f32) {
            %56 = arith.divsi %52, %arg8 : i32
            %57 = arith.muli %arg16, %22 : index
            %58 = arith.subi %40, %57 : index
            %59 = arith.addi %58, %42 : index
            %60 = arith.cmpi slt, %59, %c0 : index
            %61 = arith.subi %c-1, %59 : index
            %62 = arith.select %60, %61, %59 : index
            %63 = arith.divsi %62, %23 : index
            %64 = arith.subi %c-1, %63 : index
            %65 = arith.select %60, %64, %63 : index
            %66 = arith.subi %c-1, %65 : index
            %67 = arith.cmpi sge, %66, %c0 : index
            %68 = scf.if %67 -> (i1) {
              scf.yield %true : i1
            } else {
              %71 = arith.cmpi sge, %56, %arg5 : i32
              scf.yield %71 : i1
            }
            %69 = arith.select %68, %arg18, %arg4 : i32
            %70:2 = scf.if %68 -> (i32, f32) {
              scf.yield %arg17, %arg20 : i32, f32
            } else {
              %71:2 = scf.for %arg21 = %c0 to %33 step %c1 iter_args(%arg22 = %arg20, %arg23 = %arg17) -> (f32, i32) {
                %72 = arith.index_cast %arg21 : index to i32
                %73 = arith.muli %72, %arg5 : i32
                %74 = arith.addi %35, %73 : i32
                %75 = arith.addi %74, %56 : i32
                %76 = arith.muli %arg21, %20 : index
                %77 = arith.addi %76, %36 : index
                %78 = arith.addi %77, %65 : index
                %79 = memref.load %arg0[%78] : memref<?xf32>
                %80 = arith.muli %arg21, %19 : index
                %81 = arith.addi %arg16, %80 : index
                %82 = memref.load %alloca[%81] : memref<1xf32, 5>
                %83 = arith.mulf %79, %82 : f32
                %84 = arith.addf %arg22, %83 : f32
                scf.yield %84, %75 : f32, i32
              }
              scf.yield %71#1, %71#0 : i32, f32
            }
            scf.yield %56, %70#0, %69, %70#1 : i32, i32, i32, f32
          } else {
            scf.yield %arg19, %arg17, %arg18, %arg20 : i32, i32, i32, f32
          }
          scf.yield %55#1, %55#2, %55#0, %55#3 : i32, i32, i32, f32
        }
        %47 = scf.if %26 -> (f32) {
          %50 = memref.load %arg2[%14] : memref<?xf32>
          %51 = arith.addf %46#3, %50 : f32
          scf.yield %51 : f32
        } else {
          scf.yield %46#3 : f32
        }
        %48 = arith.addi %42, %31 : index
        %49 = arith.addi %48, %arg11 : index
        memref.store %47, %arg3[%49] : memref<?xf32>
        scf.yield %46#0, %46#1, %46#2 : i32, i32, i32
      }
      scf.yield
    }
    return
  }
}
[ict-debug] driver.cc: Before my pass process: end

[ict-debug] driver.cc: vectorizeSize = 1

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii_0 {
    gpu.func @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32) {
      %true = arith.constant true
      %c0_i32 = arith.constant 0 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c-1 = arith.constant -1 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %alloca = memref.alloca() : memref<1xf32, 5>
      %0 = gpu.block_id  y
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.muli %arg4, %arg7 : i32
      %3 = gpu.grid_dim  y
      %4 = arith.index_cast %3 : index to i32
      %5 = arith.muli %4, %arg7 : i32
      %6 = arith.muli %1, %arg7 : i32
      %7 = gpu.block_dim  x
      %8 = arith.index_cast %2 : i32 to index
      %9 = arith.subi %7, %c1 : index
      scf.parallel (%arg11) = (%c0) to (%c32) step (%c1) {
        %31 = arith.subi %8, %arg11 : index
        %32 = arith.addi %9, %31 : index
        %33 = arith.divui %32, %7 : index
        scf.for %arg12 = %c0 to %33 step %c1 {
          %34 = arith.muli %arg12, %7 : index
          %35 = arith.addi %arg11, %34 : index
          %36 = arith.index_cast %35 : index to i32
          %37 = arith.divsi %36, %arg7 : i32
          %38 = arith.remsi %36, %arg7 : i32
          %39 = arith.muli %37, %5 : i32
          %40 = arith.addi %39, %6 : i32
          %41 = arith.addi %40, %38 : i32
          %42 = arith.index_cast %41 : i32 to index
          %43 = memref.load %arg1[%42] : memref<?xf32>
          %44 = arith.addi %34, %arg11 : index
          memref.store %43, %alloca[%44] : memref<1xf32, 5>
        }
        scf.yield
      }
      %10 = gpu.block_id  x
      %11 = arith.index_cast %10 : index to i32
      %12 = llvm.mlir.undef : i32
      %13 = arith.index_cast %arg7 : i32 to index
      %14 = arith.index_cast %arg5 : i32 to index
      %15 = arith.index_cast %arg9 : i32 to index
      %16 = arith.index_cast %arg10 : i32 to index
      %17 = arith.index_cast %arg8 : i32 to index
      %18 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %19 = llvm.mlir.zero : !llvm.ptr
      %20 = llvm.icmp "ne" %18, %19 : !llvm.ptr
      %21 = arith.muli %4, %arg6 : i32
      %22 = arith.muli %11, %21 : i32
      %23 = arith.muli %1, %arg6 : i32
      %24 = arith.addi %22, %23 : i32
      %25 = arith.index_cast %24 : i32 to index
      %26 = arith.index_cast %arg6 : i32 to index
      %27 = arith.index_cast %arg4 : i32 to index
      %28 = arith.muli %arg4, %arg5 : i32
      %29 = arith.muli %11, %28 : i32
      %30 = arith.index_cast %29 : i32 to index
      scf.parallel (%arg11) = (%c0) to (%c32) step (%c1) {
        %31 = arith.subi %26, %arg11 : index
        %32 = arith.addi %9, %31 : index
        %33 = arith.divui %32, %7 : index
        %34 = arith.addi %arg11, %15 : index
        %35:3 = scf.for %arg12 = %c0 to %33 step %c1 iter_args(%arg13 = %12, %arg14 = %12, %arg15 = %12) -> (i32, i32, i32) {
          %36 = arith.muli %arg12, %7 : index
          %37 = arith.addi %arg11, %36 : index
          %38 = arith.index_cast %37 : index to i32
          %39 = arith.addi %38, %arg9 : i32
          %40:4 = scf.for %arg16 = %c0 to %13 step %c1 iter_args(%arg17 = %arg13, %arg18 = %arg14, %arg19 = %arg15, %arg20 = %cst) -> (i32, i32, i32, f32) {
            %44 = arith.index_cast %arg16 : index to i32
            %45 = arith.muli %44, %arg10 : i32
            %46 = arith.subi %39, %45 : i32
            %47 = arith.remsi %46, %arg8 : i32
            %48 = arith.cmpi eq, %47, %c0_i32 : i32
            %49:4 = scf.if %48 -> (i32, i32, i32, f32) {
              %50 = arith.divsi %46, %arg8 : i32
              %51 = arith.muli %arg16, %16 : index
              %52 = arith.subi %34, %51 : index
              %53 = arith.addi %52, %36 : index
              %54 = arith.cmpi slt, %53, %c0 : index
              %55 = arith.subi %c-1, %53 : index
              %56 = arith.select %54, %55, %53 : index
              %57 = arith.divsi %56, %17 : index
              %58 = arith.subi %c-1, %57 : index
              %59 = arith.select %54, %58, %57 : index
              %60 = arith.subi %c-1, %59 : index
              %61 = arith.cmpi sge, %60, %c0 : index
              %62 = scf.if %61 -> (i1) {
                scf.yield %true : i1
              } else {
                %65 = arith.cmpi sge, %50, %arg5 : i32
                scf.yield %65 : i1
              }
              %63 = arith.select %62, %arg18, %arg4 : i32
              %64:2 = scf.if %62 -> (i32, f32) {
                scf.yield %arg17, %arg20 : i32, f32
              } else {
                %65:2 = scf.for %arg21 = %c0 to %27 step %c1 iter_args(%arg22 = %arg20, %arg23 = %arg17) -> (f32, i32) {
                  %66 = arith.index_cast %arg21 : index to i32
                  %67 = arith.muli %66, %arg5 : i32
                  %68 = arith.addi %29, %67 : i32
                  %69 = arith.addi %68, %50 : i32
                  %70 = arith.muli %arg21, %14 : index
                  %71 = arith.addi %70, %30 : index
                  %72 = arith.addi %71, %59 : index
                  %73 = memref.load %arg0[%72] : memref<?xf32>
                  %74 = arith.muli %arg21, %13 : index
                  %75 = arith.addi %arg16, %74 : index
                  %76 = memref.load %alloca[%75] : memref<1xf32, 5>
                  %77 = arith.mulf %73, %76 : f32
                  %78 = arith.addf %arg22, %77 : f32
                  scf.yield %78, %69 : f32, i32
                }
                scf.yield %65#1, %65#0 : i32, f32
              }
              scf.yield %50, %64#0, %63, %64#1 : i32, i32, i32, f32
            } else {
              scf.yield %arg19, %arg17, %arg18, %arg20 : i32, i32, i32, f32
            }
            scf.yield %49#1, %49#2, %49#0, %49#3 : i32, i32, i32, f32
          }
          %41 = scf.if %20 -> (f32) {
            %44 = memref.load %arg2[%0] : memref<?xf32>
            %45 = arith.addf %40#3, %44 : f32
            scf.yield %45 : f32
          } else {
            scf.yield %40#3 : f32
          }
          %42 = arith.addi %36, %25 : index
          %43 = arith.addi %42, %arg11 : index
          memref.store %41, %arg3[%43] : memref<?xf32>
          scf.yield %40#0, %40#1, %40#2 : i32, i32, i32
        }
        scf.yield
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute: end

[ict-debug] ConvertPolygeistToNPU:convertScfParallelToScfFor(): replace gpu.block_dim op with thread loop bound

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii_0 {
    gpu.func @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32) {
      %true = arith.constant true
      %c0_i32 = arith.constant 0 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c-1 = arith.constant -1 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %alloca = memref.alloca() : memref<1xf32, 5>
      %0 = gpu.block_id  y
      %1 = arith.index_cast %0 : index to i32
      %2 = arith.muli %arg4, %arg7 : i32
      %3 = gpu.grid_dim  y
      %4 = arith.index_cast %3 : index to i32
      %5 = arith.muli %4, %arg7 : i32
      %6 = arith.muli %1, %arg7 : i32
      %c32_0 = arith.constant 32 : index
      %7 = arith.index_cast %2 : i32 to index
      %8 = arith.subi %c32_0, %c1 : index
      %c1_1 = arith.constant 1 : index
      scf.for %arg11 = %c0 to %c32 step %c1_1 {
        %30 = arith.subi %7, %arg11 : index
        %31 = arith.addi %8, %30 : index
        %32 = arith.divui %31, %c32_0 : index
        scf.for %arg12 = %c0 to %32 step %c1 {
          %33 = arith.muli %arg12, %c32_0 : index
          %34 = arith.addi %arg11, %33 : index
          %35 = arith.index_cast %34 : index to i32
          %36 = arith.divsi %35, %arg7 : i32
          %37 = arith.remsi %35, %arg7 : i32
          %38 = arith.muli %36, %5 : i32
          %39 = arith.addi %38, %6 : i32
          %40 = arith.addi %39, %37 : i32
          %41 = arith.index_cast %40 : i32 to index
          %42 = memref.load %arg1[%41] : memref<?xf32>
          %43 = arith.addi %33, %arg11 : index
          memref.store %42, %alloca[%43] : memref<1xf32, 5>
        }
      }
      %9 = gpu.block_id  x
      %10 = arith.index_cast %9 : index to i32
      %11 = llvm.mlir.undef : i32
      %12 = arith.index_cast %arg7 : i32 to index
      %13 = arith.index_cast %arg5 : i32 to index
      %14 = arith.index_cast %arg9 : i32 to index
      %15 = arith.index_cast %arg10 : i32 to index
      %16 = arith.index_cast %arg8 : i32 to index
      %17 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %18 = llvm.mlir.zero : !llvm.ptr
      %19 = llvm.icmp "ne" %17, %18 : !llvm.ptr
      %20 = arith.muli %4, %arg6 : i32
      %21 = arith.muli %10, %20 : i32
      %22 = arith.muli %1, %arg6 : i32
      %23 = arith.addi %21, %22 : i32
      %24 = arith.index_cast %23 : i32 to index
      %25 = arith.index_cast %arg6 : i32 to index
      %26 = arith.index_cast %arg4 : i32 to index
      %27 = arith.muli %arg4, %arg5 : i32
      %28 = arith.muli %10, %27 : i32
      %29 = arith.index_cast %28 : i32 to index
      %c1_2 = arith.constant 1 : index
      scf.for %arg11 = %c0 to %c32 step %c1_2 {
        %30 = arith.subi %25, %arg11 : index
        %31 = arith.addi %8, %30 : index
        %32 = arith.divui %31, %c32_0 : index
        %33 = arith.addi %arg11, %14 : index
        %34:3 = scf.for %arg12 = %c0 to %32 step %c1 iter_args(%arg13 = %11, %arg14 = %11, %arg15 = %11) -> (i32, i32, i32) {
          %35 = arith.muli %arg12, %c32_0 : index
          %36 = arith.addi %arg11, %35 : index
          %37 = arith.index_cast %36 : index to i32
          %38 = arith.addi %37, %arg9 : i32
          %39:4 = scf.for %arg16 = %c0 to %12 step %c1 iter_args(%arg17 = %arg13, %arg18 = %arg14, %arg19 = %arg15, %arg20 = %cst) -> (i32, i32, i32, f32) {
            %43 = arith.index_cast %arg16 : index to i32
            %44 = arith.muli %43, %arg10 : i32
            %45 = arith.subi %38, %44 : i32
            %46 = arith.remsi %45, %arg8 : i32
            %47 = arith.cmpi eq, %46, %c0_i32 : i32
            %48:4 = scf.if %47 -> (i32, i32, i32, f32) {
              %49 = arith.divsi %45, %arg8 : i32
              %50 = arith.muli %arg16, %15 : index
              %51 = arith.subi %33, %50 : index
              %52 = arith.addi %51, %35 : index
              %53 = arith.cmpi slt, %52, %c0 : index
              %54 = arith.subi %c-1, %52 : index
              %55 = arith.select %53, %54, %52 : index
              %56 = arith.divsi %55, %16 : index
              %57 = arith.subi %c-1, %56 : index
              %58 = arith.select %53, %57, %56 : index
              %59 = arith.subi %c-1, %58 : index
              %60 = arith.cmpi sge, %59, %c0 : index
              %61 = scf.if %60 -> (i1) {
                scf.yield %true : i1
              } else {
                %64 = arith.cmpi sge, %49, %arg5 : i32
                scf.yield %64 : i1
              }
              %62 = arith.select %61, %arg18, %arg4 : i32
              %63:2 = scf.if %61 -> (i32, f32) {
                scf.yield %arg17, %arg20 : i32, f32
              } else {
                %64:2 = scf.for %arg21 = %c0 to %26 step %c1 iter_args(%arg22 = %arg20, %arg23 = %arg17) -> (f32, i32) {
                  %65 = arith.index_cast %arg21 : index to i32
                  %66 = arith.muli %65, %arg5 : i32
                  %67 = arith.addi %28, %66 : i32
                  %68 = arith.addi %67, %49 : i32
                  %69 = arith.muli %arg21, %13 : index
                  %70 = arith.addi %69, %29 : index
                  %71 = arith.addi %70, %58 : index
                  %72 = memref.load %arg0[%71] : memref<?xf32>
                  %73 = arith.muli %arg21, %12 : index
                  %74 = arith.addi %arg16, %73 : index
                  %75 = memref.load %alloca[%74] : memref<1xf32, 5>
                  %76 = arith.mulf %72, %75 : f32
                  %77 = arith.addf %arg22, %76 : f32
                  scf.yield %77, %68 : f32, i32
                }
                scf.yield %64#1, %64#0 : i32, f32
              }
              scf.yield %49, %63#0, %62, %63#1 : i32, i32, i32, f32
            } else {
              scf.yield %arg19, %arg17, %arg18, %arg20 : i32, i32, i32, f32
            }
            scf.yield %48#1, %48#2, %48#0, %48#3 : i32, i32, i32, f32
          }
          %40 = scf.if %19 -> (f32) {
            %43 = memref.load %arg2[%0] : memref<?xf32>
            %44 = arith.addf %39#3, %43 : f32
            scf.yield %44 : f32
          } else {
            scf.yield %39#3 : f32
          }
          %41 = arith.addi %35, %24 : index
          %42 = arith.addi %41, %arg11 : index
          memref.store %40, %arg3[%42] : memref<?xf32>
          scf.yield %39#0, %39#1, %39#2 : i32, i32, i32
        }
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize: end

[ict-debug] MemRefAllocaToNPULowering: process op: 

%alloca = memref.alloca() : memref<1xf32, 5>
[ict-debug] MemRefAllocaToNPULowering: memory space is 5

MemRefAllocaToNPULowering: newAllocaOp: 
%0 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
MemRefAllocaToNPULowering: old allocaOp: 
%alloca = memref.alloca() : memref<1xf32, 5>
MemRefAllocaToNPULowering: module: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii_0 {
    gpu.func @_Z30conv_transpose1d_shared_kernelPKfS0_S0_Pfiiiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32, %arg10: i32) {
      %true = arith.constant true
      %c0_i32 = arith.constant 0 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c-1 = arith.constant -1 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %alloca = memref.alloca() : memref<1xf32, 5>
      %1 = gpu.block_id  y
      %2 = arith.index_cast %1 : index to i32
      %3 = arith.muli %arg4, %arg7 : i32
      %4 = gpu.grid_dim  y
      %5 = arith.index_cast %4 : index to i32
      %6 = arith.muli %5, %arg7 : i32
      %7 = arith.muli %2, %arg7 : i32
      %c32_0 = arith.constant 32 : index
      %8 = arith.index_cast %3 : i32 to index
      %9 = arith.subi %c32_0, %c1 : index
      %c1_1 = arith.constant 1 : index
      scf.for %arg11 = %c0 to %c32 step %c1_1 {
        %31 = arith.subi %8, %arg11 : index
        %32 = arith.addi %9, %31 : index
        %33 = arith.divui %32, %c32_0 : index
        scf.for %arg12 = %c0 to %33 step %c1 {
          %34 = arith.muli %arg12, %c32_0 : index
          %35 = arith.addi %arg11, %34 : index
          %36 = arith.index_cast %35 : index to i32
          %37 = arith.divsi %36, %arg7 : i32
          %38 = arith.remsi %36, %arg7 : i32
          %39 = arith.muli %37, %6 : i32
          %40 = arith.addi %39, %7 : i32
          %41 = arith.addi %40, %38 : i32
          %42 = arith.index_cast %41 : i32 to index
          %43 = memref.load %arg1[%42] : memref<?xf32>
          %44 = arith.addi %34, %arg11 : index
          memref.store %43, %alloca[%44] : memref<1xf32, 5>
        }
      }
      %10 = gpu.block_id  x
      %11 = arith.index_cast %10 : index to i32
      %12 = llvm.mlir.undef : i32
      %13 = arith.index_cast %arg7 : i32 to index
      %14 = arith.index_cast %arg5 : i32 to index
      %15 = arith.index_cast %arg9 : i32 to index
      %16 = arith.index_cast %arg10 : i32 to index
      %17 = arith.index_cast %arg8 : i32 to index
      %18 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %19 = llvm.mlir.zero : !llvm.ptr
      %20 = llvm.icmp "ne" %18, %19 : !llvm.ptr
      %21 = arith.muli %5, %arg6 : i32
      %22 = arith.muli %11, %21 : i32
      %23 = arith.muli %2, %arg6 : i32
      %24 = arith.addi %22, %23 : i32
      %25 = arith.index_cast %24 : i32 to index
      %26 = arith.index_cast %arg6 : i32 to index
      %27 = arith.index_cast %arg4 : i32 to index
      %28 = arith.muli %arg4, %arg5 : i32
      %29 = arith.muli %11, %28 : i32
      %30 = arith.index_cast %29 : i32 to index
      %c1_2 = arith.constant 1 : index
      scf.for %arg11 = %c0 to %c32 step %c1_2 {
        %31 = arith.subi %26, %arg11 : index
        %32 = arith.addi %9, %31 : index
        %33 = arith.divui %32, %c32_0 : index
        %34 = arith.addi %arg11, %15 : index
        %35:3 = scf.for %arg12 = %c0 to %33 step %c1 iter_args(%arg13 = %12, %arg14 = %12, %arg15 = %12) -> (i32, i32, i32) {
          %36 = arith.muli %arg12, %c32_0 : index
          %37 = arith.addi %arg11, %36 : index
          %38 = arith.index_cast %37 : index to i32
          %39 = arith.addi %38, %arg9 : i32
          %40:4 = scf.for %arg16 = %c0 to %13 step %c1 iter_args(%arg17 = %arg13, %arg18 = %arg14, %arg19 = %arg15, %arg20 = %cst) -> (i32, i32, i32, f32) {
            %44 = arith.index_cast %arg16 : index to i32
            %45 = arith.muli %44, %arg10 : i32
            %46 = arith.subi %39, %45 : i32
            %47 = arith.remsi %46, %arg8 : i32
            %48 = arith.cmpi eq, %47, %c0_i32 : i32
            %49:4 = scf.if %48 -> (i32, i32, i32, f32) {
              %50 = arith.divsi %46, %arg8 : i32
              %51 = arith.muli %arg16, %16 : index
              %52 = arith.subi %34, %51 : index
              %53 = arith.addi %52, %36 : index
              %54 = arith.cmpi slt, %53, %c0 : index
              %55 = arith.subi %c-1, %53 : index
              %56 = arith.select %54, %55, %53 : index
              %57 = arith.divsi %56, %17 : index
              %58 = arith.subi %c-1, %57 : index
              %59 = arith.select %54, %58, %57 : index
              %60 = arith.subi %c-1, %59 : index
              %61 = arith.cmpi sge, %60, %c0 : index
              %62 = scf.if %61 -> (i1) {
                scf.yield %true : i1
              } else {
                %65 = arith.cmpi sge, %50, %arg5 : i32
                scf.yield %65 : i1
              }
              %63 = arith.select %62, %arg18, %arg4 : i32
              %64:2 = scf.if %62 -> (i32, f32) {
                scf.yield %arg17, %arg20 : i32, f32
              } else {
                %65:2 = scf.for %arg21 = %c0 to %27 step %c1 iter_args(%arg22 = %arg20, %arg23 = %arg17) -> (f32, i32) {
                  %66 = arith.index_cast %arg21 : index to i32
                  %67 = arith.muli %66, %arg5 : i32
                  %68 = arith.addi %29, %67 : i32
                  %69 = arith.addi %68, %50 : i32
                  %70 = arith.muli %arg21, %14 : index
                  %71 = arith.addi %70, %30 : index
                  %72 = arith.addi %71, %59 : index
                  %73 = memref.load %arg0[%72] : memref<?xf32>
                  %74 = arith.muli %arg21, %13 : index
                  %75 = arith.addi %arg16, %74 : index
                  %76 = memref.load %alloca[%75] : memref<1xf32, 5>
                  %77 = arith.mulf %73, %76 : f32
                  %78 = arith.addf %arg22, %77 : f32
                  scf.yield %78, %69 : f32, i32
                }
                scf.yield %65#1, %65#0 : i32, f32
              }
              scf.yield %50, %64#0, %63, %64#1 : i32, i32, i32, f32
            } else {
              scf.yield %arg19, %arg17, %arg18, %arg20 : i32, i32, i32, f32
            }
            scf.yield %49#1, %49#2, %49#0, %49#3 : i32, i32, i32, f32
          }
          %41 = scf.if %20 -> (f32) {
            %44 = memref.load %arg2[%1] : memref<?xf32>
            %45 = arith.addf %40#3, %44 : f32
            scf.yield %45 : f32
          } else {
            scf.yield %40#3 : f32
          }
          %42 = arith.addi %36, %25 : index
          %43 = arith.addi %42, %arg11 : index
          memref.store %41, %arg3[%43] : memref<?xf32>
          scf.yield %40#0, %40#1, %40#2 : i32, i32, i32
        }
      }
      gpu.return
    }
  }
}
MemRefAllocaToNPULowering: module: end
[ict-debug] GPUBlockIdToNPULowering: process op: 

%1 = gpu.block_id  y
[ict-error] GPUBlockIdToNPULowering: block id dimension is not x

