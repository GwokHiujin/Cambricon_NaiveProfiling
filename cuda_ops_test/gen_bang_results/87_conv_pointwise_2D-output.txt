warning: CUDA version 12.1 is only partially supported
warning: CUDA version 12.1 is only partially supported
[ict-debug] driver.cc: After return 5, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z29__device_stub__forward_kernelPKfS0_S0_Pfiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    call @_Z14forward_kernelPKfS0_S0_Pfiiiii(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6, %arg7, %arg8) : (memref<?xf32>, memref<?xf32>, memref<?xf32>, memref<?xf32>, i32, i32, i32, i32, i32) -> ()
    return
  }
  func.func private @_Z14forward_kernelPKfS0_S0_Pfiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.block_dim  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %3 : i32
    %5 = gpu.thread_id  x
    %6 = arith.index_cast %5 : index to i32
    %7 = arith.addi %4, %6 : i32
    %8 = gpu.block_dim  x
    %9 = arith.index_cast %8 : index to i32
    %10 = gpu.grid_dim  x
    %11 = arith.index_cast %10 : index to i32
    %12 = arith.muli %9, %11 : i32
    %13 = arith.muli %arg4, %arg6 : i32
    %14 = arith.muli %13, %arg7 : i32
    %15 = arith.muli %14, %arg8 : i32
    %16 = arith.index_cast %15 : i32 to index
    %17 = arith.index_cast %7 : i32 to index
    %18 = arith.index_cast %12 : i32 to index
    %19 = arith.index_cast %12 : i32 to index
    %20 = arith.index_cast %7 : i32 to index
    %21 = arith.muli %arg8, %arg7 : i32
    %22 = arith.muli %arg8, %arg7 : i32
    %23 = arith.muli %22, %arg6 : i32
    %24 = arith.index_cast %arg5 : i32 to index
    %25 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
    %26 = llvm.mlir.zero : !llvm.ptr
    %27 = llvm.icmp "ne" %25, %26 : !llvm.ptr
    %28 = arith.subi %16, %17 : index
    %29 = arith.subi %18, %c1 : index
    %30 = arith.addi %29, %28 : index
    %31 = arith.divui %30, %18 : index
    affine.for %arg9 = 0 to %31 {
      %32 = arith.muli %arg9, %18 : index
      %33 = arith.divui %32, %18 : index
      %34 = arith.muli %33, %19 : index
      %35 = arith.addi %20, %34 : index
      %36 = arith.index_cast %35 : index to i32
      %37 = arith.remsi %36, %arg8 : i32
      %38 = arith.divsi %36, %arg8 : i32
      %39 = arith.remsi %38, %arg7 : i32
      %40 = arith.divsi %36, %21 : i32
      %41 = arith.remsi %40, %arg6 : i32
      %42 = arith.divsi %36, %23 : i32
      %43 = arith.muli %42, %arg5 : i32
      %44 = arith.muli %43, %arg7 : i32
      %45 = arith.muli %44, %arg8 : i32
      %46 = arith.muli %39, %arg8 : i32
      %47 = arith.muli %41, %arg5 : i32
      %48 = affine.for %arg10 = 0 to %24 iter_args(%arg11 = %cst) -> (f32) {
        %50 = arith.index_cast %arg10 : index to i32
        %51 = arith.muli %50, %arg7 : i32
        %52 = arith.muli %51, %arg8 : i32
        %53 = arith.addi %45, %52 : i32
        %54 = arith.addi %53, %46 : i32
        %55 = arith.addi %54, %37 : i32
        %56 = arith.addi %47, %50 : i32
        %57 = arith.index_cast %55 : i32 to index
        %58 = memref.load %arg0[%57] : memref<?xf32>
        %59 = arith.index_cast %56 : i32 to index
        %60 = memref.load %arg1[%59] : memref<?xf32>
        %61 = arith.mulf %58, %60 : f32
        %62 = arith.addf %arg11, %61 : f32
        affine.yield %62 : f32
      }
      %49 = scf.if %27 -> (f32) {
        %50 = arith.index_cast %41 : i32 to index
        %51 = memref.load %arg2[%50] : memref<?xf32>
        %52 = arith.addf %48, %51 : f32
        scf.yield %52 : f32
      } else {
        scf.yield %48 : f32
      }
      affine.store %49, %arg3[%arg9 * symbol(%19) + symbol(%20)] : memref<?xf32>
    }
    return
  }
}
[ict-debug] driver.cc: After return 5, module: end

[ict-debug] driver.cc: After return 6, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z14forward_kernelPKfS0_S0_Pfiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.block_dim  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %3 : i32
    %5 = gpu.thread_id  x
    %6 = arith.index_cast %5 : index to i32
    %7 = arith.addi %4, %6 : i32
    %8 = gpu.grid_dim  x
    %9 = arith.index_cast %8 : index to i32
    %10 = arith.muli %3, %9 : i32
    %11 = arith.muli %arg4, %arg6 : i32
    %12 = arith.muli %11, %arg7 : i32
    %13 = arith.muli %12, %arg8 : i32
    %14 = arith.index_cast %13 : i32 to index
    %15 = arith.index_cast %7 : i32 to index
    %16 = arith.index_cast %10 : i32 to index
    %17 = arith.muli %arg8, %arg7 : i32
    %18 = arith.muli %17, %arg6 : i32
    %19 = arith.index_cast %arg5 : i32 to index
    %20 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
    %21 = llvm.mlir.zero : !llvm.ptr
    %22 = llvm.icmp "ne" %20, %21 : !llvm.ptr
    %23 = arith.subi %14, %15 : index
    %24 = arith.subi %16, %c1 : index
    %25 = arith.addi %24, %23 : index
    %26 = arith.divui %25, %16 : index
    affine.for %arg9 = 0 to %26 {
      %27 = arith.muli %arg9, %16 : index
      %28 = arith.addi %15, %27 : index
      %29 = arith.index_cast %28 : index to i32
      %30 = arith.remsi %29, %arg8 : i32
      %31 = arith.divsi %29, %arg8 : i32
      %32 = arith.remsi %31, %arg7 : i32
      %33 = arith.divsi %29, %17 : i32
      %34 = arith.remsi %33, %arg6 : i32
      %35 = arith.divsi %29, %18 : i32
      %36 = arith.muli %35, %arg5 : i32
      %37 = arith.muli %36, %arg7 : i32
      %38 = arith.muli %37, %arg8 : i32
      %39 = arith.muli %32, %arg8 : i32
      %40 = arith.muli %34, %arg5 : i32
      %41 = affine.for %arg10 = 0 to %19 iter_args(%arg11 = %cst) -> (f32) {
        %43 = arith.index_cast %arg10 : index to i32
        %44 = arith.muli %43, %arg7 : i32
        %45 = arith.muli %44, %arg8 : i32
        %46 = arith.addi %38, %45 : i32
        %47 = arith.addi %46, %39 : i32
        %48 = arith.addi %47, %30 : i32
        %49 = arith.addi %40, %43 : i32
        %50 = arith.index_cast %48 : i32 to index
        %51 = memref.load %arg0[%50] : memref<?xf32>
        %52 = arith.index_cast %49 : i32 to index
        %53 = memref.load %arg1[%52] : memref<?xf32>
        %54 = arith.mulf %51, %53 : f32
        %55 = arith.addf %arg11, %54 : f32
        affine.yield %55 : f32
      }
      %42 = scf.if %22 -> (f32) {
        %43 = arith.index_cast %34 : i32 to index
        %44 = memref.load %arg2[%43] : memref<?xf32>
        %45 = arith.addf %41, %44 : f32
        scf.yield %45 : f32
      } else {
        scf.yield %41 : f32
      }
      affine.store %42, %arg3[%arg9 * symbol(%16) + symbol(%15)] : memref<?xf32>
    }
    return
  }
}
[ict-debug] driver.cc: After return 6, module: end

WrapAndReplaceBarrierPass::runOnOperation(): before execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z14forward_kernelPKfS0_S0_Pfiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.block_dim  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %3 : i32
    %5 = gpu.thread_id  x
    %6 = arith.index_cast %5 : index to i32
    %7 = arith.addi %4, %6 : i32
    %8 = gpu.grid_dim  x
    %9 = arith.index_cast %8 : index to i32
    %10 = arith.muli %3, %9 : i32
    %11 = arith.muli %arg4, %arg6 : i32
    %12 = arith.muli %11, %arg7 : i32
    %13 = arith.muli %12, %arg8 : i32
    %14 = arith.index_cast %13 : i32 to index
    %15 = arith.index_cast %7 : i32 to index
    %16 = arith.index_cast %10 : i32 to index
    %17 = arith.muli %arg8, %arg7 : i32
    %18 = arith.muli %17, %arg6 : i32
    %19 = arith.index_cast %arg5 : i32 to index
    %20 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
    %21 = llvm.mlir.zero : !llvm.ptr
    %22 = llvm.icmp "ne" %20, %21 : !llvm.ptr
    %23 = arith.subi %14, %15 : index
    %24 = arith.subi %16, %c1 : index
    %25 = arith.addi %24, %23 : index
    %26 = arith.divui %25, %16 : index
    scf.for %arg9 = %c0 to %26 step %c1 {
      %27 = arith.muli %arg9, %16 : index
      %28 = arith.addi %15, %27 : index
      %29 = arith.index_cast %28 : index to i32
      %30 = arith.remsi %29, %arg8 : i32
      %31 = arith.divsi %29, %arg8 : i32
      %32 = arith.remsi %31, %arg7 : i32
      %33 = arith.divsi %29, %17 : i32
      %34 = arith.remsi %33, %arg6 : i32
      %35 = arith.divsi %29, %18 : i32
      %36 = arith.muli %35, %arg5 : i32
      %37 = arith.muli %36, %arg7 : i32
      %38 = arith.muli %37, %arg8 : i32
      %39 = arith.muli %32, %arg8 : i32
      %40 = arith.muli %34, %arg5 : i32
      %41 = scf.for %arg10 = %c0 to %19 step %c1 iter_args(%arg11 = %cst) -> (f32) {
        %44 = arith.index_cast %arg10 : index to i32
        %45 = arith.muli %44, %arg7 : i32
        %46 = arith.muli %45, %arg8 : i32
        %47 = arith.addi %38, %46 : i32
        %48 = arith.addi %47, %39 : i32
        %49 = arith.addi %48, %30 : i32
        %50 = arith.addi %40, %44 : i32
        %51 = arith.index_cast %49 : i32 to index
        %52 = memref.load %arg0[%51] : memref<?xf32>
        %53 = arith.index_cast %50 : i32 to index
        %54 = memref.load %arg1[%53] : memref<?xf32>
        %55 = arith.mulf %52, %54 : f32
        %56 = arith.addf %arg11, %55 : f32
        scf.yield %56 : f32
      }
      %42 = scf.if %22 -> (f32) {
        %44 = arith.index_cast %34 : i32 to index
        %45 = memref.load %arg2[%44] : memref<?xf32>
        %46 = arith.addf %41, %45 : f32
        scf.yield %46 : f32
      } else {
        scf.yield %41 : f32
      }
      %43 = arith.addi %27, %15 : index
      memref.store %42, %arg3[%43] : memref<?xf32>
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): before execute: end
WrapAndReplaceBarrierPass::runOnOperation(): after execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z14forward_kernelPKfS0_S0_Pfiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg9) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c1_1 = arith.constant 1 : index
      %cst = arith.constant 0.000000e+00 : f32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = gpu.block_dim  x
      %3 = arith.index_cast %2 : index to i32
      %4 = arith.muli %1, %3 : i32
      %5 = arith.index_cast %arg9 : index to i32
      %6 = arith.addi %4, %5 : i32
      %7 = gpu.grid_dim  x
      %8 = arith.index_cast %7 : index to i32
      %9 = arith.muli %3, %8 : i32
      %10 = arith.muli %arg4, %arg6 : i32
      %11 = arith.muli %10, %arg7 : i32
      %12 = arith.muli %11, %arg8 : i32
      %13 = arith.index_cast %12 : i32 to index
      %14 = arith.index_cast %6 : i32 to index
      %15 = arith.index_cast %9 : i32 to index
      %16 = arith.muli %arg8, %arg7 : i32
      %17 = arith.muli %16, %arg6 : i32
      %18 = arith.index_cast %arg5 : i32 to index
      %19 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %20 = llvm.mlir.zero : !llvm.ptr
      %21 = llvm.icmp "ne" %19, %20 : !llvm.ptr
      %22 = arith.subi %13, %14 : index
      %23 = arith.subi %15, %c1_1 : index
      %24 = arith.addi %23, %22 : index
      %25 = arith.divui %24, %15 : index
      scf.for %arg10 = %c0_0 to %25 step %c1_1 {
        %26 = arith.muli %arg10, %15 : index
        %27 = arith.addi %14, %26 : index
        %28 = arith.index_cast %27 : index to i32
        %29 = arith.remsi %28, %arg8 : i32
        %30 = arith.divsi %28, %arg8 : i32
        %31 = arith.remsi %30, %arg7 : i32
        %32 = arith.divsi %28, %16 : i32
        %33 = arith.remsi %32, %arg6 : i32
        %34 = arith.divsi %28, %17 : i32
        %35 = arith.muli %34, %arg5 : i32
        %36 = arith.muli %35, %arg7 : i32
        %37 = arith.muli %36, %arg8 : i32
        %38 = arith.muli %31, %arg8 : i32
        %39 = arith.muli %33, %arg5 : i32
        %40 = scf.for %arg11 = %c0_0 to %18 step %c1_1 iter_args(%arg12 = %cst) -> (f32) {
          %43 = arith.index_cast %arg11 : index to i32
          %44 = arith.muli %43, %arg7 : i32
          %45 = arith.muli %44, %arg8 : i32
          %46 = arith.addi %37, %45 : i32
          %47 = arith.addi %46, %38 : i32
          %48 = arith.addi %47, %29 : i32
          %49 = arith.addi %39, %43 : i32
          %50 = arith.index_cast %48 : i32 to index
          %51 = memref.load %arg0[%50] : memref<?xf32>
          %52 = arith.index_cast %49 : i32 to index
          %53 = memref.load %arg1[%52] : memref<?xf32>
          %54 = arith.mulf %51, %53 : f32
          %55 = arith.addf %arg12, %54 : f32
          scf.yield %55 : f32
        }
        %41 = scf.if %21 -> (f32) {
          %43 = arith.index_cast %33 : i32 to index
          %44 = memref.load %arg2[%43] : memref<?xf32>
          %45 = arith.addf %40, %44 : f32
          scf.yield %45 : f32
        } else {
          scf.yield %40 : f32
        }
        %42 = arith.addi %26, %14 : index
        memref.store %41, %arg3[%42] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): after execute: end
[ict-debug] driver.cc: After return 7, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z14forward_kernelPKfS0_S0_Pfiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg9) = (%c0) to (%c32) step (%c1) {
      %c0_0 = arith.constant 0 : index
      %c1_1 = arith.constant 1 : index
      %cst = arith.constant 0.000000e+00 : f32
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = gpu.block_dim  x
      %3 = arith.index_cast %2 : index to i32
      %4 = arith.muli %1, %3 : i32
      %5 = arith.index_cast %arg9 : index to i32
      %6 = arith.addi %4, %5 : i32
      %7 = gpu.grid_dim  x
      %8 = arith.index_cast %7 : index to i32
      %9 = arith.muli %3, %8 : i32
      %10 = arith.muli %arg4, %arg6 : i32
      %11 = arith.muli %10, %arg7 : i32
      %12 = arith.muli %11, %arg8 : i32
      %13 = arith.index_cast %12 : i32 to index
      %14 = arith.index_cast %6 : i32 to index
      %15 = arith.index_cast %9 : i32 to index
      %16 = arith.muli %arg8, %arg7 : i32
      %17 = arith.muli %16, %arg6 : i32
      %18 = arith.index_cast %arg5 : i32 to index
      %19 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %20 = llvm.mlir.zero : !llvm.ptr
      %21 = llvm.icmp "ne" %19, %20 : !llvm.ptr
      %22 = arith.subi %13, %14 : index
      %23 = arith.subi %15, %c1_1 : index
      %24 = arith.addi %23, %22 : index
      %25 = arith.divui %24, %15 : index
      scf.for %arg10 = %c0_0 to %25 step %c1_1 {
        %26 = arith.muli %arg10, %15 : index
        %27 = arith.addi %14, %26 : index
        %28 = arith.index_cast %27 : index to i32
        %29 = arith.remsi %28, %arg8 : i32
        %30 = arith.divsi %28, %arg8 : i32
        %31 = arith.remsi %30, %arg7 : i32
        %32 = arith.divsi %28, %16 : i32
        %33 = arith.remsi %32, %arg6 : i32
        %34 = arith.divsi %28, %17 : i32
        %35 = arith.muli %34, %arg5 : i32
        %36 = arith.muli %35, %arg7 : i32
        %37 = arith.muli %36, %arg8 : i32
        %38 = arith.muli %31, %arg8 : i32
        %39 = arith.muli %33, %arg5 : i32
        %40 = scf.for %arg11 = %c0_0 to %18 step %c1_1 iter_args(%arg12 = %cst) -> (f32) {
          %43 = arith.index_cast %arg11 : index to i32
          %44 = arith.muli %43, %arg7 : i32
          %45 = arith.muli %44, %arg8 : i32
          %46 = arith.addi %37, %45 : i32
          %47 = arith.addi %46, %38 : i32
          %48 = arith.addi %47, %29 : i32
          %49 = arith.addi %39, %43 : i32
          %50 = arith.index_cast %48 : i32 to index
          %51 = memref.load %arg0[%50] : memref<?xf32>
          %52 = arith.index_cast %49 : i32 to index
          %53 = memref.load %arg1[%52] : memref<?xf32>
          %54 = arith.mulf %51, %53 : f32
          %55 = arith.addf %arg12, %54 : f32
          scf.yield %55 : f32
        }
        %41 = scf.if %21 -> (f32) {
          %43 = arith.index_cast %33 : i32 to index
          %44 = memref.load %arg2[%43] : memref<?xf32>
          %45 = arith.addf %40, %44 : f32
          scf.yield %45 : f32
        } else {
          scf.yield %40 : f32
        }
        %42 = arith.addi %26, %14 : index
        memref.store %41, %arg3[%42] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
}
[ict-debug] driver.cc: After return 7, module: end

[ict-debug] driver.cc: Before my pass process:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func @_Z14forward_kernelPKfS0_S0_Pfiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %cst = arith.constant 0.000000e+00 : f32
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.block_dim  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %3 : i32
    %5 = gpu.grid_dim  x
    %6 = arith.index_cast %5 : index to i32
    %7 = arith.muli %3, %6 : i32
    %8 = arith.muli %arg4, %arg6 : i32
    %9 = arith.muli %8, %arg7 : i32
    %10 = arith.muli %9, %arg8 : i32
    %11 = arith.index_cast %10 : i32 to index
    %12 = arith.index_cast %7 : i32 to index
    %13 = arith.muli %arg8, %arg7 : i32
    %14 = arith.muli %13, %arg6 : i32
    %15 = arith.index_cast %arg5 : i32 to index
    %16 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
    %17 = llvm.mlir.zero : !llvm.ptr
    %18 = llvm.icmp "ne" %16, %17 : !llvm.ptr
    %19 = arith.subi %12, %c1 : index
    scf.parallel (%arg9) = (%c0) to (%c32) step (%c1) {
      %20 = arith.index_cast %arg9 : index to i32
      %21 = arith.addi %4, %20 : i32
      %22 = arith.index_cast %21 : i32 to index
      %23 = arith.subi %11, %22 : index
      %24 = arith.addi %19, %23 : index
      %25 = arith.divui %24, %12 : index
      scf.for %arg10 = %c0 to %25 step %c1 {
        %26 = arith.muli %arg10, %12 : index
        %27 = arith.addi %22, %26 : index
        %28 = arith.index_cast %27 : index to i32
        %29 = arith.remsi %28, %arg8 : i32
        %30 = arith.divsi %28, %arg8 : i32
        %31 = arith.remsi %30, %arg7 : i32
        %32 = arith.divsi %28, %13 : i32
        %33 = arith.remsi %32, %arg6 : i32
        %34 = arith.divsi %28, %14 : i32
        %35 = arith.muli %34, %arg5 : i32
        %36 = arith.muli %35, %arg7 : i32
        %37 = arith.muli %36, %arg8 : i32
        %38 = arith.muli %31, %arg8 : i32
        %39 = arith.muli %33, %arg5 : i32
        %40 = scf.for %arg11 = %c0 to %15 step %c1 iter_args(%arg12 = %cst) -> (f32) {
          %43 = arith.index_cast %arg11 : index to i32
          %44 = arith.muli %43, %arg7 : i32
          %45 = arith.muli %44, %arg8 : i32
          %46 = arith.addi %37, %45 : i32
          %47 = arith.addi %46, %38 : i32
          %48 = arith.addi %47, %29 : i32
          %49 = arith.addi %39, %43 : i32
          %50 = arith.index_cast %48 : i32 to index
          %51 = memref.load %arg0[%50] : memref<?xf32>
          %52 = arith.index_cast %49 : i32 to index
          %53 = memref.load %arg1[%52] : memref<?xf32>
          %54 = arith.mulf %51, %53 : f32
          %55 = arith.addf %arg12, %54 : f32
          scf.yield %55 : f32
        }
        %41 = scf.if %18 -> (f32) {
          %43 = arith.index_cast %33 : i32 to index
          %44 = memref.load %arg2[%43] : memref<?xf32>
          %45 = arith.addf %40, %44 : f32
          scf.yield %45 : f32
        } else {
          scf.yield %40 : f32
        }
        %42 = arith.addi %26, %22 : index
        memref.store %41, %arg3[%42] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
}
[ict-debug] driver.cc: Before my pass process: end

[ict-debug] driver.cc: vectorizeSize = 1

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z14forward_kernelPKfS0_S0_Pfiiiii_0 {
    gpu.func @_Z14forward_kernelPKfS0_S0_Pfiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) {
      %cst = arith.constant 0.000000e+00 : f32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = gpu.block_dim  x
      %3 = arith.index_cast %2 : index to i32
      %4 = arith.muli %1, %3 : i32
      %5 = gpu.grid_dim  x
      %6 = arith.index_cast %5 : index to i32
      %7 = arith.muli %3, %6 : i32
      %8 = arith.muli %arg4, %arg6 : i32
      %9 = arith.muli %8, %arg7 : i32
      %10 = arith.muli %9, %arg8 : i32
      %11 = arith.index_cast %10 : i32 to index
      %12 = arith.index_cast %7 : i32 to index
      %13 = arith.muli %arg8, %arg7 : i32
      %14 = arith.muli %13, %arg6 : i32
      %15 = arith.index_cast %arg5 : i32 to index
      %16 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %17 = llvm.mlir.zero : !llvm.ptr
      %18 = llvm.icmp "ne" %16, %17 : !llvm.ptr
      %19 = arith.subi %12, %c1 : index
      scf.parallel (%arg9) = (%c0) to (%c32) step (%c1) {
        %20 = arith.index_cast %arg9 : index to i32
        %21 = arith.addi %4, %20 : i32
        %22 = arith.index_cast %21 : i32 to index
        %23 = arith.subi %11, %22 : index
        %24 = arith.addi %19, %23 : index
        %25 = arith.divui %24, %12 : index
        scf.for %arg10 = %c0 to %25 step %c1 {
          %26 = arith.muli %arg10, %12 : index
          %27 = arith.addi %22, %26 : index
          %28 = arith.index_cast %27 : index to i32
          %29 = arith.remsi %28, %arg8 : i32
          %30 = arith.divsi %28, %arg8 : i32
          %31 = arith.remsi %30, %arg7 : i32
          %32 = arith.divsi %28, %13 : i32
          %33 = arith.remsi %32, %arg6 : i32
          %34 = arith.divsi %28, %14 : i32
          %35 = arith.muli %34, %arg5 : i32
          %36 = arith.muli %35, %arg7 : i32
          %37 = arith.muli %36, %arg8 : i32
          %38 = arith.muli %31, %arg8 : i32
          %39 = arith.muli %33, %arg5 : i32
          %40 = scf.for %arg11 = %c0 to %15 step %c1 iter_args(%arg12 = %cst) -> (f32) {
            %43 = arith.index_cast %arg11 : index to i32
            %44 = arith.muli %43, %arg7 : i32
            %45 = arith.muli %44, %arg8 : i32
            %46 = arith.addi %37, %45 : i32
            %47 = arith.addi %46, %38 : i32
            %48 = arith.addi %47, %29 : i32
            %49 = arith.addi %39, %43 : i32
            %50 = arith.index_cast %48 : i32 to index
            %51 = memref.load %arg0[%50] : memref<?xf32>
            %52 = arith.index_cast %49 : i32 to index
            %53 = memref.load %arg1[%52] : memref<?xf32>
            %54 = arith.mulf %51, %53 : f32
            %55 = arith.addf %arg12, %54 : f32
            scf.yield %55 : f32
          }
          %41 = scf.if %18 -> (f32) {
            %43 = arith.index_cast %33 : i32 to index
            %44 = memref.load %arg2[%43] : memref<?xf32>
            %45 = arith.addf %40, %44 : f32
            scf.yield %45 : f32
          } else {
            scf.yield %40 : f32
          }
          %42 = arith.addi %26, %22 : index
          memref.store %41, %arg3[%42] : memref<?xf32>
        }
        scf.yield
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute: end

[ict-debug] ConvertPolygeistToNPU:convertScfParallelToScfFor(): replace gpu.block_dim op with thread loop bound

[ict-debug] ConvertPolygeistToNPU:convertScfParallelToScfFor(): replace gpu.grid_dim with npu.block_num

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize:

"builtin.module"() ({
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, memref<?xf32>, i32, i32, i32, i32, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32):
      %0 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %1 = "arith.constant"() <{value = 0 : index}> : () -> index
      %2 = "arith.constant"() <{value = 1 : index}> : () -> index
      %3 = "arith.constant"() <{value = 32 : index}> : () -> index
      %4 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %5 = "arith.index_cast"(%4) : (index) -> i32
      %6 = "arith.constant"() <{value = 32 : index}> : () -> index
      %7 = "arith.index_cast"(%6) : (index) -> i32
      %8 = "arith.muli"(%5, %7) : (i32, i32) -> i32
      %9 = "npu.block_num"() : () -> i64
      %10 = "arith.index_cast"(%9) : (i64) -> i32
      %11 = "arith.muli"(%7, %10) : (i32, i32) -> i32
      %12 = "arith.muli"(%arg4, %arg6) : (i32, i32) -> i32
      %13 = "arith.muli"(%12, %arg7) : (i32, i32) -> i32
      %14 = "arith.muli"(%13, %arg8) : (i32, i32) -> i32
      %15 = "arith.index_cast"(%14) : (i32) -> index
      %16 = "arith.index_cast"(%11) : (i32) -> index
      %17 = "arith.muli"(%arg8, %arg7) : (i32, i32) -> i32
      %18 = "arith.muli"(%17, %arg6) : (i32, i32) -> i32
      %19 = "arith.index_cast"(%arg5) : (i32) -> index
      %20 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %21 = "llvm.mlir.zero"() : () -> !llvm.ptr
      %22 = "llvm.icmp"(%20, %21) <{predicate = 1 : i64}> : (!llvm.ptr, !llvm.ptr) -> i1
      %23 = "arith.subi"(%16, %2) : (index, index) -> index
      %24 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%1, %3, %24) ({
      ^bb0(%arg9: index):
        %25 = "arith.index_cast"(%arg9) : (index) -> i32
        %26 = "arith.addi"(%8, %25) : (i32, i32) -> i32
        %27 = "arith.index_cast"(%26) : (i32) -> index
        %28 = "arith.subi"(%15, %27) : (index, index) -> index
        %29 = "arith.addi"(%23, %28) : (index, index) -> index
        %30 = "arith.divui"(%29, %16) : (index, index) -> index
        "scf.for"(%1, %30, %2) ({
        ^bb0(%arg10: index):
          %31 = "arith.muli"(%arg10, %16) : (index, index) -> index
          %32 = "arith.addi"(%27, %31) : (index, index) -> index
          %33 = "arith.index_cast"(%32) : (index) -> i32
          %34 = "arith.remsi"(%33, %arg8) : (i32, i32) -> i32
          %35 = "arith.divsi"(%33, %arg8) : (i32, i32) -> i32
          %36 = "arith.remsi"(%35, %arg7) : (i32, i32) -> i32
          %37 = "arith.divsi"(%33, %17) : (i32, i32) -> i32
          %38 = "arith.remsi"(%37, %arg6) : (i32, i32) -> i32
          %39 = "arith.divsi"(%33, %18) : (i32, i32) -> i32
          %40 = "arith.muli"(%39, %arg5) : (i32, i32) -> i32
          %41 = "arith.muli"(%40, %arg7) : (i32, i32) -> i32
          %42 = "arith.muli"(%41, %arg8) : (i32, i32) -> i32
          %43 = "arith.muli"(%36, %arg8) : (i32, i32) -> i32
          %44 = "arith.muli"(%38, %arg5) : (i32, i32) -> i32
          %45 = "scf.for"(%1, %19, %2, %0) ({
          ^bb0(%arg11: index, %arg12: f32):
            %48 = "arith.index_cast"(%arg11) : (index) -> i32
            %49 = "arith.muli"(%48, %arg7) : (i32, i32) -> i32
            %50 = "arith.muli"(%49, %arg8) : (i32, i32) -> i32
            %51 = "arith.addi"(%42, %50) : (i32, i32) -> i32
            %52 = "arith.addi"(%51, %43) : (i32, i32) -> i32
            %53 = "arith.addi"(%52, %34) : (i32, i32) -> i32
            %54 = "arith.addi"(%44, %48) : (i32, i32) -> i32
            %55 = "arith.index_cast"(%53) : (i32) -> index
            %56 = "memref.load"(%arg0, %55) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
            %57 = "arith.index_cast"(%54) : (i32) -> index
            %58 = "memref.load"(%arg1, %57) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
            %59 = "arith.mulf"(%56, %58) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %60 = "arith.addf"(%arg12, %59) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "scf.yield"(%60) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          %46 = "scf.if"(%22) ({
            %48 = "arith.index_cast"(%38) : (i32) -> index
            %49 = "memref.load"(%arg2, %48) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
            %50 = "arith.addf"(%45, %49) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "scf.yield"(%50) : (f32) -> ()
          }, {
            "scf.yield"(%45) : (f32) -> ()
          }) : (i1) -> f32
          %47 = "arith.addi"(%31, %27) : (index, index) -> index
          "memref.store"(%46, %arg3, %47) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }) : (index, index, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z14forward_kernelPKfS0_S0_Pfiiiii", workgroup_attributions = 0 : i64} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z14forward_kernelPKfS0_S0_Pfiiiii_0"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize: end

[ict-debug] GPUBlockIdToNPULowering: process op: 

%4 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%6 = "arith.index_cast"(%5) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%13 = "arith.index_cast"(%12) : (i64) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%19 = "arith.index_cast"(%18) : (i32) -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%21 = "arith.index_cast"(%15) : (i32) -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%25 = "arith.index_cast"(%arg5) : (i32) -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%35 = "arith.index_cast"(%arg9) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%38 = "arith.index_cast"(%37) : (i32) -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%46 = "arith.index_cast"(%44) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%63 = "arith.index_cast"(%arg11) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%71 = "arith.index_cast"(%69) : (i32) -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%74 = "arith.index_cast"(%70) : (i32) -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%62 = "arith.index_cast"(%52) : (i32) -> index
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z14forward_kernelPKfS0_S0_Pfiiiii_0 {
    gpu.func @_Z14forward_kernelPKfS0_S0_Pfiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) {
      %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.ptr
      %cst = arith.constant 0.000000e+00 : f32
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %1 = "npu.block_id"() : () -> i64
      %2 = emitc.cast %1 : i64 to i32
      %c32_0 = arith.constant 32 : index
      %c32_i32 = arith.constant 32 : i32
      %3 = arith.muli %2, %c32_i32 : i32
      %4 = "npu.block_num"() : () -> i64
      %5 = emitc.cast %4 : i64 to i32
      %6 = arith.muli %c32_i32, %5 : i32
      %7 = arith.muli %arg4, %arg6 : i32
      %8 = arith.muli %7, %arg7 : i32
      %9 = arith.muli %8, %arg8 : i32
      %10 = emitc.cast %9 : i32 to index
      %11 = emitc.cast %6 : i32 to index
      %12 = arith.muli %arg8, %arg7 : i32
      %13 = arith.muli %12, %arg6 : i32
      %14 = emitc.cast %arg5 : i32 to index
      %15 = llvm.bitcast %0 : !llvm.ptr to !llvm.ptr
      %16 = llvm.mlir.zero : !llvm.ptr
      %17 = llvm.icmp "ne" %15, %16 : !llvm.ptr
      %18 = arith.subi %11, %c1 : index
      %c1_1 = arith.constant 1 : index
      scf.for %arg9 = %c0 to %c32 step %c1_1 {
        %19 = builtin.unrealized_conversion_cast %arg9 : index to i64
        %20 = emitc.cast %19 : i64 to i32
        %21 = arith.addi %3, %20 : i32
        %22 = emitc.cast %21 : i32 to index
        %23 = arith.subi %10, %22 : index
        %24 = arith.addi %18, %23 : index
        %25 = arith.divui %24, %11 : index
        scf.for %arg10 = %c0 to %25 step %c1 {
          %26 = arith.muli %arg10, %11 : index
          %27 = arith.addi %22, %26 : index
          %28 = builtin.unrealized_conversion_cast %27 : index to i64
          %29 = emitc.cast %28 : i64 to i32
          %30 = arith.remsi %29, %arg8 : i32
          %31 = arith.divsi %29, %arg8 : i32
          %32 = arith.remsi %31, %arg7 : i32
          %33 = arith.divsi %29, %12 : i32
          %34 = arith.remsi %33, %arg6 : i32
          %35 = arith.divsi %29, %13 : i32
          %36 = arith.muli %35, %arg5 : i32
          %37 = arith.muli %36, %arg7 : i32
          %38 = arith.muli %37, %arg8 : i32
          %39 = arith.muli %32, %arg8 : i32
          %40 = arith.muli %34, %arg5 : i32
          %41 = scf.for %arg11 = %c0 to %14 step %c1 iter_args(%arg12 = %cst) -> (f32) {
            %44 = builtin.unrealized_conversion_cast %arg11 : index to i64
            %45 = emitc.cast %44 : i64 to i32
            %46 = arith.muli %45, %arg7 : i32
            %47 = arith.muli %46, %arg8 : i32
            %48 = arith.addi %38, %47 : i32
            %49 = arith.addi %48, %39 : i32
            %50 = arith.addi %49, %30 : i32
            %51 = arith.addi %40, %45 : i32
            %52 = emitc.cast %50 : i32 to index
            %53 = memref.load %arg0[%52] : memref<?xf32>
            %54 = emitc.cast %51 : i32 to index
            %55 = memref.load %arg1[%54] : memref<?xf32>
            %56 = emitc.mul %53, %55 : (f32, f32) -> f32
            %57 = emitc.add %arg12, %56 : (f32, f32) -> f32
            scf.yield %57 : f32
          }
          %42 = scf.if %17 -> (f32) {
            %44 = emitc.cast %34 : i32 to index
            %45 = memref.load %arg2[%44] : memref<?xf32>
            %46 = emitc.add %41, %45 : (f32, f32) -> f32
            scf.yield %46 : f32
          } else {
            scf.yield %41 : f32
          }
          %43 = arith.addi %26, %22 : index
          memref.store %42, %arg3[%43] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU: end

[ict-debug] driver.cc: Before convert to EmitC dialect:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z14forward_kernelPKfS0_S0_Pfiiiii_0 {
    gpu.func @_Z14forward_kernelPKfS0_S0_Pfiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) {
      %c32_i32 = arith.constant 32 : i32
      %c32 = arith.constant 32 : index
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %cst = arith.constant 0.000000e+00 : f32
      %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.ptr
      %1 = "npu.block_id"() : () -> i64
      %2 = emitc.cast %1 : i64 to i32
      %3 = arith.muli %2, %c32_i32 : i32
      %4 = "npu.block_num"() : () -> i64
      %5 = emitc.cast %4 : i64 to i32
      %6 = arith.muli %5, %c32_i32 : i32
      %7 = arith.muli %arg4, %arg6 : i32
      %8 = arith.muli %7, %arg7 : i32
      %9 = arith.muli %8, %arg8 : i32
      %10 = emitc.cast %9 : i32 to index
      %11 = emitc.cast %6 : i32 to index
      %12 = arith.muli %arg8, %arg7 : i32
      %13 = arith.muli %12, %arg6 : i32
      %14 = emitc.cast %arg5 : i32 to index
      %15 = llvm.mlir.zero : !llvm.ptr
      %16 = llvm.icmp "ne" %0, %15 : !llvm.ptr
      %17 = arith.subi %11, %c1 : index
      scf.for %arg9 = %c0 to %c32 step %c1 {
        %18 = builtin.unrealized_conversion_cast %arg9 : index to i64
        %19 = emitc.cast %18 : i64 to i32
        %20 = arith.addi %3, %19 : i32
        %21 = emitc.cast %20 : i32 to index
        %22 = arith.subi %10, %21 : index
        %23 = arith.addi %17, %22 : index
        %24 = arith.divui %23, %11 : index
        scf.for %arg10 = %c0 to %24 step %c1 {
          %25 = arith.muli %arg10, %11 : index
          %26 = arith.addi %21, %25 : index
          %27 = builtin.unrealized_conversion_cast %26 : index to i64
          %28 = emitc.cast %27 : i64 to i32
          %29 = arith.remsi %28, %arg8 : i32
          %30 = arith.divsi %28, %arg8 : i32
          %31 = arith.remsi %30, %arg7 : i32
          %32 = arith.divsi %28, %12 : i32
          %33 = arith.remsi %32, %arg6 : i32
          %34 = arith.divsi %28, %13 : i32
          %35 = arith.muli %34, %arg5 : i32
          %36 = arith.muli %35, %arg7 : i32
          %37 = arith.muli %36, %arg8 : i32
          %38 = arith.muli %31, %arg8 : i32
          %39 = arith.muli %33, %arg5 : i32
          %40 = scf.for %arg11 = %c0 to %14 step %c1 iter_args(%arg12 = %cst) -> (f32) {
            %43 = builtin.unrealized_conversion_cast %arg11 : index to i64
            %44 = emitc.cast %43 : i64 to i32
            %45 = arith.muli %44, %arg7 : i32
            %46 = arith.muli %45, %arg8 : i32
            %47 = arith.addi %37, %46 : i32
            %48 = arith.addi %47, %38 : i32
            %49 = arith.addi %48, %29 : i32
            %50 = arith.addi %39, %44 : i32
            %51 = emitc.cast %49 : i32 to index
            %52 = memref.load %arg0[%51] : memref<?xf32>
            %53 = emitc.cast %50 : i32 to index
            %54 = memref.load %arg1[%53] : memref<?xf32>
            %55 = emitc.mul %52, %54 : (f32, f32) -> f32
            %56 = emitc.add %arg12, %55 : (f32, f32) -> f32
            scf.yield %56 : f32
          }
          %41 = scf.if %16 -> (f32) {
            %43 = emitc.cast %33 : i32 to index
            %44 = memref.load %arg2[%43] : memref<?xf32>
            %45 = emitc.add %40, %44 : (f32, f32) -> f32
            scf.yield %45 : f32
          } else {
            scf.yield %40 : f32
          }
          %42 = arith.addi %25, %21 : index
          memref.store %41, %arg3[%42] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: Before convert to EmitC dialect: end

[ict-debug] driver.cc: After convert to EmitC dialect:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<"dlti.endianness", "little">, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  gpu.module @_Z14forward_kernelPKfS0_S0_Pfiiiii_0 {
    gpu.func @_Z14forward_kernelPKfS0_S0_Pfiiiii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32) {
      %c32_i32 = arith.constant 32 : i32
      %c32 = arith.constant 32 : index
      %c1 = arith.constant 1 : index
      %c0 = arith.constant 0 : index
      %cst = arith.constant 0.000000e+00 : f32
      %0 = builtin.unrealized_conversion_cast %arg2 : memref<?xf32> to !llvm.ptr
      %1 = "npu.block_id"() : () -> i64
      %2 = emitc.cast %1 : i64 to i32
      %3 = arith.muli %2, %c32_i32 : i32
      %4 = "npu.block_num"() : () -> i64
      %5 = emitc.cast %4 : i64 to i32
      %6 = arith.muli %5, %c32_i32 : i32
      %7 = arith.muli %arg4, %arg6 : i32
      %8 = arith.muli %7, %arg7 : i32
      %9 = arith.muli %8, %arg8 : i32
      %10 = emitc.cast %9 : i32 to index
      %11 = emitc.cast %6 : i32 to index
      %12 = arith.muli %arg8, %arg7 : i32
      %13 = arith.muli %12, %arg6 : i32
      %14 = emitc.cast %arg5 : i32 to index
      %15 = llvm.mlir.zero : !llvm.ptr
      %16 = llvm.icmp "ne" %0, %15 : !llvm.ptr
      %17 = arith.subi %11, %c1 : index
      scf.for %arg9 = %c0 to %c32 step %c1 {
        %18 = builtin.unrealized_conversion_cast %arg9 : index to i64
        %19 = emitc.cast %18 : i64 to i32
        %20 = arith.addi %3, %19 : i32
        %21 = emitc.cast %20 : i32 to index
        %22 = arith.subi %10, %21 : index
        %23 = arith.addi %17, %22 : index
        %24 = arith.divui %23, %11 : index
        scf.for %arg10 = %c0 to %24 step %c1 {
          %25 = arith.muli %arg10, %11 : index
          %26 = arith.addi %21, %25 : index
          %27 = builtin.unrealized_conversion_cast %26 : index to i64
          %28 = emitc.cast %27 : i64 to i32
          %29 = arith.remsi %28, %arg8 : i32
          %30 = arith.divsi %28, %arg8 : i32
          %31 = arith.remsi %30, %arg7 : i32
          %32 = arith.divsi %28, %12 : i32
          %33 = arith.remsi %32, %arg6 : i32
          %34 = arith.divsi %28, %13 : i32
          %35 = arith.muli %34, %arg5 : i32
          %36 = arith.muli %35, %arg7 : i32
          %37 = arith.muli %36, %arg8 : i32
          %38 = arith.muli %31, %arg8 : i32
          %39 = arith.muli %33, %arg5 : i32
          %40 = scf.for %arg11 = %c0 to %14 step %c1 iter_args(%arg12 = %cst) -> (f32) {
            %43 = builtin.unrealized_conversion_cast %arg11 : index to i64
            %44 = emitc.cast %43 : i64 to i32
            %45 = arith.muli %44, %arg7 : i32
            %46 = arith.muli %45, %arg8 : i32
            %47 = arith.addi %37, %46 : i32
            %48 = arith.addi %47, %38 : i32
            %49 = arith.addi %48, %29 : i32
            %50 = arith.addi %39, %44 : i32
            %51 = emitc.cast %49 : i32 to index
            %52 = memref.load %arg0[%51] : memref<?xf32>
            %53 = emitc.cast %50 : i32 to index
            %54 = memref.load %arg1[%53] : memref<?xf32>
            %55 = emitc.mul %52, %54 : (f32, f32) -> f32
            %56 = emitc.add %arg12, %55 : (f32, f32) -> f32
            scf.yield %56 : f32
          }
          %41 = "emitc.variable"() <{value = #emitc.opaque<"">}> : () -> f32
          emitc.if %16 {
            %43 = emitc.cast %33 : i32 to index
            %44 = memref.load %arg2[%43] : memref<?xf32>
            %45 = emitc.add %40, %44 : (f32, f32) -> f32
            emitc.assign %45 : f32 to %41 : f32
          } else {
            emitc.assign %40 : f32 to %41 : f32
          }
          %42 = arith.addi %25, %21 : index
          memref.store %41, %arg3[%42] : memref<?xf32>
        }
      }
      gpu.return
    }
  }
}
[ict-debug] driver.cc: After convert to EmitC dialect: end

loc("./cuda_ops/87_conv_pointwise_2D.cu":38:25): error: 'llvm.mlir.zero' op unable to find printer for op
[ict-debug] driver.cc: After emitc::translateToCpp:

