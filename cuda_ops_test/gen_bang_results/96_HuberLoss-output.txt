warning: CUDA version 12.1 is only partially supported
warning: CUDA version 12.1 is only partially supported
warning: we failed to emit call to builtin function __nvvm_ldg_f4
warning: we failed to emit call to builtin function __nvvm_ldg_f
[ict-debug] driver.cc: After return 5, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z46__device_stub__smooth_l1_loss_optimized_kernelPKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    call @_Z31smooth_l1_loss_optimized_kernelPKfS0_Pfi(%arg0, %arg1, %arg2, %arg3) : (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z31smooth_l1_loss_optimized_kernelPKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c2_i32 = arith.constant 2 : i32
    %cst = arith.constant 5.000000e-01 : f32
    %cst_0 = arith.constant 1.000000e+00 : f32
    %c4_i32 = arith.constant 4 : i32
    %cst_1 = arith.constant 0.000000e+00 : f32
    %c0 = arith.constant 0 : index
    %alloca = memref.alloca() : memref<256xf32, 5>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_3 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %0 = gpu.thread_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.cmpi eq, %1, %c0_i32 : i32
    %3 = gpu.block_id  x
    %4 = arith.index_cast %3 : index to i32
    %5 = gpu.block_dim  x
    %6 = arith.index_cast %5 : index to i32
    %7 = arith.muli %4, %6 : i32
    %8 = arith.addi %7, %1 : i32
    %9 = gpu.grid_dim  x
    %10 = arith.index_cast %9 : index to i32
    %11 = gpu.block_dim  x
    %12 = arith.index_cast %11 : index to i32
    %13 = arith.muli %10, %12 : i32
    %14 = arith.divsi %arg3, %c4_i32 : i32
    %15 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
    %16 = "polygeist.pointer2memref"(%15) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %17 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
    %18 = "polygeist.pointer2memref"(%17) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %19 = arith.index_cast %14 : i32 to index
    %20 = arith.index_cast %8 : i32 to index
    %21 = arith.index_cast %13 : i32 to index
    %22 = arith.index_cast %13 : i32 to index
    %23 = arith.index_cast %8 : i32 to index
    %24 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %25 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %26 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %27 = llvm.getelementptr %26[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %28 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %29 = llvm.getelementptr %28[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %30 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %31 = llvm.getelementptr %30[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %32 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %33 = llvm.getelementptr %32[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %34 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %35 = llvm.getelementptr %34[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %36 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %37 = llvm.getelementptr %36[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %38 = arith.subi %19, %20 : index
    %39 = arith.subi %21, %c1 : index
    %40 = arith.addi %39, %38 : index
    %41 = arith.divui %40, %21 : index
    %42 = affine.for %arg4 = 0 to %41 iter_args(%arg5 = %cst_1) -> (f32) {
      %59 = arith.muli %arg4, %21 : index
      %60 = arith.divui %59, %21 : index
      %61 = arith.muli %60, %22 : index
      %62 = arith.addi %23, %61 : index
      %63 = "polygeist.subindex"(%16, %62) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %64 = func.call @_Z5__ldgPK6float4(%63) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      affine.store %64, %alloca_3[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %65 = "polygeist.subindex"(%18, %62) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %66 = func.call @_Z5__ldgPK6float4(%65) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      affine.store %66, %alloca_2[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %67 = llvm.load %24 : !llvm.ptr -> f32
      %68 = llvm.load %25 : !llvm.ptr -> f32
      %69 = arith.subf %67, %68 : f32
      %70 = math.absf %69 : f32
      %71 = arith.cmpf olt, %70, %cst_0 : f32
      %72 = scf.if %71 -> (f32) {
        %95 = arith.mulf %69, %cst : f32
        %96 = arith.mulf %95, %69 : f32
        scf.yield %96 : f32
      } else {
        %95 = arith.subf %70, %cst : f32
        scf.yield %95 : f32
      }
      %73 = arith.addf %arg5, %72 : f32
      %74 = llvm.load %27 : !llvm.ptr -> f32
      %75 = llvm.load %29 : !llvm.ptr -> f32
      %76 = arith.subf %74, %75 : f32
      %77 = math.absf %76 : f32
      %78 = arith.cmpf olt, %77, %cst_0 : f32
      %79 = scf.if %78 -> (f32) {
        %95 = arith.mulf %76, %cst : f32
        %96 = arith.mulf %95, %76 : f32
        scf.yield %96 : f32
      } else {
        %95 = arith.subf %77, %cst : f32
        scf.yield %95 : f32
      }
      %80 = arith.addf %73, %79 : f32
      %81 = llvm.load %31 : !llvm.ptr -> f32
      %82 = llvm.load %33 : !llvm.ptr -> f32
      %83 = arith.subf %81, %82 : f32
      %84 = math.absf %83 : f32
      %85 = arith.cmpf olt, %84, %cst_0 : f32
      %86 = scf.if %85 -> (f32) {
        %95 = arith.mulf %83, %cst : f32
        %96 = arith.mulf %95, %83 : f32
        scf.yield %96 : f32
      } else {
        %95 = arith.subf %84, %cst : f32
        scf.yield %95 : f32
      }
      %87 = arith.addf %80, %86 : f32
      %88 = llvm.load %35 : !llvm.ptr -> f32
      %89 = llvm.load %37 : !llvm.ptr -> f32
      %90 = arith.subf %88, %89 : f32
      %91 = math.absf %90 : f32
      %92 = arith.cmpf olt, %91, %cst_0 : f32
      %93 = scf.if %92 -> (f32) {
        %95 = arith.mulf %90, %cst : f32
        %96 = arith.mulf %95, %90 : f32
        scf.yield %96 : f32
      } else {
        %95 = arith.subf %91, %cst : f32
        scf.yield %95 : f32
      }
      %94 = arith.addf %87, %93 : f32
      affine.yield %94 : f32
    }
    %43 = arith.muli %14, %c4_i32 : i32
    %44 = arith.addi %43, %8 : i32
    %45 = arith.index_cast %arg3 : i32 to index
    %46 = arith.index_cast %44 : i32 to index
    %47 = arith.index_cast %13 : i32 to index
    %48 = arith.index_cast %13 : i32 to index
    %49 = arith.index_cast %44 : i32 to index
    %50 = arith.subi %45, %46 : index
    %51 = arith.subi %47, %c1 : index
    %52 = arith.addi %51, %50 : index
    %53 = arith.divui %52, %47 : index
    %54 = affine.for %arg4 = 0 to %53 iter_args(%arg5 = %42) -> (f32) {
      %59 = arith.muli %arg4, %47 : index
      %60 = arith.divui %59, %47 : index
      %61 = arith.muli %60, %48 : index
      %62 = arith.addi %49, %61 : index
      %63 = "polygeist.subindex"(%arg0, %62) : (memref<?xf32>, index) -> memref<?xf32>
      %64 = func.call @_Z5__ldgPKf(%63) : (memref<?xf32>) -> f32
      %65 = "polygeist.subindex"(%arg1, %62) : (memref<?xf32>, index) -> memref<?xf32>
      %66 = func.call @_Z5__ldgPKf(%65) : (memref<?xf32>) -> f32
      %67 = arith.subf %64, %66 : f32
      %68 = math.absf %67 : f32
      %69 = arith.cmpf olt, %68, %cst_0 : f32
      %70 = scf.if %69 -> (f32) {
        %72 = arith.mulf %67, %cst : f32
        %73 = arith.mulf %72, %67 : f32
        scf.yield %73 : f32
      } else {
        %72 = arith.subf %68, %cst : f32
        scf.yield %72 : f32
      }
      %71 = arith.addf %arg5, %70 : f32
      affine.yield %71 : f32
    }
    affine.store %54, %alloca[symbol(%0)] : memref<256xf32, 5>
    nvvm.barrier0
    %55 = gpu.block_dim  x
    %56 = arith.index_cast %55 : index to i32
    %57 = arith.divui %56, %c2_i32 : i32
    %58 = scf.while (%arg4 = %57) : (i32) -> i32 {
      %59 = arith.cmpi sgt, %arg4, %c0_i32 : i32
      scf.condition(%59) %arg4 : i32
    } do {
    ^bb0(%arg4: i32):
      %59 = arith.cmpi slt, %1, %arg4 : i32
      scf.if %59 {
        %61 = arith.addi %1, %arg4 : i32
        %62 = arith.index_cast %61 : i32 to index
        %63 = memref.load %alloca[%62] : memref<256xf32, 5>
        %64 = affine.load %alloca[symbol(%0)] : memref<256xf32, 5>
        %65 = arith.addf %64, %63 : f32
        affine.store %65, %alloca[symbol(%0)] : memref<256xf32, 5>
      }
      nvvm.barrier0
      %60 = arith.shrsi %arg4, %c1_i32 : i32
      scf.yield %60 : i32
    }
    scf.if %2 {
      %59 = affine.load %alloca[0] : memref<256xf32, 5>
      %60 = arith.sitofp %arg3 : i32 to f32
      %61 = arith.divf %59, %60 : f32
      %62 = memref.atomic_rmw addf %61, %arg2[%c0] : (f32, memref<?xf32>) -> f32
    }
    return
  }
  func.func private @_Z5__ldgPK6float4(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)> attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1x4xf32>
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = "polygeist.pointer2memref"(%0) : (!llvm.ptr) -> memref<?x4xf32>
    %cast_3 = memref.cast %alloca_2 : memref<1x4xf32> to memref<?x4xf32>
    call @__nvvm_ldg_f4(%1, %cast_3) : (memref<?x4xf32>, memref<?x4xf32>) -> ()
    %2 = affine.load %alloca_2[0, 0] : memref<1x4xf32>
    %3 = affine.load %alloca_2[0, 1] : memref<1x4xf32>
    %4 = affine.load %alloca_2[0, 2] : memref<1x4xf32>
    %5 = affine.load %alloca_2[0, 3] : memref<1x4xf32>
    %6 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %2, %6 : f32, !llvm.ptr
    %7 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %8 = llvm.getelementptr %7[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %3, %8 : f32, !llvm.ptr
    %9 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %10 = llvm.getelementptr %9[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %10 : f32, !llvm.ptr
    %11 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %12 = llvm.getelementptr %11[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %5, %12 : f32, !llvm.ptr
    call @_ZN6float4C1EOS_(%cast, %cast_1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
    %13 = affine.load %alloca[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    return %13 : !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
  }
  func.func private @_Z5__ldgPKf(%arg0: memref<?xf32>) -> f32 attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    %0 = call @__nvvm_ldg_f(%arg0) : (memref<?xf32>) -> f32
    return %0 : f32
  }
  func.func private @__nvvm_ldg_f4(memref<?x4xf32>, memref<?x4xf32>) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
  func.func private @_ZN6float4C1EOS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
  func.func private @__nvvm_ldg_f(memref<?xf32>) -> f32 attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
}
[ict-debug] driver.cc: After return 5, module: end

[ict-debug] driver.cc: After return 6, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z31smooth_l1_loss_optimized_kernelPKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c2_i32 = arith.constant 2 : i32
    %cst = arith.constant 5.000000e-01 : f32
    %cst_0 = arith.constant 1.000000e+00 : f32
    %c4_i32 = arith.constant 4 : i32
    %cst_1 = arith.constant 0.000000e+00 : f32
    %c0 = arith.constant 0 : index
    %alloca = memref.alloca() : memref<256xf32, 5>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_3 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %0 = gpu.thread_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.cmpi eq, %1, %c0_i32 : i32
    %3 = gpu.block_id  x
    %4 = arith.index_cast %3 : index to i32
    %5 = gpu.block_dim  x
    %6 = arith.index_cast %5 : index to i32
    %7 = arith.muli %4, %6 : i32
    %8 = arith.addi %7, %1 : i32
    %9 = gpu.grid_dim  x
    %10 = arith.index_cast %9 : index to i32
    %11 = arith.muli %10, %6 : i32
    %12 = arith.divsi %arg3, %c4_i32 : i32
    %13 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
    %14 = "polygeist.pointer2memref"(%13) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %15 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
    %16 = "polygeist.pointer2memref"(%15) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %17 = arith.index_cast %12 : i32 to index
    %18 = arith.index_cast %8 : i32 to index
    %19 = arith.index_cast %11 : i32 to index
    %20 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %21 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %22 = llvm.getelementptr %20[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %23 = llvm.getelementptr %21[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %24 = llvm.getelementptr %20[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %25 = llvm.getelementptr %21[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %26 = llvm.getelementptr %20[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %27 = llvm.getelementptr %21[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %28 = arith.subi %17, %18 : index
    %29 = arith.subi %19, %c1 : index
    %30 = arith.addi %29, %28 : index
    %31 = arith.divui %30, %19 : index
    %32 = affine.for %arg4 = 0 to %31 iter_args(%arg5 = %cst_1) -> (f32) {
      %43 = arith.muli %arg4, %19 : index
      %44 = arith.addi %18, %43 : index
      %45 = "polygeist.subindex"(%14, %44) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %46 = func.call @_Z5__ldgPK6float4(%45) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      affine.store %46, %alloca_3[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %47 = "polygeist.subindex"(%16, %44) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %48 = func.call @_Z5__ldgPK6float4(%47) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      affine.store %48, %alloca_2[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %49 = llvm.load %20 : !llvm.ptr -> f32
      %50 = llvm.load %21 : !llvm.ptr -> f32
      %51 = arith.subf %49, %50 : f32
      %52 = math.absf %51 : f32
      %53 = arith.cmpf olt, %52, %cst_0 : f32
      %54 = scf.if %53 -> (f32) {
        %77 = arith.mulf %51, %cst : f32
        %78 = arith.mulf %77, %51 : f32
        scf.yield %78 : f32
      } else {
        %77 = arith.subf %52, %cst : f32
        scf.yield %77 : f32
      }
      %55 = arith.addf %arg5, %54 : f32
      %56 = llvm.load %22 : !llvm.ptr -> f32
      %57 = llvm.load %23 : !llvm.ptr -> f32
      %58 = arith.subf %56, %57 : f32
      %59 = math.absf %58 : f32
      %60 = arith.cmpf olt, %59, %cst_0 : f32
      %61 = scf.if %60 -> (f32) {
        %77 = arith.mulf %58, %cst : f32
        %78 = arith.mulf %77, %58 : f32
        scf.yield %78 : f32
      } else {
        %77 = arith.subf %59, %cst : f32
        scf.yield %77 : f32
      }
      %62 = arith.addf %55, %61 : f32
      %63 = llvm.load %24 : !llvm.ptr -> f32
      %64 = llvm.load %25 : !llvm.ptr -> f32
      %65 = arith.subf %63, %64 : f32
      %66 = math.absf %65 : f32
      %67 = arith.cmpf olt, %66, %cst_0 : f32
      %68 = scf.if %67 -> (f32) {
        %77 = arith.mulf %65, %cst : f32
        %78 = arith.mulf %77, %65 : f32
        scf.yield %78 : f32
      } else {
        %77 = arith.subf %66, %cst : f32
        scf.yield %77 : f32
      }
      %69 = arith.addf %62, %68 : f32
      %70 = llvm.load %26 : !llvm.ptr -> f32
      %71 = llvm.load %27 : !llvm.ptr -> f32
      %72 = arith.subf %70, %71 : f32
      %73 = math.absf %72 : f32
      %74 = arith.cmpf olt, %73, %cst_0 : f32
      %75 = scf.if %74 -> (f32) {
        %77 = arith.mulf %72, %cst : f32
        %78 = arith.mulf %77, %72 : f32
        scf.yield %78 : f32
      } else {
        %77 = arith.subf %73, %cst : f32
        scf.yield %77 : f32
      }
      %76 = arith.addf %69, %75 : f32
      affine.yield %76 : f32
    }
    %33 = arith.muli %12, %c4_i32 : i32
    %34 = arith.addi %33, %8 : i32
    %35 = arith.index_cast %arg3 : i32 to index
    %36 = arith.index_cast %34 : i32 to index
    %37 = arith.subi %35, %36 : index
    %38 = arith.addi %29, %37 : index
    %39 = arith.divui %38, %19 : index
    %40 = affine.for %arg4 = 0 to %39 iter_args(%arg5 = %32) -> (f32) {
      %43 = arith.muli %arg4, %19 : index
      %44 = arith.addi %36, %43 : index
      %45 = "polygeist.subindex"(%arg0, %44) : (memref<?xf32>, index) -> memref<?xf32>
      %46 = func.call @__nvvm_ldg_f(%45) : (memref<?xf32>) -> f32
      %47 = "polygeist.subindex"(%arg1, %44) : (memref<?xf32>, index) -> memref<?xf32>
      %48 = func.call @__nvvm_ldg_f(%47) : (memref<?xf32>) -> f32
      %49 = arith.subf %46, %48 : f32
      %50 = math.absf %49 : f32
      %51 = arith.cmpf olt, %50, %cst_0 : f32
      %52 = scf.if %51 -> (f32) {
        %54 = arith.mulf %49, %cst : f32
        %55 = arith.mulf %54, %49 : f32
        scf.yield %55 : f32
      } else {
        %54 = arith.subf %50, %cst : f32
        scf.yield %54 : f32
      }
      %53 = arith.addf %arg5, %52 : f32
      affine.yield %53 : f32
    }
    affine.store %40, %alloca[symbol(%0)] : memref<256xf32, 5>
    nvvm.barrier0
    %41 = arith.divui %6, %c2_i32 : i32
    %42 = scf.while (%arg4 = %41) : (i32) -> i32 {
      %43 = arith.cmpi sgt, %arg4, %c0_i32 : i32
      scf.condition(%43) %arg4 : i32
    } do {
    ^bb0(%arg4: i32):
      %43 = arith.cmpi slt, %1, %arg4 : i32
      scf.if %43 {
        %45 = arith.addi %1, %arg4 : i32
        %46 = arith.index_cast %45 : i32 to index
        %47 = memref.load %alloca[%46] : memref<256xf32, 5>
        %48 = affine.load %alloca[symbol(%0)] : memref<256xf32, 5>
        %49 = arith.addf %48, %47 : f32
        affine.store %49, %alloca[symbol(%0)] : memref<256xf32, 5>
      }
      nvvm.barrier0
      %44 = arith.shrsi %arg4, %c1_i32 : i32
      scf.yield %44 : i32
    }
    scf.if %2 {
      %43 = affine.load %alloca[0] : memref<256xf32, 5>
      %44 = arith.sitofp %arg3 : i32 to f32
      %45 = arith.divf %43, %44 : f32
      %46 = memref.atomic_rmw addf %45, %arg2[%c0] : (f32, memref<?xf32>) -> f32
    }
    return
  }
  func.func private @_Z5__ldgPK6float4(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)> attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1x4xf32>
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = "polygeist.pointer2memref"(%0) : (!llvm.ptr) -> memref<?x4xf32>
    %cast_3 = memref.cast %alloca_2 : memref<1x4xf32> to memref<?x4xf32>
    call @__nvvm_ldg_f4(%1, %cast_3) : (memref<?x4xf32>, memref<?x4xf32>) -> ()
    %2 = affine.load %alloca_2[0, 0] : memref<1x4xf32>
    %3 = affine.load %alloca_2[0, 1] : memref<1x4xf32>
    %4 = affine.load %alloca_2[0, 2] : memref<1x4xf32>
    %5 = affine.load %alloca_2[0, 3] : memref<1x4xf32>
    %6 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %2, %6 : f32, !llvm.ptr
    %7 = llvm.getelementptr %6[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %3, %7 : f32, !llvm.ptr
    %8 = llvm.getelementptr %6[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %6[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %5, %9 : f32, !llvm.ptr
    call @_ZN6float4C1EOS_(%cast, %cast_1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
    %10 = affine.load %alloca[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    return %10 : !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
  }
  func.func private @__nvvm_ldg_f4(memref<?x4xf32>, memref<?x4xf32>) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
  func.func private @_ZN6float4C1EOS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
  func.func private @__nvvm_ldg_f(memref<?xf32>) -> f32 attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
}
[ict-debug] driver.cc: After return 6, module: end

WrapAndReplaceBarrierPass::runOnOperation(): before execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z31smooth_l1_loss_optimized_kernelPKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c2_i32 = arith.constant 2 : i32
    %cst = arith.constant 5.000000e-01 : f32
    %cst_0 = arith.constant 1.000000e+00 : f32
    %c4_i32 = arith.constant 4 : i32
    %cst_1 = arith.constant 0.000000e+00 : f32
    %c0 = arith.constant 0 : index
    %alloca = memref.alloca() : memref<256xf32, 5>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_3 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %0 = gpu.thread_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.cmpi eq, %1, %c0_i32 : i32
    %3 = gpu.block_id  x
    %4 = arith.index_cast %3 : index to i32
    %5 = gpu.block_dim  x
    %6 = arith.index_cast %5 : index to i32
    %7 = arith.muli %4, %6 : i32
    %8 = arith.addi %7, %1 : i32
    %9 = gpu.grid_dim  x
    %10 = arith.index_cast %9 : index to i32
    %11 = arith.muli %10, %6 : i32
    %12 = arith.divsi %arg3, %c4_i32 : i32
    %13 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
    %14 = "polygeist.pointer2memref"(%13) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %15 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
    %16 = "polygeist.pointer2memref"(%15) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %17 = arith.index_cast %12 : i32 to index
    %18 = arith.index_cast %8 : i32 to index
    %19 = arith.index_cast %11 : i32 to index
    %20 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %21 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %22 = llvm.getelementptr %20[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %23 = llvm.getelementptr %21[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %24 = llvm.getelementptr %20[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %25 = llvm.getelementptr %21[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %26 = llvm.getelementptr %20[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %27 = llvm.getelementptr %21[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %28 = arith.subi %17, %18 : index
    %29 = arith.subi %19, %c1 : index
    %30 = arith.addi %29, %28 : index
    %31 = arith.divui %30, %19 : index
    %32 = scf.for %arg4 = %c0 to %31 step %c1 iter_args(%arg5 = %cst_1) -> (f32) {
      %43 = arith.muli %arg4, %19 : index
      %44 = arith.addi %18, %43 : index
      %45 = "polygeist.subindex"(%14, %44) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %46 = func.call @_Z5__ldgPK6float4(%45) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      memref.store %46, %alloca_3[%c0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %47 = "polygeist.subindex"(%16, %44) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %48 = func.call @_Z5__ldgPK6float4(%47) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      memref.store %48, %alloca_2[%c0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %49 = llvm.load %20 : !llvm.ptr -> f32
      %50 = llvm.load %21 : !llvm.ptr -> f32
      %51 = arith.subf %49, %50 : f32
      %52 = math.absf %51 : f32
      %53 = arith.cmpf olt, %52, %cst_0 : f32
      %54 = scf.if %53 -> (f32) {
        %77 = arith.mulf %51, %cst : f32
        %78 = arith.mulf %77, %51 : f32
        scf.yield %78 : f32
      } else {
        %77 = arith.subf %52, %cst : f32
        scf.yield %77 : f32
      }
      %55 = arith.addf %arg5, %54 : f32
      %56 = llvm.load %22 : !llvm.ptr -> f32
      %57 = llvm.load %23 : !llvm.ptr -> f32
      %58 = arith.subf %56, %57 : f32
      %59 = math.absf %58 : f32
      %60 = arith.cmpf olt, %59, %cst_0 : f32
      %61 = scf.if %60 -> (f32) {
        %77 = arith.mulf %58, %cst : f32
        %78 = arith.mulf %77, %58 : f32
        scf.yield %78 : f32
      } else {
        %77 = arith.subf %59, %cst : f32
        scf.yield %77 : f32
      }
      %62 = arith.addf %55, %61 : f32
      %63 = llvm.load %24 : !llvm.ptr -> f32
      %64 = llvm.load %25 : !llvm.ptr -> f32
      %65 = arith.subf %63, %64 : f32
      %66 = math.absf %65 : f32
      %67 = arith.cmpf olt, %66, %cst_0 : f32
      %68 = scf.if %67 -> (f32) {
        %77 = arith.mulf %65, %cst : f32
        %78 = arith.mulf %77, %65 : f32
        scf.yield %78 : f32
      } else {
        %77 = arith.subf %66, %cst : f32
        scf.yield %77 : f32
      }
      %69 = arith.addf %62, %68 : f32
      %70 = llvm.load %26 : !llvm.ptr -> f32
      %71 = llvm.load %27 : !llvm.ptr -> f32
      %72 = arith.subf %70, %71 : f32
      %73 = math.absf %72 : f32
      %74 = arith.cmpf olt, %73, %cst_0 : f32
      %75 = scf.if %74 -> (f32) {
        %77 = arith.mulf %72, %cst : f32
        %78 = arith.mulf %77, %72 : f32
        scf.yield %78 : f32
      } else {
        %77 = arith.subf %73, %cst : f32
        scf.yield %77 : f32
      }
      %76 = arith.addf %69, %75 : f32
      scf.yield %76 : f32
    }
    %33 = arith.muli %12, %c4_i32 : i32
    %34 = arith.addi %33, %8 : i32
    %35 = arith.index_cast %arg3 : i32 to index
    %36 = arith.index_cast %34 : i32 to index
    %37 = arith.subi %35, %36 : index
    %38 = arith.addi %29, %37 : index
    %39 = arith.divui %38, %19 : index
    %40 = scf.for %arg4 = %c0 to %39 step %c1 iter_args(%arg5 = %32) -> (f32) {
      %43 = arith.muli %arg4, %19 : index
      %44 = arith.addi %36, %43 : index
      %45 = "polygeist.subindex"(%arg0, %44) : (memref<?xf32>, index) -> memref<?xf32>
      %46 = func.call @__nvvm_ldg_f(%45) : (memref<?xf32>) -> f32
      %47 = "polygeist.subindex"(%arg1, %44) : (memref<?xf32>, index) -> memref<?xf32>
      %48 = func.call @__nvvm_ldg_f(%47) : (memref<?xf32>) -> f32
      %49 = arith.subf %46, %48 : f32
      %50 = math.absf %49 : f32
      %51 = arith.cmpf olt, %50, %cst_0 : f32
      %52 = scf.if %51 -> (f32) {
        %54 = arith.mulf %49, %cst : f32
        %55 = arith.mulf %54, %49 : f32
        scf.yield %55 : f32
      } else {
        %54 = arith.subf %50, %cst : f32
        scf.yield %54 : f32
      }
      %53 = arith.addf %arg5, %52 : f32
      scf.yield %53 : f32
    }
    memref.store %40, %alloca[%0] : memref<256xf32, 5>
    nvvm.barrier0
    %41 = arith.divui %6, %c2_i32 : i32
    %42 = scf.while (%arg4 = %41) : (i32) -> i32 {
      %43 = arith.cmpi sgt, %arg4, %c0_i32 : i32
      scf.condition(%43) %arg4 : i32
    } do {
    ^bb0(%arg4: i32):
      %43 = arith.cmpi slt, %1, %arg4 : i32
      scf.if %43 {
        %45 = arith.addi %1, %arg4 : i32
        %46 = arith.index_cast %45 : i32 to index
        %47 = memref.load %alloca[%46] : memref<256xf32, 5>
        %48 = memref.load %alloca[%0] : memref<256xf32, 5>
        %49 = arith.addf %48, %47 : f32
        memref.store %49, %alloca[%0] : memref<256xf32, 5>
      }
      nvvm.barrier0
      %44 = arith.shrsi %arg4, %c1_i32 : i32
      scf.yield %44 : i32
    }
    scf.if %2 {
      %43 = memref.load %alloca[%c0] : memref<256xf32, 5>
      %44 = arith.sitofp %arg3 : i32 to f32
      %45 = arith.divf %43, %44 : f32
      %46 = memref.atomic_rmw addf %45, %arg2[%c0] : (f32, memref<?xf32>) -> f32
    }
    return
  }
  func.func private @_Z5__ldgPK6float4(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)> attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    %c3 = arith.constant 3 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1x4xf32>
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = "polygeist.pointer2memref"(%0) : (!llvm.ptr) -> memref<?x4xf32>
    %cast_3 = memref.cast %alloca_2 : memref<1x4xf32> to memref<?x4xf32>
    call @__nvvm_ldg_f4(%1, %cast_3) : (memref<?x4xf32>, memref<?x4xf32>) -> ()
    %2 = memref.load %alloca_2[%c0, %c0] : memref<1x4xf32>
    %3 = memref.load %alloca_2[%c0, %c1] : memref<1x4xf32>
    %4 = memref.load %alloca_2[%c0, %c2] : memref<1x4xf32>
    %5 = memref.load %alloca_2[%c0, %c3] : memref<1x4xf32>
    %6 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %2, %6 : f32, !llvm.ptr
    %7 = llvm.getelementptr %6[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %3, %7 : f32, !llvm.ptr
    %8 = llvm.getelementptr %6[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %6[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %5, %9 : f32, !llvm.ptr
    call @_ZN6float4C1EOS_(%cast, %cast_1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
    %10 = memref.load %alloca[%c0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    return %10 : !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
  }
  func.func private @__nvvm_ldg_f4(memref<?x4xf32>, memref<?x4xf32>) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
  func.func private @_ZN6float4C1EOS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
  func.func private @__nvvm_ldg_f(memref<?xf32>) -> f32 attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
}
WrapAndReplaceBarrierPass::runOnOperation(): before execute: end
[ict-debug] WrapAndReplaceBarrierPass::runOnOperation(): Function name: __nvvm_ldg_f4. func.getBlocks().size() == 0! this function is empty, skip it.

[ict-debug] WrapAndReplaceBarrierPass::runOnOperation(): Function name: __nvvm_ldg_f. func.getBlocks().size() == 0! this function is empty, skip it.

WrapAndReplaceBarrierPass::runOnOperation(): after execute: 
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist --function=* -cuda-lower -output-intermediate-gpu -scal-rep=0 -raise-scf-to-affine --cuda-gpu-arch=sm_70 -parallel-licm=1 -gpu-kernel-structure-mode=block_thread_noops --enable-buffer-elim=0 -O2 -I /CUDA2BANG/cuda2bang/polygeist/mlir-build/projects/openmp/runtime/src/ -resource-dir=/CUDA2BANG/cuda2bang/polygeist/mlir-build/lib/clang/18/ -I /CUDA2BANG/cuda2bang/polygeist/mlir-build/projects/openmp/runtime/src/ -I /usr/local/cuda/include/ -use-original-gpu-block-size --emit-npu=distribute.mincut -use-my-pass -bang-dump-file=./gen_bang_results/96_HuberLoss.mlu ./cuda_ops/96_HuberLoss.cu -o 96_HuberLoss.o
 #0 0x00005602fded3b9f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x3390b9f)
 #1 0x00005602fded1384 SignalHandler(int) Signals.cpp:0:0
 #2 0x00007fdbd1a20420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)
 #3 0x00005602fe29b978 mlir::AsmPrinter::Impl::printTypeImpl(mlir::Type) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x3758978)
 #4 0x00005602fe29c63b mlir::AsmPrinter::Impl::printType(mlir::Type) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x375963b)
 #5 0x00005602fe28568b mlir::OpAsmPrinter::printFunctionalType(mlir::Operation*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x374268b)
 #6 0x00005602fe29ea0c (anonymous namespace)::OperationPrinter::printGenericOp(mlir::Operation*, bool) AsmPrinter.cpp:0:0
 #7 0x00005602fe29ed32 (anonymous namespace)::OperationPrinter::printCustomOrGenericOp(mlir::Operation*) AsmPrinter.cpp:0:0
 #8 0x00005602fe29f229 (anonymous namespace)::OperationPrinter::printFullOpWithIndentAndLoc(mlir::Operation*) AsmPrinter.cpp:0:0
 #9 0x00005602fe2a04d8 mlir::Operation::print(llvm::raw_ostream&, mlir::AsmState&) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x375d4d8)
#10 0x00005602fe2a1ebc mlir::Operation::print(llvm::raw_ostream&, mlir::OpPrintingFlags const&) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x375eebc)
#11 0x00005602fe300db4 mlir::Diagnostic::appendOp(mlir::Operation&, mlir::OpPrintingFlags const&) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x37bddb4)
#12 0x00005602fe34dd05 mlir::OpState::emitError(llvm::Twine const&) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x380ad05)
#13 0x0000560301b6f9d1 mlir::func::ReturnOp::verify() (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x702c9d1)
#14 0x0000560301b7a28b mlir::Op<mlir::func::ReturnOp, mlir::OpTrait::ZeroRegions, mlir::OpTrait::ZeroResults, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::VariadicOperands, mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl, mlir::OpTrait::OpInvariants, mlir::ConditionallySpeculatable::Trait, mlir::OpTrait::AlwaysSpeculatableImplTrait, mlir::MemoryEffectOpInterface::Trait, mlir::OpTrait::MemRefsNormalizable, mlir::RegionBranchTerminatorOpInterface::Trait, mlir::OpTrait::ReturnLike, mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::Operation*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x703728b)
#15 0x00005602fe1117e6 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*>::CallImpl<mlir::LogicalResult (* const)(mlir::Operation*)>(void*, mlir::Operation*) /CUDA2BANG/cuda2bang/polygeist/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:221:3
#16 0x0000560301b79f0b mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::verifyInvariants(mlir::Operation*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x7036f0b)
#17 0x00005602fe3831da (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) Verifier.cpp:0:0
#18 0x00005602fe382dce (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) Verifier.cpp:0:0
#19 0x00005602fe384b1a mlir::verify(mlir::Operation*, bool) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x3841b1a)
#20 0x00005602fe2994a8 mlir::AsmState::AsmState(mlir::Operation*, mlir::OpPrintingFlags const&, llvm::DenseMap<mlir::Operation*, std::pair<unsigned int, unsigned int>, llvm::DenseMapInfo<mlir::Operation*, void>, llvm::detail::DenseMapPair<mlir::Operation*, std::pair<unsigned int, unsigned int>>>*, mlir::FallbackAsmResourceMap*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x37564a8)
#21 0x00005602fe2a2043 mlir::Operation::dump() (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x375f043)
#22 0x00005602feaf3182 (anonymous namespace)::WrapAndReplaceBarrierPass::runOnOperation() /CUDA2BANG/cuda2bang/polygeist/lib/polygeist/Passes/ConvertParallelToGPU.cpp:2547:16
#23 0x00005602fecd0881 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x418d881)
#24 0x00005602fecd0e01 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x418de01)
#25 0x00005602fecd197e mlir::PassManager::run(mlir::Operation*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x418e97e)
#26 0x00005602fb5a0efe main /CUDA2BANG/cuda2bang/polygeist/tools/cgeist/driver.cc:882:0
#27 0x00007fdbd1386083 __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:342:3
#28 0x00005602fb57084e _start (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0xa2d84e)
