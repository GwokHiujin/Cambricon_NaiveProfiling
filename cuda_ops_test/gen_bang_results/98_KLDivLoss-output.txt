warning: CUDA version 12.1 is only partially supported
warning: CUDA version 12.1 is only partially supported
[ict-debug] driver.cc: After return 5, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @sdata : memref<1xf32>
  func.func private @_Z35__device_stub__kl_div_kernel_stage1PKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    call @_Z20kl_div_kernel_stage1PKfS0_Pfi(%arg0, %arg1, %arg2, %arg3) : (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()
    return
  }
  func.func private @_Z20kl_div_kernel_stage1PKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %c32_i32 = arith.constant 32 : i32
    %c64_i32 = arith.constant 64 : i32
    %c128_i32 = arith.constant 128 : i32
    %c256_i32 = arith.constant 256 : i32
    %c512_i32 = arith.constant 512 : i32
    %c4_i32 = arith.constant 4 : i32
    %c0_i32 = arith.constant 0 : i32
    %c7_i32 = arith.constant 7 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %c8_i32 = arith.constant 8 : i32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1xf32, 5>
    %0 = "polygeist.memref2pointer"(%alloca_2) : (memref<1xf32, 5>) -> !llvm.ptr
    %1 = gpu.thread_id  x
    %2 = arith.index_cast %1 : index to i32
    %3 = arith.cmpi eq, %2, %c0_i32 : i32
    %4 = gpu.block_id  x
    %5 = arith.index_cast %4 : index to i32
    %6 = gpu.block_dim  x
    %7 = arith.index_cast %6 : index to i32
    %8 = arith.muli %5, %7 : i32
    %9 = arith.muli %8, %c8_i32 : i32
    %10 = arith.addi %9, %2 : i32
    %11 = gpu.block_dim  x
    %12 = arith.index_cast %11 : index to i32
    %13 = gpu.grid_dim  x
    %14 = arith.index_cast %13 : index to i32
    %15 = arith.muli %12, %14 : i32
    %16 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
    %17 = "polygeist.pointer2memref"(%16) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %18 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
    %19 = "polygeist.pointer2memref"(%18) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %20 = gpu.block_dim  x
    %21 = arith.index_cast %20 : index to i32
    %22 = arith.muli %21, %c7_i32 : i32
    %23 = arith.addi %10, %22 : i32
    %24:4 = scf.while (%arg4 = %cst, %arg5 = %23) : (f32, i32) -> (f32, i32, f32, i32) {
      %45 = arith.subi %arg5, %22 : i32
      %46 = arith.cmpi ult, %arg5, %arg3 : i32
      %47:4 = scf.if %46 -> (f32, i32, f32, i32) {
        %48 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %49 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %50 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %51 = llvm.getelementptr %50[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %52 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %53 = llvm.getelementptr %52[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %54 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %55 = llvm.getelementptr %54[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %56 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %57 = llvm.getelementptr %56[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %58 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %59 = llvm.getelementptr %58[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %60 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %61 = llvm.getelementptr %60[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %62 = affine.for %arg6 = 0 to 2 iter_args(%arg7 = %arg4) -> (f32) {
          %67 = arith.index_cast %arg6 : index to i32
          %68 = arith.muli %67, %c4_i32 : i32
          %69 = arith.muli %68, %21 : i32
          %70 = arith.addi %45, %69 : i32
          %71 = arith.divui %70, %c4_i32 : i32
          %72 = arith.index_cast %71 : i32 to index
          %73 = "polygeist.subindex"(%17, %72) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          func.call @_ZN6float4C1ERKS_(%cast_1, %73) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
          %74 = arith.index_cast %71 : i32 to index
          %75 = "polygeist.subindex"(%19, %74) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          func.call @_ZN6float4C1ERKS_(%cast, %75) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
          %76 = llvm.load %48 : !llvm.ptr -> f32
          %77 = math.exp %76 : f32
          %78 = llvm.load %49 : !llvm.ptr -> f32
          %79 = arith.mulf %78, %76 : f32
          %80 = arith.subf %77, %79 : f32
          %81 = arith.addf %arg7, %80 : f32
          %82 = llvm.load %51 : !llvm.ptr -> f32
          %83 = math.exp %82 : f32
          %84 = llvm.load %53 : !llvm.ptr -> f32
          %85 = arith.mulf %84, %82 : f32
          %86 = arith.subf %83, %85 : f32
          %87 = arith.addf %81, %86 : f32
          %88 = llvm.load %55 : !llvm.ptr -> f32
          %89 = math.exp %88 : f32
          %90 = llvm.load %57 : !llvm.ptr -> f32
          %91 = arith.mulf %90, %88 : f32
          %92 = arith.subf %89, %91 : f32
          %93 = arith.addf %87, %92 : f32
          %94 = llvm.load %59 : !llvm.ptr -> f32
          %95 = math.exp %94 : f32
          %96 = llvm.load %61 : !llvm.ptr -> f32
          %97 = arith.mulf %96, %94 : f32
          %98 = arith.subf %95, %97 : f32
          %99 = arith.addf %93, %98 : f32
          affine.yield %99 : f32
        }
        %63 = arith.muli %15, %c8_i32 : i32
        %64 = arith.addi %45, %63 : i32
        %65 = llvm.mlir.undef : f32
        %66 = llvm.mlir.undef : i32
        scf.yield %62, %64, %65, %66 : f32, i32, f32, i32
      } else {
        scf.yield %arg4, %45, %arg4, %45 : f32, i32, f32, i32
      }
      scf.condition(%46) %47#0, %47#1, %47#2, %47#3 : f32, i32, f32, i32
    } do {
    ^bb0(%arg4: f32, %arg5: i32, %arg6: f32, %arg7: i32):
      %45 = arith.addi %arg5, %22 : i32
      scf.yield %arg4, %45 : f32, i32
    }
    %25 = arith.index_cast %arg3 : i32 to index
    %26 = arith.index_cast %24#3 : i32 to index
    %27 = arith.index_cast %15 : i32 to index
    %28 = arith.index_cast %15 : i32 to index
    %29 = arith.index_cast %24#3 : i32 to index
    %30 = arith.subi %25, %26 : index
    %31 = arith.subi %27, %c1 : index
    %32 = arith.addi %31, %30 : index
    %33 = arith.divui %32, %27 : index
    %34 = affine.for %arg4 = 0 to %33 iter_args(%arg5 = %24#2) -> (f32) {
      %45 = affine.load %arg0[%arg4 * symbol(%28) + symbol(%29)] : memref<?xf32>
      %46 = affine.load %arg1[%arg4 * symbol(%28) + symbol(%29)] : memref<?xf32>
      %47 = math.exp %45 : f32
      %48 = arith.mulf %46, %45 : f32
      %49 = arith.subf %47, %48 : f32
      %50 = arith.addf %arg5, %49 : f32
      affine.yield %50 : f32
    }
    affine.store %34, %alloca_2[symbol(%1)] : memref<1xf32, 5>
    nvvm.barrier0
    %35 = gpu.block_dim  x
    %36 = arith.index_cast %35 : index to i32
    %37 = arith.cmpi uge, %36, %c512_i32 : i32
    scf.if %37 {
      %45 = arith.cmpi ult, %2, %c256_i32 : i32
      scf.if %45 {
        %46 = affine.load %alloca_2[symbol(%1) + 256] : memref<1xf32, 5>
        %47 = affine.load %alloca_2[symbol(%1)] : memref<1xf32, 5>
        %48 = arith.addf %47, %46 : f32
        affine.store %48, %alloca_2[symbol(%1)] : memref<1xf32, 5>
      }
      nvvm.barrier0
    }
    %38 = gpu.block_dim  x
    %39 = arith.index_cast %38 : index to i32
    %40 = arith.cmpi uge, %39, %c256_i32 : i32
    scf.if %40 {
      %45 = arith.cmpi ult, %2, %c128_i32 : i32
      scf.if %45 {
        %46 = affine.load %alloca_2[symbol(%1) + 128] : memref<1xf32, 5>
        %47 = affine.load %alloca_2[symbol(%1)] : memref<1xf32, 5>
        %48 = arith.addf %47, %46 : f32
        affine.store %48, %alloca_2[symbol(%1)] : memref<1xf32, 5>
      }
      nvvm.barrier0
    }
    %41 = gpu.block_dim  x
    %42 = arith.index_cast %41 : index to i32
    %43 = arith.cmpi uge, %42, %c128_i32 : i32
    scf.if %43 {
      %45 = arith.cmpi ult, %2, %c64_i32 : i32
      scf.if %45 {
        %46 = affine.load %alloca_2[symbol(%1) + 64] : memref<1xf32, 5>
        %47 = affine.load %alloca_2[symbol(%1)] : memref<1xf32, 5>
        %48 = arith.addf %47, %46 : f32
        affine.store %48, %alloca_2[symbol(%1)] : memref<1xf32, 5>
      }
      nvvm.barrier0
    }
    %44 = arith.cmpi ult, %2, %c32_i32 : i32
    scf.if %44 {
      %45 = "polygeist.pointer2memref"(%0) : (!llvm.ptr) -> memref<?xf32>
      func.call @_Z10warpReduceILj256EEvPVfj(%45, %2) : (memref<?xf32>, i32) -> ()
    }
    scf.if %3 {
      %45 = gpu.block_id  x
      %46 = affine.load %alloca_2[0] : memref<1xf32, 5>
      memref.store %46, %arg2[%45] : memref<?xf32>
    }
    return
  }
  func.func private @_Z35__device_stub__kl_div_kernel_stage2PKfPfif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    call @_Z20kl_div_kernel_stage2PKfPfif(%arg0, %arg1, %arg2, %arg3) : (memref<?xf32>, memref<?xf32>, i32, f32) -> ()
    return
  }
  func.func private @_Z20kl_div_kernel_stage2PKfPfif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %c-3_i32 = arith.constant -3 : i32
    %c0_i32 = arith.constant 0 : i32
    %c32_i32 = arith.constant 32 : i32
    %c64_i32 = arith.constant 64 : i32
    %c128_i32 = arith.constant 128 : i32
    %c256_i32 = arith.constant 256 : i32
    %c512_i32 = arith.constant 512 : i32
    %c4_i32 = arith.constant 4 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %0 = gpu.thread_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.cmpi eq, %1, %c0_i32 : i32
    %3 = arith.cmpi sge, %arg2, %c4_i32 : i32
    %4 = scf.if %3 -> (f32) {
      %28 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %29 = "polygeist.pointer2memref"(%28) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %30 = arith.muli %1, %c4_i32 : i32
      %31 = arith.addi %arg2, %c-3_i32 : i32
      %32 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %33 = llvm.getelementptr %32[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %34 = llvm.getelementptr %32[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %35 = llvm.getelementptr %32[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %36 = gpu.block_dim  x
      %37 = arith.index_cast %36 : index to i32
      %38 = arith.muli %37, %c4_i32 : i32
      %39 = arith.index_cast %31 : i32 to index
      %40 = arith.index_cast %30 : i32 to index
      %41 = arith.index_cast %38 : i32 to index
      %42 = arith.index_cast %38 : i32 to index
      %43 = arith.index_cast %30 : i32 to index
      %44 = scf.for %arg4 = %40 to %39 step %41 iter_args(%arg5 = %cst) -> (f32) {
        %45 = arith.subi %arg4, %40 : index
        %46 = arith.divui %45, %41 : index
        %47 = arith.muli %46, %42 : index
        %48 = arith.addi %43, %47 : index
        %49 = arith.index_cast %48 : index to i32
        %50 = arith.divsi %49, %c4_i32 : i32
        %51 = arith.index_cast %50 : i32 to index
        %52 = "polygeist.subindex"(%29, %51) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        func.call @_ZN6float4C1ERKS_(%cast, %52) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
        %53 = llvm.load %32 : !llvm.ptr -> f32
        %54 = llvm.load %33 : !llvm.ptr -> f32
        %55 = arith.addf %53, %54 : f32
        %56 = llvm.load %34 : !llvm.ptr -> f32
        %57 = arith.addf %55, %56 : f32
        %58 = llvm.load %35 : !llvm.ptr -> f32
        %59 = arith.addf %57, %58 : f32
        %60 = arith.addf %arg5, %59 : f32
        scf.yield %60 : f32
      }
      scf.yield %44 : f32
    } else {
      scf.yield %cst : f32
    }
    %5 = arith.divsi %arg2, %c4_i32 : i32
    %6 = arith.muli %5, %c4_i32 : i32
    %7 = arith.addi %1, %6 : i32
    %8 = gpu.block_dim  x
    %9 = arith.index_cast %arg2 : i32 to index
    %10 = arith.index_cast %7 : i32 to index
    %11 = arith.index_cast %7 : i32 to index
    %12 = arith.subi %9, %10 : index
    %13 = arith.subi %8, %c1 : index
    %14 = arith.addi %13, %12 : index
    %15 = arith.divui %14, %8 : index
    %16 = affine.for %arg4 = 0 to %15 iter_args(%arg5 = %4) -> (f32) {
      %28 = affine.load %arg0[%arg4 * symbol(%8) + symbol(%11)] : memref<?xf32>
      %29 = arith.addf %arg5, %28 : f32
      affine.yield %29 : f32
    }
    %17 = memref.get_global @sdata : memref<1xf32>
    affine.store %16, %17[symbol(%0)] : memref<1xf32>
    nvvm.barrier0
    %18 = gpu.block_dim  x
    %19 = arith.index_cast %18 : index to i32
    %20 = arith.cmpi uge, %19, %c512_i32 : i32
    scf.if %20 {
      %28 = arith.cmpi ult, %1, %c256_i32 : i32
      scf.if %28 {
        %29 = memref.get_global @sdata : memref<1xf32>
        %30 = affine.load %29[symbol(%0) + 256] : memref<1xf32>
        %31 = affine.load %29[symbol(%0)] : memref<1xf32>
        %32 = arith.addf %31, %30 : f32
        affine.store %32, %29[symbol(%0)] : memref<1xf32>
      }
      nvvm.barrier0
    }
    %21 = gpu.block_dim  x
    %22 = arith.index_cast %21 : index to i32
    %23 = arith.cmpi uge, %22, %c256_i32 : i32
    scf.if %23 {
      %28 = arith.cmpi ult, %1, %c128_i32 : i32
      scf.if %28 {
        %29 = memref.get_global @sdata : memref<1xf32>
        %30 = affine.load %29[symbol(%0) + 128] : memref<1xf32>
        %31 = affine.load %29[symbol(%0)] : memref<1xf32>
        %32 = arith.addf %31, %30 : f32
        affine.store %32, %29[symbol(%0)] : memref<1xf32>
      }
      nvvm.barrier0
    }
    %24 = gpu.block_dim  x
    %25 = arith.index_cast %24 : index to i32
    %26 = arith.cmpi uge, %25, %c128_i32 : i32
    scf.if %26 {
      %28 = arith.cmpi ult, %1, %c64_i32 : i32
      scf.if %28 {
        %29 = memref.get_global @sdata : memref<1xf32>
        %30 = affine.load %29[symbol(%0) + 64] : memref<1xf32>
        %31 = affine.load %29[symbol(%0)] : memref<1xf32>
        %32 = arith.addf %31, %30 : f32
        affine.store %32, %29[symbol(%0)] : memref<1xf32>
      }
      nvvm.barrier0
    }
    %27 = arith.cmpi ult, %1, %c32_i32 : i32
    scf.if %27 {
      %28 = memref.get_global @sdata : memref<1xf32>
      %cast_0 = memref.cast %28 : memref<1xf32> to memref<?xf32>
      func.call @_Z10warpReduceILj256EEvPVfj(%cast_0, %1) : (memref<?xf32>, i32) -> ()
    }
    scf.if %2 {
      %28 = memref.get_global @sdata : memref<1xf32>
      %29 = affine.load %28[0] : memref<1xf32>
      %30 = arith.mulf %29, %arg3 : f32
      affine.store %30, %arg1[0] : memref<?xf32>
    }
    return
  }
  func.func private @_ZN6float4C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
  func.func private @_Z10warpReduceILj256EEvPVfj(%arg0: memref<?xf32>, %arg1: i32) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    %0 = arith.index_cast %arg1 : i32 to index
    %1 = arith.index_cast %arg1 : i32 to index
    %2 = arith.index_cast %arg1 : i32 to index
    %3 = arith.index_cast %arg1 : i32 to index
    %4 = arith.index_cast %arg1 : i32 to index
    %5 = arith.index_cast %arg1 : i32 to index
    %6 = arith.index_cast %arg1 : i32 to index
    %7 = affine.load %arg0[symbol(%0) + 32] : memref<?xf32>
    %8 = affine.load %arg0[symbol(%6)] : memref<?xf32>
    %9 = arith.addf %8, %7 : f32
    affine.store %9, %arg0[symbol(%6)] : memref<?xf32>
    %10 = arith.index_cast %arg1 : i32 to index
    %11 = affine.load %arg0[symbol(%1) + 16] : memref<?xf32>
    %12 = affine.load %arg0[symbol(%10)] : memref<?xf32>
    %13 = arith.addf %12, %11 : f32
    affine.store %13, %arg0[symbol(%10)] : memref<?xf32>
    %14 = arith.index_cast %arg1 : i32 to index
    %15 = affine.load %arg0[symbol(%2) + 8] : memref<?xf32>
    %16 = affine.load %arg0[symbol(%14)] : memref<?xf32>
    %17 = arith.addf %16, %15 : f32
    affine.store %17, %arg0[symbol(%14)] : memref<?xf32>
    %18 = arith.index_cast %arg1 : i32 to index
    %19 = affine.load %arg0[symbol(%3) + 4] : memref<?xf32>
    %20 = affine.load %arg0[symbol(%18)] : memref<?xf32>
    %21 = arith.addf %20, %19 : f32
    affine.store %21, %arg0[symbol(%18)] : memref<?xf32>
    %22 = arith.index_cast %arg1 : i32 to index
    %23 = affine.load %arg0[symbol(%4) + 2] : memref<?xf32>
    %24 = affine.load %arg0[symbol(%22)] : memref<?xf32>
    %25 = arith.addf %24, %23 : f32
    affine.store %25, %arg0[symbol(%22)] : memref<?xf32>
    %26 = arith.index_cast %arg1 : i32 to index
    %27 = affine.load %arg0[symbol(%5) + 1] : memref<?xf32>
    %28 = affine.load %arg0[symbol(%26)] : memref<?xf32>
    %29 = arith.addf %28, %27 : f32
    affine.store %29, %arg0[symbol(%26)] : memref<?xf32>
    return
  }
}
[ict-debug] driver.cc: After return 5, module: end

[ict-debug] driver.cc: After return 6, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @sdata : memref<1xf32>
  func.func private @_Z20kl_div_kernel_stage1PKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %c32_i32 = arith.constant 32 : i32
    %c64_i32 = arith.constant 64 : i32
    %c128_i32 = arith.constant 128 : i32
    %c256_i32 = arith.constant 256 : i32
    %c512_i32 = arith.constant 512 : i32
    %c4_i32 = arith.constant 4 : i32
    %c0_i32 = arith.constant 0 : i32
    %c7_i32 = arith.constant 7 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %c8_i32 = arith.constant 8 : i32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1xf32, 5>
    %0 = gpu.thread_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.cmpi eq, %1, %c0_i32 : i32
    %3 = gpu.block_id  x
    %4 = arith.index_cast %3 : index to i32
    %5 = gpu.block_dim  x
    %6 = arith.index_cast %5 : index to i32
    %7 = arith.muli %4, %6 : i32
    %8 = arith.muli %7, %c8_i32 : i32
    %9 = arith.addi %8, %1 : i32
    %10 = gpu.grid_dim  x
    %11 = arith.index_cast %10 : index to i32
    %12 = arith.muli %6, %11 : i32
    %13 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
    %14 = "polygeist.pointer2memref"(%13) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %15 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
    %16 = "polygeist.pointer2memref"(%15) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %17 = arith.muli %6, %c7_i32 : i32
    %18 = arith.addi %9, %17 : i32
    %19:4 = scf.while (%arg4 = %cst, %arg5 = %18) : (f32, i32) -> (f32, i32, f32, i32) {
      %32 = arith.subi %arg5, %17 : i32
      %33 = arith.cmpi ult, %arg5, %arg3 : i32
      %34:4 = scf.if %33 -> (f32, i32, f32, i32) {
        %35 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %36 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %37 = llvm.getelementptr %35[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %38 = llvm.getelementptr %36[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %39 = llvm.getelementptr %35[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %40 = llvm.getelementptr %36[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %41 = llvm.getelementptr %35[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %42 = llvm.getelementptr %36[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %43 = affine.for %arg6 = 0 to 2 iter_args(%arg7 = %arg4) -> (f32) {
          %48 = arith.index_cast %arg6 : index to i32
          %49 = arith.muli %48, %c4_i32 : i32
          %50 = arith.muli %49, %6 : i32
          %51 = arith.addi %32, %50 : i32
          %52 = arith.divui %51, %c4_i32 : i32
          %53 = arith.index_cast %52 : i32 to index
          %54 = "polygeist.subindex"(%14, %53) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          func.call @_ZN6float4C1ERKS_(%cast_1, %54) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
          %55 = "polygeist.subindex"(%16, %53) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          func.call @_ZN6float4C1ERKS_(%cast, %55) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
          %56 = llvm.load %35 : !llvm.ptr -> f32
          %57 = math.exp %56 : f32
          %58 = llvm.load %36 : !llvm.ptr -> f32
          %59 = arith.mulf %58, %56 : f32
          %60 = arith.subf %57, %59 : f32
          %61 = arith.addf %arg7, %60 : f32
          %62 = llvm.load %37 : !llvm.ptr -> f32
          %63 = math.exp %62 : f32
          %64 = llvm.load %38 : !llvm.ptr -> f32
          %65 = arith.mulf %64, %62 : f32
          %66 = arith.subf %63, %65 : f32
          %67 = arith.addf %61, %66 : f32
          %68 = llvm.load %39 : !llvm.ptr -> f32
          %69 = math.exp %68 : f32
          %70 = llvm.load %40 : !llvm.ptr -> f32
          %71 = arith.mulf %70, %68 : f32
          %72 = arith.subf %69, %71 : f32
          %73 = arith.addf %67, %72 : f32
          %74 = llvm.load %41 : !llvm.ptr -> f32
          %75 = math.exp %74 : f32
          %76 = llvm.load %42 : !llvm.ptr -> f32
          %77 = arith.mulf %76, %74 : f32
          %78 = arith.subf %75, %77 : f32
          %79 = arith.addf %73, %78 : f32
          affine.yield %79 : f32
        }
        %44 = arith.muli %12, %c8_i32 : i32
        %45 = arith.addi %32, %44 : i32
        %46 = llvm.mlir.undef : f32
        %47 = llvm.mlir.undef : i32
        scf.yield %43, %45, %46, %47 : f32, i32, f32, i32
      } else {
        scf.yield %arg4, %32, %arg4, %32 : f32, i32, f32, i32
      }
      scf.condition(%33) %34#0, %34#1, %34#2, %34#3 : f32, i32, f32, i32
    } do {
    ^bb0(%arg4: f32, %arg5: i32, %arg6: f32, %arg7: i32):
      %32 = arith.addi %arg5, %17 : i32
      scf.yield %arg4, %32 : f32, i32
    }
    %20 = arith.index_cast %arg3 : i32 to index
    %21 = arith.index_cast %19#3 : i32 to index
    %22 = arith.index_cast %12 : i32 to index
    %23 = arith.subi %20, %21 : index
    %24 = arith.subi %22, %c1 : index
    %25 = arith.addi %24, %23 : index
    %26 = arith.divui %25, %22 : index
    %27 = affine.for %arg4 = 0 to %26 iter_args(%arg5 = %19#2) -> (f32) {
      %32 = affine.load %arg0[%arg4 * symbol(%22) + symbol(%21)] : memref<?xf32>
      %33 = affine.load %arg1[%arg4 * symbol(%22) + symbol(%21)] : memref<?xf32>
      %34 = math.exp %32 : f32
      %35 = arith.mulf %33, %32 : f32
      %36 = arith.subf %34, %35 : f32
      %37 = arith.addf %arg5, %36 : f32
      affine.yield %37 : f32
    }
    affine.store %27, %alloca_2[symbol(%0)] : memref<1xf32, 5>
    nvvm.barrier0
    %28 = arith.cmpi uge, %6, %c512_i32 : i32
    scf.if %28 {
      %32 = arith.cmpi ult, %1, %c256_i32 : i32
      scf.if %32 {
        %33 = affine.load %alloca_2[symbol(%0) + 256] : memref<1xf32, 5>
        %34 = affine.load %alloca_2[symbol(%0)] : memref<1xf32, 5>
        %35 = arith.addf %34, %33 : f32
        affine.store %35, %alloca_2[symbol(%0)] : memref<1xf32, 5>
      }
      nvvm.barrier0
    }
    %29 = arith.cmpi uge, %6, %c256_i32 : i32
    scf.if %29 {
      %32 = arith.cmpi ult, %1, %c128_i32 : i32
      scf.if %32 {
        %33 = affine.load %alloca_2[symbol(%0) + 128] : memref<1xf32, 5>
        %34 = affine.load %alloca_2[symbol(%0)] : memref<1xf32, 5>
        %35 = arith.addf %34, %33 : f32
        affine.store %35, %alloca_2[symbol(%0)] : memref<1xf32, 5>
      }
      nvvm.barrier0
    }
    %30 = arith.cmpi uge, %6, %c128_i32 : i32
    scf.if %30 {
      %32 = arith.cmpi ult, %1, %c64_i32 : i32
      scf.if %32 {
        %33 = affine.load %alloca_2[symbol(%0) + 64] : memref<1xf32, 5>
        %34 = affine.load %alloca_2[symbol(%0)] : memref<1xf32, 5>
        %35 = arith.addf %34, %33 : f32
        affine.store %35, %alloca_2[symbol(%0)] : memref<1xf32, 5>
      }
      nvvm.barrier0
    }
    %31 = arith.cmpi ult, %1, %c32_i32 : i32
    scf.if %31 {
      %32 = affine.load %alloca_2[symbol(%0) + 32] : memref<1xf32, 5>
      %33 = affine.load %alloca_2[symbol(%0)] : memref<1xf32, 5>
      %34 = arith.addf %33, %32 : f32
      affine.store %34, %alloca_2[symbol(%0)] : memref<1xf32, 5>
      %35 = affine.load %alloca_2[symbol(%0) + 16] : memref<1xf32, 5>
      %36 = arith.addf %34, %35 : f32
      affine.store %36, %alloca_2[symbol(%0)] : memref<1xf32, 5>
      %37 = affine.load %alloca_2[symbol(%0) + 8] : memref<1xf32, 5>
      %38 = arith.addf %36, %37 : f32
      affine.store %38, %alloca_2[symbol(%0)] : memref<1xf32, 5>
      %39 = affine.load %alloca_2[symbol(%0) + 4] : memref<1xf32, 5>
      %40 = arith.addf %38, %39 : f32
      affine.store %40, %alloca_2[symbol(%0)] : memref<1xf32, 5>
      %41 = affine.load %alloca_2[symbol(%0) + 2] : memref<1xf32, 5>
      %42 = arith.addf %40, %41 : f32
      affine.store %42, %alloca_2[symbol(%0)] : memref<1xf32, 5>
      %43 = affine.load %alloca_2[symbol(%0) + 1] : memref<1xf32, 5>
      %44 = arith.addf %42, %43 : f32
      affine.store %44, %alloca_2[symbol(%0)] : memref<1xf32, 5>
    }
    scf.if %2 {
      %32 = affine.load %alloca_2[0] : memref<1xf32, 5>
      affine.store %32, %arg2[symbol(%3)] : memref<?xf32>
    }
    return
  }
  func.func private @_Z20kl_div_kernel_stage2PKfPfif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c1 = arith.constant 1 : index
    %c-3_i32 = arith.constant -3 : i32
    %c0_i32 = arith.constant 0 : i32
    %c32_i32 = arith.constant 32 : i32
    %c64_i32 = arith.constant 64 : i32
    %c128_i32 = arith.constant 128 : i32
    %c256_i32 = arith.constant 256 : i32
    %c512_i32 = arith.constant 512 : i32
    %c4_i32 = arith.constant 4 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %0 = gpu.thread_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.cmpi eq, %1, %c0_i32 : i32
    %3 = arith.cmpi sge, %arg2, %c4_i32 : i32
    %4 = scf.if %3 -> (f32) {
      %22 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %23 = "polygeist.pointer2memref"(%22) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %24 = arith.muli %1, %c4_i32 : i32
      %25 = arith.addi %arg2, %c-3_i32 : i32
      %26 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %27 = llvm.getelementptr %26[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %28 = llvm.getelementptr %26[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %29 = llvm.getelementptr %26[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %30 = gpu.block_dim  x
      %31 = arith.index_cast %30 : index to i32
      %32 = arith.muli %31, %c4_i32 : i32
      %33 = arith.index_cast %25 : i32 to index
      %34 = arith.index_cast %24 : i32 to index
      %35 = arith.index_cast %32 : i32 to index
      %36 = scf.for %arg4 = %34 to %33 step %35 iter_args(%arg5 = %cst) -> (f32) {
        %37 = arith.subi %arg4, %34 : index
        %38 = arith.divui %37, %35 : index
        %39 = arith.muli %38, %35 : index
        %40 = arith.addi %34, %39 : index
        %41 = arith.index_cast %40 : index to i32
        %42 = arith.divsi %41, %c4_i32 : i32
        %43 = arith.index_cast %42 : i32 to index
        %44 = "polygeist.subindex"(%23, %43) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        func.call @_ZN6float4C1ERKS_(%cast, %44) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
        %45 = llvm.load %26 : !llvm.ptr -> f32
        %46 = llvm.load %27 : !llvm.ptr -> f32
        %47 = arith.addf %45, %46 : f32
        %48 = llvm.load %28 : !llvm.ptr -> f32
        %49 = arith.addf %47, %48 : f32
        %50 = llvm.load %29 : !llvm.ptr -> f32
        %51 = arith.addf %49, %50 : f32
        %52 = arith.addf %arg5, %51 : f32
        scf.yield %52 : f32
      }
      scf.yield %36 : f32
    } else {
      scf.yield %cst : f32
    }
    %5 = arith.divsi %arg2, %c4_i32 : i32
    %6 = arith.muli %5, %c4_i32 : i32
    %7 = arith.addi %1, %6 : i32
    %8 = gpu.block_dim  x
    %9 = arith.index_cast %arg2 : i32 to index
    %10 = arith.index_cast %7 : i32 to index
    %11 = arith.subi %9, %10 : index
    %12 = arith.subi %8, %c1 : index
    %13 = arith.addi %12, %11 : index
    %14 = arith.divui %13, %8 : index
    %15 = affine.for %arg4 = 0 to %14 iter_args(%arg5 = %4) -> (f32) {
      %22 = affine.load %arg0[%arg4 * symbol(%8) + symbol(%10)] : memref<?xf32>
      %23 = arith.addf %arg5, %22 : f32
      affine.yield %23 : f32
    }
    %16 = memref.get_global @sdata : memref<1xf32>
    affine.store %15, %16[symbol(%0)] : memref<1xf32>
    nvvm.barrier0
    %17 = arith.index_cast %8 : index to i32
    %18 = arith.cmpi uge, %17, %c512_i32 : i32
    scf.if %18 {
      %22 = arith.cmpi ult, %1, %c256_i32 : i32
      scf.if %22 {
        %23 = affine.load %16[symbol(%0) + 256] : memref<1xf32>
        %24 = affine.load %16[symbol(%0)] : memref<1xf32>
        %25 = arith.addf %24, %23 : f32
        affine.store %25, %16[symbol(%0)] : memref<1xf32>
      }
      nvvm.barrier0
    }
    %19 = arith.cmpi uge, %17, %c256_i32 : i32
    scf.if %19 {
      %22 = arith.cmpi ult, %1, %c128_i32 : i32
      scf.if %22 {
        %23 = affine.load %16[symbol(%0) + 128] : memref<1xf32>
        %24 = affine.load %16[symbol(%0)] : memref<1xf32>
        %25 = arith.addf %24, %23 : f32
        affine.store %25, %16[symbol(%0)] : memref<1xf32>
      }
      nvvm.barrier0
    }
    %20 = arith.cmpi uge, %17, %c128_i32 : i32
    scf.if %20 {
      %22 = arith.cmpi ult, %1, %c64_i32 : i32
      scf.if %22 {
        %23 = affine.load %16[symbol(%0) + 64] : memref<1xf32>
        %24 = affine.load %16[symbol(%0)] : memref<1xf32>
        %25 = arith.addf %24, %23 : f32
        affine.store %25, %16[symbol(%0)] : memref<1xf32>
      }
      nvvm.barrier0
    }
    %21 = arith.cmpi ult, %1, %c32_i32 : i32
    scf.if %21 {
      %22 = affine.load %16[symbol(%0) + 32] : memref<1xf32>
      %23 = affine.load %16[symbol(%0)] : memref<1xf32>
      %24 = arith.addf %23, %22 : f32
      affine.store %24, %16[symbol(%0)] : memref<1xf32>
      %25 = affine.load %16[symbol(%0) + 16] : memref<1xf32>
      %26 = arith.addf %24, %25 : f32
      affine.store %26, %16[symbol(%0)] : memref<1xf32>
      %27 = affine.load %16[symbol(%0) + 8] : memref<1xf32>
      %28 = arith.addf %26, %27 : f32
      affine.store %28, %16[symbol(%0)] : memref<1xf32>
      %29 = affine.load %16[symbol(%0) + 4] : memref<1xf32>
      %30 = arith.addf %28, %29 : f32
      affine.store %30, %16[symbol(%0)] : memref<1xf32>
      %31 = affine.load %16[symbol(%0) + 2] : memref<1xf32>
      %32 = arith.addf %30, %31 : f32
      affine.store %32, %16[symbol(%0)] : memref<1xf32>
      %33 = affine.load %16[symbol(%0) + 1] : memref<1xf32>
      %34 = arith.addf %32, %33 : f32
      affine.store %34, %16[symbol(%0)] : memref<1xf32>
    }
    scf.if %2 {
      %22 = affine.load %16[0] : memref<1xf32>
      %23 = arith.mulf %22, %arg3 : f32
      affine.store %23, %arg1[0] : memref<?xf32>
    }
    return
  }
  func.func private @_ZN6float4C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
}
[ict-debug] driver.cc: After return 6, module: end

WrapAndReplaceBarrierPass::runOnOperation(): before execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @sdata : memref<1xf32>
  func.func private @_Z20kl_div_kernel_stage1PKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c4 = arith.constant 4 : index
    %c8 = arith.constant 8 : index
    %c16 = arith.constant 16 : index
    %c32 = arith.constant 32 : index
    %c64 = arith.constant 64 : index
    %c128 = arith.constant 128 : index
    %c256 = arith.constant 256 : index
    %c2 = arith.constant 2 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32_i32 = arith.constant 32 : i32
    %c64_i32 = arith.constant 64 : i32
    %c128_i32 = arith.constant 128 : i32
    %c256_i32 = arith.constant 256 : i32
    %c512_i32 = arith.constant 512 : i32
    %c4_i32 = arith.constant 4 : i32
    %c0_i32 = arith.constant 0 : i32
    %c7_i32 = arith.constant 7 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %c8_i32 = arith.constant 8 : i32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1xf32, 5>
    %0 = gpu.thread_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.cmpi eq, %1, %c0_i32 : i32
    %3 = gpu.block_id  x
    %4 = arith.index_cast %3 : index to i32
    %5 = gpu.block_dim  x
    %6 = arith.index_cast %5 : index to i32
    %7 = arith.muli %4, %6 : i32
    %8 = arith.muli %7, %c8_i32 : i32
    %9 = arith.addi %8, %1 : i32
    %10 = gpu.grid_dim  x
    %11 = arith.index_cast %10 : index to i32
    %12 = arith.muli %6, %11 : i32
    %13 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
    %14 = "polygeist.pointer2memref"(%13) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %15 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
    %16 = "polygeist.pointer2memref"(%15) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %17 = arith.muli %6, %c7_i32 : i32
    %18 = arith.addi %9, %17 : i32
    %19:4 = scf.while (%arg4 = %cst, %arg5 = %18) : (f32, i32) -> (f32, i32, f32, i32) {
      %32 = arith.subi %arg5, %17 : i32
      %33 = arith.cmpi ult, %arg5, %arg3 : i32
      %34:4 = scf.if %33 -> (f32, i32, f32, i32) {
        %35 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %36 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %37 = llvm.getelementptr %35[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %38 = llvm.getelementptr %36[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %39 = llvm.getelementptr %35[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %40 = llvm.getelementptr %36[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %41 = llvm.getelementptr %35[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %42 = llvm.getelementptr %36[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %43 = scf.for %arg6 = %c0 to %c2 step %c1 iter_args(%arg7 = %arg4) -> (f32) {
          %48 = arith.index_cast %arg6 : index to i32
          %49 = arith.muli %48, %c4_i32 : i32
          %50 = arith.muli %49, %6 : i32
          %51 = arith.addi %32, %50 : i32
          %52 = arith.divui %51, %c4_i32 : i32
          %53 = arith.index_cast %52 : i32 to index
          %54 = "polygeist.subindex"(%14, %53) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          func.call @_ZN6float4C1ERKS_(%cast_1, %54) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
          %55 = "polygeist.subindex"(%16, %53) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          func.call @_ZN6float4C1ERKS_(%cast, %55) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
          %56 = llvm.load %35 : !llvm.ptr -> f32
          %57 = math.exp %56 : f32
          %58 = llvm.load %36 : !llvm.ptr -> f32
          %59 = arith.mulf %58, %56 : f32
          %60 = arith.subf %57, %59 : f32
          %61 = arith.addf %arg7, %60 : f32
          %62 = llvm.load %37 : !llvm.ptr -> f32
          %63 = math.exp %62 : f32
          %64 = llvm.load %38 : !llvm.ptr -> f32
          %65 = arith.mulf %64, %62 : f32
          %66 = arith.subf %63, %65 : f32
          %67 = arith.addf %61, %66 : f32
          %68 = llvm.load %39 : !llvm.ptr -> f32
          %69 = math.exp %68 : f32
          %70 = llvm.load %40 : !llvm.ptr -> f32
          %71 = arith.mulf %70, %68 : f32
          %72 = arith.subf %69, %71 : f32
          %73 = arith.addf %67, %72 : f32
          %74 = llvm.load %41 : !llvm.ptr -> f32
          %75 = math.exp %74 : f32
          %76 = llvm.load %42 : !llvm.ptr -> f32
          %77 = arith.mulf %76, %74 : f32
          %78 = arith.subf %75, %77 : f32
          %79 = arith.addf %73, %78 : f32
          scf.yield %79 : f32
        }
        %44 = arith.muli %12, %c8_i32 : i32
        %45 = arith.addi %32, %44 : i32
        %46 = llvm.mlir.undef : f32
        %47 = llvm.mlir.undef : i32
        scf.yield %43, %45, %46, %47 : f32, i32, f32, i32
      } else {
        scf.yield %arg4, %32, %arg4, %32 : f32, i32, f32, i32
      }
      scf.condition(%33) %34#0, %34#1, %34#2, %34#3 : f32, i32, f32, i32
    } do {
    ^bb0(%arg4: f32, %arg5: i32, %arg6: f32, %arg7: i32):
      %32 = arith.addi %arg5, %17 : i32
      scf.yield %arg4, %32 : f32, i32
    }
    %20 = arith.index_cast %arg3 : i32 to index
    %21 = arith.index_cast %19#3 : i32 to index
    %22 = arith.index_cast %12 : i32 to index
    %23 = arith.subi %20, %21 : index
    %24 = arith.subi %22, %c1 : index
    %25 = arith.addi %24, %23 : index
    %26 = arith.divui %25, %22 : index
    %27 = scf.for %arg4 = %c0 to %26 step %c1 iter_args(%arg5 = %19#2) -> (f32) {
      %32 = arith.muli %arg4, %22 : index
      %33 = arith.addi %32, %21 : index
      %34 = memref.load %arg0[%33] : memref<?xf32>
      %35 = memref.load %arg1[%33] : memref<?xf32>
      %36 = math.exp %34 : f32
      %37 = arith.mulf %35, %34 : f32
      %38 = arith.subf %36, %37 : f32
      %39 = arith.addf %arg5, %38 : f32
      scf.yield %39 : f32
    }
    memref.store %27, %alloca_2[%0] : memref<1xf32, 5>
    nvvm.barrier0
    %28 = arith.cmpi uge, %6, %c512_i32 : i32
    scf.if %28 {
      %32 = arith.cmpi ult, %1, %c256_i32 : i32
      scf.if %32 {
        %33 = arith.addi %0, %c256 : index
        %34 = memref.load %alloca_2[%33] : memref<1xf32, 5>
        %35 = memref.load %alloca_2[%0] : memref<1xf32, 5>
        %36 = arith.addf %35, %34 : f32
        memref.store %36, %alloca_2[%0] : memref<1xf32, 5>
      }
      nvvm.barrier0
    }
    %29 = arith.cmpi uge, %6, %c256_i32 : i32
    scf.if %29 {
      %32 = arith.cmpi ult, %1, %c128_i32 : i32
      scf.if %32 {
        %33 = arith.addi %0, %c128 : index
        %34 = memref.load %alloca_2[%33] : memref<1xf32, 5>
        %35 = memref.load %alloca_2[%0] : memref<1xf32, 5>
        %36 = arith.addf %35, %34 : f32
        memref.store %36, %alloca_2[%0] : memref<1xf32, 5>
      }
      nvvm.barrier0
    }
    %30 = arith.cmpi uge, %6, %c128_i32 : i32
    scf.if %30 {
      %32 = arith.cmpi ult, %1, %c64_i32 : i32
      scf.if %32 {
        %33 = arith.addi %0, %c64 : index
        %34 = memref.load %alloca_2[%33] : memref<1xf32, 5>
        %35 = memref.load %alloca_2[%0] : memref<1xf32, 5>
        %36 = arith.addf %35, %34 : f32
        memref.store %36, %alloca_2[%0] : memref<1xf32, 5>
      }
      nvvm.barrier0
    }
    %31 = arith.cmpi ult, %1, %c32_i32 : i32
    scf.if %31 {
      %32 = arith.addi %0, %c32 : index
      %33 = memref.load %alloca_2[%32] : memref<1xf32, 5>
      %34 = memref.load %alloca_2[%0] : memref<1xf32, 5>
      %35 = arith.addf %34, %33 : f32
      memref.store %35, %alloca_2[%0] : memref<1xf32, 5>
      %36 = arith.addi %0, %c16 : index
      %37 = memref.load %alloca_2[%36] : memref<1xf32, 5>
      %38 = arith.addf %35, %37 : f32
      memref.store %38, %alloca_2[%0] : memref<1xf32, 5>
      %39 = arith.addi %0, %c8 : index
      %40 = memref.load %alloca_2[%39] : memref<1xf32, 5>
      %41 = arith.addf %38, %40 : f32
      memref.store %41, %alloca_2[%0] : memref<1xf32, 5>
      %42 = arith.addi %0, %c4 : index
      %43 = memref.load %alloca_2[%42] : memref<1xf32, 5>
      %44 = arith.addf %41, %43 : f32
      memref.store %44, %alloca_2[%0] : memref<1xf32, 5>
      %45 = arith.addi %0, %c2 : index
      %46 = memref.load %alloca_2[%45] : memref<1xf32, 5>
      %47 = arith.addf %44, %46 : f32
      memref.store %47, %alloca_2[%0] : memref<1xf32, 5>
      %48 = arith.addi %0, %c1 : index
      %49 = memref.load %alloca_2[%48] : memref<1xf32, 5>
      %50 = arith.addf %47, %49 : f32
      memref.store %50, %alloca_2[%0] : memref<1xf32, 5>
    }
    scf.if %2 {
      %32 = memref.load %alloca_2[%c0] : memref<1xf32, 5>
      memref.store %32, %arg2[%3] : memref<?xf32>
    }
    return
  }
  func.func private @_Z20kl_div_kernel_stage2PKfPfif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c2 = arith.constant 2 : index
    %c4 = arith.constant 4 : index
    %c8 = arith.constant 8 : index
    %c16 = arith.constant 16 : index
    %c32 = arith.constant 32 : index
    %c64 = arith.constant 64 : index
    %c128 = arith.constant 128 : index
    %c256 = arith.constant 256 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c-3_i32 = arith.constant -3 : i32
    %c0_i32 = arith.constant 0 : i32
    %c32_i32 = arith.constant 32 : i32
    %c64_i32 = arith.constant 64 : i32
    %c128_i32 = arith.constant 128 : i32
    %c256_i32 = arith.constant 256 : i32
    %c512_i32 = arith.constant 512 : i32
    %c4_i32 = arith.constant 4 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %0 = gpu.thread_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.cmpi eq, %1, %c0_i32 : i32
    %3 = arith.cmpi sge, %arg2, %c4_i32 : i32
    %4 = scf.if %3 -> (f32) {
      %22 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %23 = "polygeist.pointer2memref"(%22) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %24 = arith.muli %1, %c4_i32 : i32
      %25 = arith.addi %arg2, %c-3_i32 : i32
      %26 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %27 = llvm.getelementptr %26[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %28 = llvm.getelementptr %26[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %29 = llvm.getelementptr %26[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %30 = gpu.block_dim  x
      %31 = arith.index_cast %30 : index to i32
      %32 = arith.muli %31, %c4_i32 : i32
      %33 = arith.index_cast %25 : i32 to index
      %34 = arith.index_cast %24 : i32 to index
      %35 = arith.index_cast %32 : i32 to index
      %36 = scf.for %arg4 = %34 to %33 step %35 iter_args(%arg5 = %cst) -> (f32) {
        %37 = arith.subi %arg4, %34 : index
        %38 = arith.divui %37, %35 : index
        %39 = arith.muli %38, %35 : index
        %40 = arith.addi %34, %39 : index
        %41 = arith.index_cast %40 : index to i32
        %42 = arith.divsi %41, %c4_i32 : i32
        %43 = arith.index_cast %42 : i32 to index
        %44 = "polygeist.subindex"(%23, %43) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        func.call @_ZN6float4C1ERKS_(%cast, %44) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
        %45 = llvm.load %26 : !llvm.ptr -> f32
        %46 = llvm.load %27 : !llvm.ptr -> f32
        %47 = arith.addf %45, %46 : f32
        %48 = llvm.load %28 : !llvm.ptr -> f32
        %49 = arith.addf %47, %48 : f32
        %50 = llvm.load %29 : !llvm.ptr -> f32
        %51 = arith.addf %49, %50 : f32
        %52 = arith.addf %arg5, %51 : f32
        scf.yield %52 : f32
      }
      scf.yield %36 : f32
    } else {
      scf.yield %cst : f32
    }
    %5 = arith.divsi %arg2, %c4_i32 : i32
    %6 = arith.muli %5, %c4_i32 : i32
    %7 = arith.addi %1, %6 : i32
    %8 = gpu.block_dim  x
    %9 = arith.index_cast %arg2 : i32 to index
    %10 = arith.index_cast %7 : i32 to index
    %11 = arith.subi %9, %10 : index
    %12 = arith.subi %8, %c1 : index
    %13 = arith.addi %12, %11 : index
    %14 = arith.divui %13, %8 : index
    %15 = scf.for %arg4 = %c0 to %14 step %c1 iter_args(%arg5 = %4) -> (f32) {
      %22 = arith.muli %arg4, %8 : index
      %23 = arith.addi %22, %10 : index
      %24 = memref.load %arg0[%23] : memref<?xf32>
      %25 = arith.addf %arg5, %24 : f32
      scf.yield %25 : f32
    }
    %16 = memref.get_global @sdata : memref<1xf32>
    memref.store %15, %16[%0] : memref<1xf32>
    nvvm.barrier0
    %17 = arith.index_cast %8 : index to i32
    %18 = arith.cmpi uge, %17, %c512_i32 : i32
    scf.if %18 {
      %22 = arith.cmpi ult, %1, %c256_i32 : i32
      scf.if %22 {
        %23 = arith.addi %0, %c256 : index
        %24 = memref.load %16[%23] : memref<1xf32>
        %25 = memref.load %16[%0] : memref<1xf32>
        %26 = arith.addf %25, %24 : f32
        memref.store %26, %16[%0] : memref<1xf32>
      }
      nvvm.barrier0
    }
    %19 = arith.cmpi uge, %17, %c256_i32 : i32
    scf.if %19 {
      %22 = arith.cmpi ult, %1, %c128_i32 : i32
      scf.if %22 {
        %23 = arith.addi %0, %c128 : index
        %24 = memref.load %16[%23] : memref<1xf32>
        %25 = memref.load %16[%0] : memref<1xf32>
        %26 = arith.addf %25, %24 : f32
        memref.store %26, %16[%0] : memref<1xf32>
      }
      nvvm.barrier0
    }
    %20 = arith.cmpi uge, %17, %c128_i32 : i32
    scf.if %20 {
      %22 = arith.cmpi ult, %1, %c64_i32 : i32
      scf.if %22 {
        %23 = arith.addi %0, %c64 : index
        %24 = memref.load %16[%23] : memref<1xf32>
        %25 = memref.load %16[%0] : memref<1xf32>
        %26 = arith.addf %25, %24 : f32
        memref.store %26, %16[%0] : memref<1xf32>
      }
      nvvm.barrier0
    }
    %21 = arith.cmpi ult, %1, %c32_i32 : i32
    scf.if %21 {
      %22 = arith.addi %0, %c32 : index
      %23 = memref.load %16[%22] : memref<1xf32>
      %24 = memref.load %16[%0] : memref<1xf32>
      %25 = arith.addf %24, %23 : f32
      memref.store %25, %16[%0] : memref<1xf32>
      %26 = arith.addi %0, %c16 : index
      %27 = memref.load %16[%26] : memref<1xf32>
      %28 = arith.addf %25, %27 : f32
      memref.store %28, %16[%0] : memref<1xf32>
      %29 = arith.addi %0, %c8 : index
      %30 = memref.load %16[%29] : memref<1xf32>
      %31 = arith.addf %28, %30 : f32
      memref.store %31, %16[%0] : memref<1xf32>
      %32 = arith.addi %0, %c4 : index
      %33 = memref.load %16[%32] : memref<1xf32>
      %34 = arith.addf %31, %33 : f32
      memref.store %34, %16[%0] : memref<1xf32>
      %35 = arith.addi %0, %c2 : index
      %36 = memref.load %16[%35] : memref<1xf32>
      %37 = arith.addf %34, %36 : f32
      memref.store %37, %16[%0] : memref<1xf32>
      %38 = arith.addi %0, %c1 : index
      %39 = memref.load %16[%38] : memref<1xf32>
      %40 = arith.addf %37, %39 : f32
      memref.store %40, %16[%0] : memref<1xf32>
    }
    scf.if %2 {
      %22 = memref.load %16[%c0] : memref<1xf32>
      %23 = arith.mulf %22, %arg3 : f32
      memref.store %23, %arg1[%c0] : memref<?xf32>
    }
    return
  }
  func.func private @_ZN6float4C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): before execute: end
WrapAndReplaceBarrierPass::runOnOperation(): after execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @sdata : memref<1xf32>
  func.func @_Z20kl_div_kernel_stage1PKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %c4 = arith.constant 4 : index
      %c8 = arith.constant 8 : index
      %c16 = arith.constant 16 : index
      %c32_0 = arith.constant 32 : index
      %c64 = arith.constant 64 : index
      %c128 = arith.constant 128 : index
      %c256 = arith.constant 256 : index
      %c2 = arith.constant 2 : index
      %c0_1 = arith.constant 0 : index
      %c1_2 = arith.constant 1 : index
      %c32_i32 = arith.constant 32 : i32
      %c64_i32 = arith.constant 64 : i32
      %c128_i32 = arith.constant 128 : i32
      %c256_i32 = arith.constant 256 : i32
      %c512_i32 = arith.constant 512 : i32
      %c4_i32 = arith.constant 4 : i32
      %c0_i32 = arith.constant 0 : i32
      %c7_i32 = arith.constant 7 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c8_i32 = arith.constant 8 : i32
      %alloca_3 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %cast = memref.cast %alloca_3 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %alloca_4 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %cast_5 = memref.cast %alloca_4 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %0 = arith.index_cast %arg4 : index to i32
      %1 = arith.cmpi eq, %0, %c0_i32 : i32
      %2 = gpu.block_id  x
      %3 = arith.index_cast %2 : index to i32
      %4 = gpu.block_dim  x
      %5 = arith.index_cast %4 : index to i32
      %6 = arith.muli %3, %5 : i32
      %7 = arith.muli %6, %c8_i32 : i32
      %8 = arith.addi %7, %0 : i32
      %9 = gpu.grid_dim  x
      %10 = arith.index_cast %9 : index to i32
      %11 = arith.muli %5, %10 : i32
      %12 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %13 = "polygeist.pointer2memref"(%12) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %14 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %15 = "polygeist.pointer2memref"(%14) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %16 = arith.muli %5, %c7_i32 : i32
      %17 = arith.addi %8, %16 : i32
      %18:4 = scf.while (%arg5 = %cst, %arg6 = %17) : (f32, i32) -> (f32, i32, f32, i32) {
        %31 = arith.subi %arg6, %16 : i32
        %32 = arith.cmpi ult, %arg6, %arg3 : i32
        %33:4 = scf.if %32 -> (f32, i32, f32, i32) {
          %34 = "polygeist.memref2pointer"(%alloca_4) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %35 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %36 = llvm.getelementptr %34[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %37 = llvm.getelementptr %35[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %38 = llvm.getelementptr %34[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %39 = llvm.getelementptr %35[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %40 = llvm.getelementptr %34[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %41 = llvm.getelementptr %35[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %42 = scf.for %arg7 = %c0_1 to %c2 step %c1_2 iter_args(%arg8 = %arg5) -> (f32) {
            %47 = arith.index_cast %arg7 : index to i32
            %48 = arith.muli %47, %c4_i32 : i32
            %49 = arith.muli %48, %5 : i32
            %50 = arith.addi %31, %49 : i32
            %51 = arith.divui %50, %c4_i32 : i32
            %52 = arith.index_cast %51 : i32 to index
            %53 = "polygeist.subindex"(%13, %52) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            func.call @_ZN6float4C1ERKS_(%cast_5, %53) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %54 = "polygeist.subindex"(%15, %52) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            func.call @_ZN6float4C1ERKS_(%cast, %54) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %55 = llvm.load %34 : !llvm.ptr -> f32
            %56 = math.exp %55 : f32
            %57 = llvm.load %35 : !llvm.ptr -> f32
            %58 = arith.mulf %57, %55 : f32
            %59 = arith.subf %56, %58 : f32
            %60 = arith.addf %arg8, %59 : f32
            %61 = llvm.load %36 : !llvm.ptr -> f32
            %62 = math.exp %61 : f32
            %63 = llvm.load %37 : !llvm.ptr -> f32
            %64 = arith.mulf %63, %61 : f32
            %65 = arith.subf %62, %64 : f32
            %66 = arith.addf %60, %65 : f32
            %67 = llvm.load %38 : !llvm.ptr -> f32
            %68 = math.exp %67 : f32
            %69 = llvm.load %39 : !llvm.ptr -> f32
            %70 = arith.mulf %69, %67 : f32
            %71 = arith.subf %68, %70 : f32
            %72 = arith.addf %66, %71 : f32
            %73 = llvm.load %40 : !llvm.ptr -> f32
            %74 = math.exp %73 : f32
            %75 = llvm.load %41 : !llvm.ptr -> f32
            %76 = arith.mulf %75, %73 : f32
            %77 = arith.subf %74, %76 : f32
            %78 = arith.addf %72, %77 : f32
            scf.yield %78 : f32
          }
          %43 = arith.muli %11, %c8_i32 : i32
          %44 = arith.addi %31, %43 : i32
          %45 = llvm.mlir.undef : f32
          %46 = llvm.mlir.undef : i32
          scf.yield %42, %44, %45, %46 : f32, i32, f32, i32
        } else {
          scf.yield %arg5, %31, %arg5, %31 : f32, i32, f32, i32
        }
        scf.condition(%32) %33#0, %33#1, %33#2, %33#3 : f32, i32, f32, i32
      } do {
      ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
        %31 = arith.addi %arg6, %16 : i32
        scf.yield %arg5, %31 : f32, i32
      }
      %19 = arith.index_cast %arg3 : i32 to index
      %20 = arith.index_cast %18#3 : i32 to index
      %21 = arith.index_cast %11 : i32 to index
      %22 = arith.subi %19, %20 : index
      %23 = arith.subi %21, %c1_2 : index
      %24 = arith.addi %23, %22 : index
      %25 = arith.divui %24, %21 : index
      %26 = scf.for %arg5 = %c0_1 to %25 step %c1_2 iter_args(%arg6 = %18#2) -> (f32) {
        %31 = arith.muli %arg5, %21 : index
        %32 = arith.addi %31, %20 : index
        %33 = memref.load %arg0[%32] : memref<?xf32>
        %34 = memref.load %arg1[%32] : memref<?xf32>
        %35 = math.exp %33 : f32
        %36 = arith.mulf %34, %33 : f32
        %37 = arith.subf %35, %36 : f32
        %38 = arith.addf %arg6, %37 : f32
        scf.yield %38 : f32
      }
      memref.store %26, %alloca[%arg4] : memref<1xf32, 5>
      "polygeist.barrier"(%arg4) : (index) -> ()
      %27 = arith.cmpi uge, %5, %c512_i32 : i32
      scf.if %27 {
        %31 = arith.cmpi ult, %0, %c256_i32 : i32
        scf.if %31 {
          %32 = arith.addi %arg4, %c256 : index
          %33 = memref.load %alloca[%32] : memref<1xf32, 5>
          %34 = memref.load %alloca[%arg4] : memref<1xf32, 5>
          %35 = arith.addf %34, %33 : f32
          memref.store %35, %alloca[%arg4] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %28 = arith.cmpi uge, %5, %c256_i32 : i32
      scf.if %28 {
        %31 = arith.cmpi ult, %0, %c128_i32 : i32
        scf.if %31 {
          %32 = arith.addi %arg4, %c128 : index
          %33 = memref.load %alloca[%32] : memref<1xf32, 5>
          %34 = memref.load %alloca[%arg4] : memref<1xf32, 5>
          %35 = arith.addf %34, %33 : f32
          memref.store %35, %alloca[%arg4] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %29 = arith.cmpi uge, %5, %c128_i32 : i32
      scf.if %29 {
        %31 = arith.cmpi ult, %0, %c64_i32 : i32
        scf.if %31 {
          %32 = arith.addi %arg4, %c64 : index
          %33 = memref.load %alloca[%32] : memref<1xf32, 5>
          %34 = memref.load %alloca[%arg4] : memref<1xf32, 5>
          %35 = arith.addf %34, %33 : f32
          memref.store %35, %alloca[%arg4] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %30 = arith.cmpi ult, %0, %c32_i32 : i32
      scf.if %30 {
        %31 = arith.addi %arg4, %c32_0 : index
        %32 = memref.load %alloca[%31] : memref<1xf32, 5>
        %33 = memref.load %alloca[%arg4] : memref<1xf32, 5>
        %34 = arith.addf %33, %32 : f32
        memref.store %34, %alloca[%arg4] : memref<1xf32, 5>
        %35 = arith.addi %arg4, %c16 : index
        %36 = memref.load %alloca[%35] : memref<1xf32, 5>
        %37 = arith.addf %34, %36 : f32
        memref.store %37, %alloca[%arg4] : memref<1xf32, 5>
        %38 = arith.addi %arg4, %c8 : index
        %39 = memref.load %alloca[%38] : memref<1xf32, 5>
        %40 = arith.addf %37, %39 : f32
        memref.store %40, %alloca[%arg4] : memref<1xf32, 5>
        %41 = arith.addi %arg4, %c4 : index
        %42 = memref.load %alloca[%41] : memref<1xf32, 5>
        %43 = arith.addf %40, %42 : f32
        memref.store %43, %alloca[%arg4] : memref<1xf32, 5>
        %44 = arith.addi %arg4, %c2 : index
        %45 = memref.load %alloca[%44] : memref<1xf32, 5>
        %46 = arith.addf %43, %45 : f32
        memref.store %46, %alloca[%arg4] : memref<1xf32, 5>
        %47 = arith.addi %arg4, %c1_2 : index
        %48 = memref.load %alloca[%47] : memref<1xf32, 5>
        %49 = arith.addf %46, %48 : f32
        memref.store %49, %alloca[%arg4] : memref<1xf32, 5>
      }
      scf.if %1 {
        %31 = memref.load %alloca[%c0_1] : memref<1xf32, 5>
        memref.store %31, %arg2[%2] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z20kl_div_kernel_stage2PKfPfif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %c2 = arith.constant 2 : index
      %c4 = arith.constant 4 : index
      %c8 = arith.constant 8 : index
      %c16 = arith.constant 16 : index
      %c32_0 = arith.constant 32 : index
      %c64 = arith.constant 64 : index
      %c128 = arith.constant 128 : index
      %c256 = arith.constant 256 : index
      %c0_1 = arith.constant 0 : index
      %c1_2 = arith.constant 1 : index
      %c-3_i32 = arith.constant -3 : i32
      %c0_i32 = arith.constant 0 : i32
      %c32_i32 = arith.constant 32 : i32
      %c64_i32 = arith.constant 64 : i32
      %c128_i32 = arith.constant 128 : i32
      %c256_i32 = arith.constant 256 : i32
      %c512_i32 = arith.constant 512 : i32
      %c4_i32 = arith.constant 4 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %0 = arith.index_cast %arg4 : index to i32
      %1 = arith.cmpi eq, %0, %c0_i32 : i32
      %2 = arith.cmpi sge, %arg2, %c4_i32 : i32
      %3 = scf.if %2 -> (f32) {
        %21 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
        %22 = "polygeist.pointer2memref"(%21) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %23 = arith.muli %0, %c4_i32 : i32
        %24 = arith.addi %arg2, %c-3_i32 : i32
        %25 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %26 = llvm.getelementptr %25[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %27 = llvm.getelementptr %25[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %28 = llvm.getelementptr %25[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %29 = gpu.block_dim  x
        %30 = arith.index_cast %29 : index to i32
        %31 = arith.muli %30, %c4_i32 : i32
        %32 = arith.index_cast %24 : i32 to index
        %33 = arith.index_cast %23 : i32 to index
        %34 = arith.index_cast %31 : i32 to index
        %35 = scf.for %arg5 = %33 to %32 step %34 iter_args(%arg6 = %cst) -> (f32) {
          %36 = arith.subi %arg5, %33 : index
          %37 = arith.divui %36, %34 : index
          %38 = arith.muli %37, %34 : index
          %39 = arith.addi %33, %38 : index
          %40 = arith.index_cast %39 : index to i32
          %41 = arith.divsi %40, %c4_i32 : i32
          %42 = arith.index_cast %41 : i32 to index
          %43 = "polygeist.subindex"(%22, %42) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          func.call @_ZN6float4C1ERKS_(%cast, %43) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
          %44 = llvm.load %25 : !llvm.ptr -> f32
          %45 = llvm.load %26 : !llvm.ptr -> f32
          %46 = arith.addf %44, %45 : f32
          %47 = llvm.load %27 : !llvm.ptr -> f32
          %48 = arith.addf %46, %47 : f32
          %49 = llvm.load %28 : !llvm.ptr -> f32
          %50 = arith.addf %48, %49 : f32
          %51 = arith.addf %arg6, %50 : f32
          scf.yield %51 : f32
        }
        scf.yield %35 : f32
      } else {
        scf.yield %cst : f32
      }
      %4 = arith.divsi %arg2, %c4_i32 : i32
      %5 = arith.muli %4, %c4_i32 : i32
      %6 = arith.addi %0, %5 : i32
      %7 = gpu.block_dim  x
      %8 = arith.index_cast %arg2 : i32 to index
      %9 = arith.index_cast %6 : i32 to index
      %10 = arith.subi %8, %9 : index
      %11 = arith.subi %7, %c1_2 : index
      %12 = arith.addi %11, %10 : index
      %13 = arith.divui %12, %7 : index
      %14 = scf.for %arg5 = %c0_1 to %13 step %c1_2 iter_args(%arg6 = %3) -> (f32) {
        %21 = arith.muli %arg5, %7 : index
        %22 = arith.addi %21, %9 : index
        %23 = memref.load %arg0[%22] : memref<?xf32>
        %24 = arith.addf %arg6, %23 : f32
        scf.yield %24 : f32
      }
      %15 = memref.get_global @sdata : memref<1xf32>
      memref.store %14, %15[%arg4] : memref<1xf32>
      "polygeist.barrier"(%arg4) : (index) -> ()
      %16 = arith.index_cast %7 : index to i32
      %17 = arith.cmpi uge, %16, %c512_i32 : i32
      scf.if %17 {
        %21 = arith.cmpi ult, %0, %c256_i32 : i32
        scf.if %21 {
          %22 = arith.addi %arg4, %c256 : index
          %23 = memref.load %15[%22] : memref<1xf32>
          %24 = memref.load %15[%arg4] : memref<1xf32>
          %25 = arith.addf %24, %23 : f32
          memref.store %25, %15[%arg4] : memref<1xf32>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %18 = arith.cmpi uge, %16, %c256_i32 : i32
      scf.if %18 {
        %21 = arith.cmpi ult, %0, %c128_i32 : i32
        scf.if %21 {
          %22 = arith.addi %arg4, %c128 : index
          %23 = memref.load %15[%22] : memref<1xf32>
          %24 = memref.load %15[%arg4] : memref<1xf32>
          %25 = arith.addf %24, %23 : f32
          memref.store %25, %15[%arg4] : memref<1xf32>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %19 = arith.cmpi uge, %16, %c128_i32 : i32
      scf.if %19 {
        %21 = arith.cmpi ult, %0, %c64_i32 : i32
        scf.if %21 {
          %22 = arith.addi %arg4, %c64 : index
          %23 = memref.load %15[%22] : memref<1xf32>
          %24 = memref.load %15[%arg4] : memref<1xf32>
          %25 = arith.addf %24, %23 : f32
          memref.store %25, %15[%arg4] : memref<1xf32>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %20 = arith.cmpi ult, %0, %c32_i32 : i32
      scf.if %20 {
        %21 = arith.addi %arg4, %c32_0 : index
        %22 = memref.load %15[%21] : memref<1xf32>
        %23 = memref.load %15[%arg4] : memref<1xf32>
        %24 = arith.addf %23, %22 : f32
        memref.store %24, %15[%arg4] : memref<1xf32>
        %25 = arith.addi %arg4, %c16 : index
        %26 = memref.load %15[%25] : memref<1xf32>
        %27 = arith.addf %24, %26 : f32
        memref.store %27, %15[%arg4] : memref<1xf32>
        %28 = arith.addi %arg4, %c8 : index
        %29 = memref.load %15[%28] : memref<1xf32>
        %30 = arith.addf %27, %29 : f32
        memref.store %30, %15[%arg4] : memref<1xf32>
        %31 = arith.addi %arg4, %c4 : index
        %32 = memref.load %15[%31] : memref<1xf32>
        %33 = arith.addf %30, %32 : f32
        memref.store %33, %15[%arg4] : memref<1xf32>
        %34 = arith.addi %arg4, %c2 : index
        %35 = memref.load %15[%34] : memref<1xf32>
        %36 = arith.addf %33, %35 : f32
        memref.store %36, %15[%arg4] : memref<1xf32>
        %37 = arith.addi %arg4, %c1_2 : index
        %38 = memref.load %15[%37] : memref<1xf32>
        %39 = arith.addf %36, %38 : f32
        memref.store %39, %15[%arg4] : memref<1xf32>
      }
      scf.if %1 {
        %21 = memref.load %15[%c0_1] : memref<1xf32>
        %22 = arith.mulf %21, %arg3 : f32
        memref.store %22, %arg1[%c0_1] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func private @_ZN6float4C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
}
WrapAndReplaceBarrierPass::runOnOperation(): after execute: end
[ict-debug] driver.cc: After return 7, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @sdata : memref<1xf32>
  func.func @_Z20kl_div_kernel_stage1PKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %c4 = arith.constant 4 : index
      %c8 = arith.constant 8 : index
      %c16 = arith.constant 16 : index
      %c32_0 = arith.constant 32 : index
      %c64 = arith.constant 64 : index
      %c128 = arith.constant 128 : index
      %c256 = arith.constant 256 : index
      %c2 = arith.constant 2 : index
      %c0_1 = arith.constant 0 : index
      %c1_2 = arith.constant 1 : index
      %c32_i32 = arith.constant 32 : i32
      %c64_i32 = arith.constant 64 : i32
      %c128_i32 = arith.constant 128 : i32
      %c256_i32 = arith.constant 256 : i32
      %c512_i32 = arith.constant 512 : i32
      %c4_i32 = arith.constant 4 : i32
      %c0_i32 = arith.constant 0 : i32
      %c7_i32 = arith.constant 7 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c8_i32 = arith.constant 8 : i32
      %alloca_3 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %cast = memref.cast %alloca_3 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %alloca_4 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %cast_5 = memref.cast %alloca_4 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %0 = arith.index_cast %arg4 : index to i32
      %1 = arith.cmpi eq, %0, %c0_i32 : i32
      %2 = gpu.block_id  x
      %3 = arith.index_cast %2 : index to i32
      %4 = gpu.block_dim  x
      %5 = arith.index_cast %4 : index to i32
      %6 = arith.muli %3, %5 : i32
      %7 = arith.muli %6, %c8_i32 : i32
      %8 = arith.addi %7, %0 : i32
      %9 = gpu.grid_dim  x
      %10 = arith.index_cast %9 : index to i32
      %11 = arith.muli %5, %10 : i32
      %12 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %13 = "polygeist.pointer2memref"(%12) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %14 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %15 = "polygeist.pointer2memref"(%14) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %16 = arith.muli %5, %c7_i32 : i32
      %17 = arith.addi %8, %16 : i32
      %18:4 = scf.while (%arg5 = %cst, %arg6 = %17) : (f32, i32) -> (f32, i32, f32, i32) {
        %31 = arith.subi %arg6, %16 : i32
        %32 = arith.cmpi ult, %arg6, %arg3 : i32
        %33:4 = scf.if %32 -> (f32, i32, f32, i32) {
          %34 = "polygeist.memref2pointer"(%alloca_4) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %35 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %36 = llvm.getelementptr %34[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %37 = llvm.getelementptr %35[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %38 = llvm.getelementptr %34[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %39 = llvm.getelementptr %35[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %40 = llvm.getelementptr %34[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %41 = llvm.getelementptr %35[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %42 = scf.for %arg7 = %c0_1 to %c2 step %c1_2 iter_args(%arg8 = %arg5) -> (f32) {
            %47 = arith.index_cast %arg7 : index to i32
            %48 = arith.muli %47, %c4_i32 : i32
            %49 = arith.muli %48, %5 : i32
            %50 = arith.addi %31, %49 : i32
            %51 = arith.divui %50, %c4_i32 : i32
            %52 = arith.index_cast %51 : i32 to index
            %53 = "polygeist.subindex"(%13, %52) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            func.call @_ZN6float4C1ERKS_(%cast_5, %53) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %54 = "polygeist.subindex"(%15, %52) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            func.call @_ZN6float4C1ERKS_(%cast, %54) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %55 = llvm.load %34 : !llvm.ptr -> f32
            %56 = math.exp %55 : f32
            %57 = llvm.load %35 : !llvm.ptr -> f32
            %58 = arith.mulf %57, %55 : f32
            %59 = arith.subf %56, %58 : f32
            %60 = arith.addf %arg8, %59 : f32
            %61 = llvm.load %36 : !llvm.ptr -> f32
            %62 = math.exp %61 : f32
            %63 = llvm.load %37 : !llvm.ptr -> f32
            %64 = arith.mulf %63, %61 : f32
            %65 = arith.subf %62, %64 : f32
            %66 = arith.addf %60, %65 : f32
            %67 = llvm.load %38 : !llvm.ptr -> f32
            %68 = math.exp %67 : f32
            %69 = llvm.load %39 : !llvm.ptr -> f32
            %70 = arith.mulf %69, %67 : f32
            %71 = arith.subf %68, %70 : f32
            %72 = arith.addf %66, %71 : f32
            %73 = llvm.load %40 : !llvm.ptr -> f32
            %74 = math.exp %73 : f32
            %75 = llvm.load %41 : !llvm.ptr -> f32
            %76 = arith.mulf %75, %73 : f32
            %77 = arith.subf %74, %76 : f32
            %78 = arith.addf %72, %77 : f32
            scf.yield %78 : f32
          }
          %43 = arith.muli %11, %c8_i32 : i32
          %44 = arith.addi %31, %43 : i32
          %45 = llvm.mlir.undef : f32
          %46 = llvm.mlir.undef : i32
          scf.yield %42, %44, %45, %46 : f32, i32, f32, i32
        } else {
          scf.yield %arg5, %31, %arg5, %31 : f32, i32, f32, i32
        }
        scf.condition(%32) %33#0, %33#1, %33#2, %33#3 : f32, i32, f32, i32
      } do {
      ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
        %31 = arith.addi %arg6, %16 : i32
        scf.yield %arg5, %31 : f32, i32
      }
      %19 = arith.index_cast %arg3 : i32 to index
      %20 = arith.index_cast %18#3 : i32 to index
      %21 = arith.index_cast %11 : i32 to index
      %22 = arith.subi %19, %20 : index
      %23 = arith.subi %21, %c1_2 : index
      %24 = arith.addi %23, %22 : index
      %25 = arith.divui %24, %21 : index
      %26 = scf.for %arg5 = %c0_1 to %25 step %c1_2 iter_args(%arg6 = %18#2) -> (f32) {
        %31 = arith.muli %arg5, %21 : index
        %32 = arith.addi %31, %20 : index
        %33 = memref.load %arg0[%32] : memref<?xf32>
        %34 = memref.load %arg1[%32] : memref<?xf32>
        %35 = math.exp %33 : f32
        %36 = arith.mulf %34, %33 : f32
        %37 = arith.subf %35, %36 : f32
        %38 = arith.addf %arg6, %37 : f32
        scf.yield %38 : f32
      }
      memref.store %26, %alloca[%arg4] : memref<1xf32, 5>
      "polygeist.barrier"(%arg4) : (index) -> ()
      %27 = arith.cmpi uge, %5, %c512_i32 : i32
      scf.if %27 {
        %31 = arith.cmpi ult, %0, %c256_i32 : i32
        scf.if %31 {
          %32 = arith.addi %arg4, %c256 : index
          %33 = memref.load %alloca[%32] : memref<1xf32, 5>
          %34 = memref.load %alloca[%arg4] : memref<1xf32, 5>
          %35 = arith.addf %34, %33 : f32
          memref.store %35, %alloca[%arg4] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %28 = arith.cmpi uge, %5, %c256_i32 : i32
      scf.if %28 {
        %31 = arith.cmpi ult, %0, %c128_i32 : i32
        scf.if %31 {
          %32 = arith.addi %arg4, %c128 : index
          %33 = memref.load %alloca[%32] : memref<1xf32, 5>
          %34 = memref.load %alloca[%arg4] : memref<1xf32, 5>
          %35 = arith.addf %34, %33 : f32
          memref.store %35, %alloca[%arg4] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %29 = arith.cmpi uge, %5, %c128_i32 : i32
      scf.if %29 {
        %31 = arith.cmpi ult, %0, %c64_i32 : i32
        scf.if %31 {
          %32 = arith.addi %arg4, %c64 : index
          %33 = memref.load %alloca[%32] : memref<1xf32, 5>
          %34 = memref.load %alloca[%arg4] : memref<1xf32, 5>
          %35 = arith.addf %34, %33 : f32
          memref.store %35, %alloca[%arg4] : memref<1xf32, 5>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %30 = arith.cmpi ult, %0, %c32_i32 : i32
      scf.if %30 {
        %31 = arith.addi %arg4, %c32_0 : index
        %32 = memref.load %alloca[%31] : memref<1xf32, 5>
        %33 = memref.load %alloca[%arg4] : memref<1xf32, 5>
        %34 = arith.addf %33, %32 : f32
        memref.store %34, %alloca[%arg4] : memref<1xf32, 5>
        %35 = arith.addi %arg4, %c16 : index
        %36 = memref.load %alloca[%35] : memref<1xf32, 5>
        %37 = arith.addf %34, %36 : f32
        memref.store %37, %alloca[%arg4] : memref<1xf32, 5>
        %38 = arith.addi %arg4, %c8 : index
        %39 = memref.load %alloca[%38] : memref<1xf32, 5>
        %40 = arith.addf %37, %39 : f32
        memref.store %40, %alloca[%arg4] : memref<1xf32, 5>
        %41 = arith.addi %arg4, %c4 : index
        %42 = memref.load %alloca[%41] : memref<1xf32, 5>
        %43 = arith.addf %40, %42 : f32
        memref.store %43, %alloca[%arg4] : memref<1xf32, 5>
        %44 = arith.addi %arg4, %c2 : index
        %45 = memref.load %alloca[%44] : memref<1xf32, 5>
        %46 = arith.addf %43, %45 : f32
        memref.store %46, %alloca[%arg4] : memref<1xf32, 5>
        %47 = arith.addi %arg4, %c1_2 : index
        %48 = memref.load %alloca[%47] : memref<1xf32, 5>
        %49 = arith.addf %46, %48 : f32
        memref.store %49, %alloca[%arg4] : memref<1xf32, 5>
      }
      scf.if %1 {
        %31 = memref.load %alloca[%c0_1] : memref<1xf32, 5>
        memref.store %31, %arg2[%2] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z20kl_div_kernel_stage2PKfPfif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %c2 = arith.constant 2 : index
      %c4 = arith.constant 4 : index
      %c8 = arith.constant 8 : index
      %c16 = arith.constant 16 : index
      %c32_0 = arith.constant 32 : index
      %c64 = arith.constant 64 : index
      %c128 = arith.constant 128 : index
      %c256 = arith.constant 256 : index
      %c0_1 = arith.constant 0 : index
      %c1_2 = arith.constant 1 : index
      %c-3_i32 = arith.constant -3 : i32
      %c0_i32 = arith.constant 0 : i32
      %c32_i32 = arith.constant 32 : i32
      %c64_i32 = arith.constant 64 : i32
      %c128_i32 = arith.constant 128 : i32
      %c256_i32 = arith.constant 256 : i32
      %c512_i32 = arith.constant 512 : i32
      %c4_i32 = arith.constant 4 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %0 = arith.index_cast %arg4 : index to i32
      %1 = arith.cmpi eq, %0, %c0_i32 : i32
      %2 = arith.cmpi sge, %arg2, %c4_i32 : i32
      %3 = scf.if %2 -> (f32) {
        %21 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
        %22 = "polygeist.pointer2memref"(%21) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %23 = arith.muli %0, %c4_i32 : i32
        %24 = arith.addi %arg2, %c-3_i32 : i32
        %25 = "polygeist.memref2pointer"(%alloca) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %26 = llvm.getelementptr %25[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %27 = llvm.getelementptr %25[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %28 = llvm.getelementptr %25[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %29 = gpu.block_dim  x
        %30 = arith.index_cast %29 : index to i32
        %31 = arith.muli %30, %c4_i32 : i32
        %32 = arith.index_cast %24 : i32 to index
        %33 = arith.index_cast %23 : i32 to index
        %34 = arith.index_cast %31 : i32 to index
        %35 = scf.for %arg5 = %33 to %32 step %34 iter_args(%arg6 = %cst) -> (f32) {
          %36 = arith.subi %arg5, %33 : index
          %37 = arith.divui %36, %34 : index
          %38 = arith.muli %37, %34 : index
          %39 = arith.addi %33, %38 : index
          %40 = arith.index_cast %39 : index to i32
          %41 = arith.divsi %40, %c4_i32 : i32
          %42 = arith.index_cast %41 : i32 to index
          %43 = "polygeist.subindex"(%22, %42) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          func.call @_ZN6float4C1ERKS_(%cast, %43) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
          %44 = llvm.load %25 : !llvm.ptr -> f32
          %45 = llvm.load %26 : !llvm.ptr -> f32
          %46 = arith.addf %44, %45 : f32
          %47 = llvm.load %27 : !llvm.ptr -> f32
          %48 = arith.addf %46, %47 : f32
          %49 = llvm.load %28 : !llvm.ptr -> f32
          %50 = arith.addf %48, %49 : f32
          %51 = arith.addf %arg6, %50 : f32
          scf.yield %51 : f32
        }
        scf.yield %35 : f32
      } else {
        scf.yield %cst : f32
      }
      %4 = arith.divsi %arg2, %c4_i32 : i32
      %5 = arith.muli %4, %c4_i32 : i32
      %6 = arith.addi %0, %5 : i32
      %7 = gpu.block_dim  x
      %8 = arith.index_cast %arg2 : i32 to index
      %9 = arith.index_cast %6 : i32 to index
      %10 = arith.subi %8, %9 : index
      %11 = arith.subi %7, %c1_2 : index
      %12 = arith.addi %11, %10 : index
      %13 = arith.divui %12, %7 : index
      %14 = scf.for %arg5 = %c0_1 to %13 step %c1_2 iter_args(%arg6 = %3) -> (f32) {
        %21 = arith.muli %arg5, %7 : index
        %22 = arith.addi %21, %9 : index
        %23 = memref.load %arg0[%22] : memref<?xf32>
        %24 = arith.addf %arg6, %23 : f32
        scf.yield %24 : f32
      }
      %15 = memref.get_global @sdata : memref<1xf32>
      memref.store %14, %15[%arg4] : memref<1xf32>
      "polygeist.barrier"(%arg4) : (index) -> ()
      %16 = arith.index_cast %7 : index to i32
      %17 = arith.cmpi uge, %16, %c512_i32 : i32
      scf.if %17 {
        %21 = arith.cmpi ult, %0, %c256_i32 : i32
        scf.if %21 {
          %22 = arith.addi %arg4, %c256 : index
          %23 = memref.load %15[%22] : memref<1xf32>
          %24 = memref.load %15[%arg4] : memref<1xf32>
          %25 = arith.addf %24, %23 : f32
          memref.store %25, %15[%arg4] : memref<1xf32>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %18 = arith.cmpi uge, %16, %c256_i32 : i32
      scf.if %18 {
        %21 = arith.cmpi ult, %0, %c128_i32 : i32
        scf.if %21 {
          %22 = arith.addi %arg4, %c128 : index
          %23 = memref.load %15[%22] : memref<1xf32>
          %24 = memref.load %15[%arg4] : memref<1xf32>
          %25 = arith.addf %24, %23 : f32
          memref.store %25, %15[%arg4] : memref<1xf32>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %19 = arith.cmpi uge, %16, %c128_i32 : i32
      scf.if %19 {
        %21 = arith.cmpi ult, %0, %c64_i32 : i32
        scf.if %21 {
          %22 = arith.addi %arg4, %c64 : index
          %23 = memref.load %15[%22] : memref<1xf32>
          %24 = memref.load %15[%arg4] : memref<1xf32>
          %25 = arith.addf %24, %23 : f32
          memref.store %25, %15[%arg4] : memref<1xf32>
        }
        "polygeist.barrier"(%arg4) : (index) -> ()
      }
      %20 = arith.cmpi ult, %0, %c32_i32 : i32
      scf.if %20 {
        %21 = arith.addi %arg4, %c32_0 : index
        %22 = memref.load %15[%21] : memref<1xf32>
        %23 = memref.load %15[%arg4] : memref<1xf32>
        %24 = arith.addf %23, %22 : f32
        memref.store %24, %15[%arg4] : memref<1xf32>
        %25 = arith.addi %arg4, %c16 : index
        %26 = memref.load %15[%25] : memref<1xf32>
        %27 = arith.addf %24, %26 : f32
        memref.store %27, %15[%arg4] : memref<1xf32>
        %28 = arith.addi %arg4, %c8 : index
        %29 = memref.load %15[%28] : memref<1xf32>
        %30 = arith.addf %27, %29 : f32
        memref.store %30, %15[%arg4] : memref<1xf32>
        %31 = arith.addi %arg4, %c4 : index
        %32 = memref.load %15[%31] : memref<1xf32>
        %33 = arith.addf %30, %32 : f32
        memref.store %33, %15[%arg4] : memref<1xf32>
        %34 = arith.addi %arg4, %c2 : index
        %35 = memref.load %15[%34] : memref<1xf32>
        %36 = arith.addf %33, %35 : f32
        memref.store %36, %15[%arg4] : memref<1xf32>
        %37 = arith.addi %arg4, %c1_2 : index
        %38 = memref.load %15[%37] : memref<1xf32>
        %39 = arith.addf %36, %38 : f32
        memref.store %39, %15[%arg4] : memref<1xf32>
      }
      scf.if %1 {
        %21 = memref.load %15[%c0_1] : memref<1xf32>
        %22 = arith.mulf %21, %arg3 : f32
        memref.store %22, %arg1[%c0_1] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func private @_ZN6float4C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
}
[ict-debug] driver.cc: After return 7, module: end

[ict-debug] driver.cc: Before my pass process:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @sdata : memref<1xf32>
  func.func @_Z20kl_div_kernel_stage1PKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c8_i32 = arith.constant 8 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %c7_i32 = arith.constant 7 : i32
    %c0_i32 = arith.constant 0 : i32
    %c4_i32 = arith.constant 4 : i32
    %c512_i32 = arith.constant 512 : i32
    %c256_i32 = arith.constant 256 : i32
    %c128_i32 = arith.constant 128 : i32
    %c64_i32 = arith.constant 64 : i32
    %c32_i32 = arith.constant 32 : i32
    %c2 = arith.constant 2 : index
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c64 = arith.constant 64 : index
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c4 = arith.constant 4 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<1xf32, 5>
    %alloca_0 = memref.alloca() : memref<32xf32>
    %alloca_1 = memref.alloca() : memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_3 = memref.alloca() : memref<32xf32>
    %alloca_4 = memref.alloca() : memref<32xf32>
    %alloca_5 = memref.alloca() : memref<32xf32>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = gpu.block_dim  x
    %3 = arith.index_cast %2 : index to i32
    %4 = arith.muli %1, %3 : i32
    %5 = arith.muli %4, %c8_i32 : i32
    %6 = gpu.grid_dim  x
    %7 = arith.index_cast %6 : index to i32
    %8 = arith.muli %3, %7 : i32
    %9 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
    %10 = "polygeist.pointer2memref"(%9) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %11 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
    %12 = "polygeist.pointer2memref"(%11) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %13 = arith.muli %3, %c7_i32 : i32
    %14 = arith.index_cast %arg3 : i32 to index
    %15 = arith.index_cast %8 : i32 to index
    %16 = arith.subi %15, %c1 : index
    %17 = arith.muli %8, %c8_i32 : i32
    %18 = llvm.mlir.undef : f32
    %19 = llvm.mlir.undef : i32
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %30 = "polygeist.subindex"(%alloca_1, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %31 = "polygeist.subindex"(%alloca_2, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %32 = arith.index_cast %arg4 : index to i32
      %33 = arith.addi %5, %32 : i32
      %34 = arith.addi %33, %13 : i32
      %35:4 = scf.while (%arg5 = %cst, %arg6 = %34) : (f32, i32) -> (f32, i32, f32, i32) {
        %41 = arith.subi %arg6, %13 : i32
        %42 = arith.cmpi ult, %arg6, %arg3 : i32
        %43:4 = scf.if %42 -> (f32, i32, f32, i32) {
          %44 = "polygeist.subindex"(%alloca_2, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %45 = "polygeist.memref2pointer"(%44) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %46 = "polygeist.subindex"(%alloca_1, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %47 = "polygeist.memref2pointer"(%46) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %48 = llvm.getelementptr %45[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %49 = llvm.getelementptr %47[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %50 = llvm.getelementptr %45[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %51 = llvm.getelementptr %47[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %52 = llvm.getelementptr %45[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %53 = llvm.getelementptr %47[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %54 = scf.for %arg7 = %c0 to %c2 step %c1 iter_args(%arg8 = %arg5) -> (f32) {
            %56 = arith.index_cast %arg7 : index to i32
            %57 = arith.muli %56, %c4_i32 : i32
            %58 = arith.muli %57, %3 : i32
            %59 = arith.addi %41, %58 : i32
            %60 = arith.divui %59, %c4_i32 : i32
            %61 = arith.index_cast %60 : i32 to index
            %62 = "polygeist.subindex"(%10, %61) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            func.call @_ZN6float4C1ERKS_(%31, %62) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %63 = "polygeist.subindex"(%12, %61) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            func.call @_ZN6float4C1ERKS_(%30, %63) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %64 = llvm.load %45 : !llvm.ptr -> f32
            %65 = math.exp %64 : f32
            %66 = llvm.load %47 : !llvm.ptr -> f32
            %67 = arith.mulf %66, %64 : f32
            %68 = arith.subf %65, %67 : f32
            %69 = arith.addf %arg8, %68 : f32
            %70 = llvm.load %48 : !llvm.ptr -> f32
            %71 = math.exp %70 : f32
            %72 = llvm.load %49 : !llvm.ptr -> f32
            %73 = arith.mulf %72, %70 : f32
            %74 = arith.subf %71, %73 : f32
            %75 = arith.addf %69, %74 : f32
            %76 = llvm.load %50 : !llvm.ptr -> f32
            %77 = math.exp %76 : f32
            %78 = llvm.load %51 : !llvm.ptr -> f32
            %79 = arith.mulf %78, %76 : f32
            %80 = arith.subf %77, %79 : f32
            %81 = arith.addf %75, %80 : f32
            %82 = llvm.load %52 : !llvm.ptr -> f32
            %83 = math.exp %82 : f32
            %84 = llvm.load %53 : !llvm.ptr -> f32
            %85 = arith.mulf %84, %82 : f32
            %86 = arith.subf %83, %85 : f32
            %87 = arith.addf %81, %86 : f32
            scf.yield %87 : f32
          }
          %55 = arith.addi %41, %17 : i32
          scf.yield %54, %55, %18, %19 : f32, i32, f32, i32
        } else {
          scf.yield %arg5, %41, %arg5, %41 : f32, i32, f32, i32
        }
        scf.condition(%42) %43#0, %43#1, %43#2, %43#3 : f32, i32, f32, i32
      } do {
      ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
        %41 = arith.addi %arg6, %13 : i32
        scf.yield %arg5, %41 : f32, i32
      }
      %36 = arith.index_cast %35#3 : i32 to index
      %37 = arith.subi %14, %36 : index
      %38 = arith.addi %16, %37 : index
      %39 = arith.divui %38, %15 : index
      %40 = scf.for %arg5 = %c0 to %39 step %c1 iter_args(%arg6 = %35#2) -> (f32) {
        %41 = arith.muli %arg5, %15 : index
        %42 = arith.addi %41, %36 : index
        %43 = memref.load %arg0[%42] : memref<?xf32>
        %44 = memref.load %arg1[%42] : memref<?xf32>
        %45 = math.exp %43 : f32
        %46 = arith.mulf %44, %43 : f32
        %47 = arith.subf %45, %46 : f32
        %48 = arith.addf %arg6, %47 : f32
        scf.yield %48 : f32
      }
      memref.store %40, %alloca_0[%arg4] : memref<32xf32>
      memref.store %40, %alloca[%arg4] : memref<1xf32, 5>
      scf.yield
    }
    %20 = gpu.block_dim  x
    %21 = arith.index_cast %20 : index to i32
    %22 = arith.cmpi uge, %21, %c512_i32 : i32
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %30 = memref.load %alloca_0[%arg4] : memref<32xf32>
      %31 = arith.index_cast %arg4 : index to i32
      %32 = arith.cmpi ult, %31, %c256_i32 : i32
      %33 = arith.andi %22, %32 : i1
      %34 = scf.if %33 -> (f32) {
        %35 = arith.addi %arg4, %c256 : index
        %36 = memref.load %alloca[%35] : memref<1xf32, 5>
        %37 = arith.addf %30, %36 : f32
        memref.store %37, %alloca[%arg4] : memref<1xf32, 5>
        scf.yield %37 : f32
      } else {
        scf.yield %30 : f32
      }
      memref.store %34, %alloca_3[%arg4] : memref<32xf32>
      scf.yield
    }
    %23 = gpu.block_dim  x
    %24 = arith.index_cast %23 : index to i32
    %25 = arith.cmpi uge, %24, %c256_i32 : i32
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %30 = memref.load %alloca_3[%arg4] : memref<32xf32>
      %31 = arith.index_cast %arg4 : index to i32
      %32 = arith.cmpi ult, %31, %c128_i32 : i32
      %33 = arith.andi %25, %32 : i1
      %34 = scf.if %33 -> (f32) {
        %35 = arith.addi %arg4, %c128 : index
        %36 = memref.load %alloca[%35] : memref<1xf32, 5>
        %37 = arith.addf %30, %36 : f32
        memref.store %37, %alloca[%arg4] : memref<1xf32, 5>
        scf.yield %37 : f32
      } else {
        scf.yield %30 : f32
      }
      memref.store %34, %alloca_4[%arg4] : memref<32xf32>
      scf.yield
    }
    %26 = gpu.block_dim  x
    %27 = arith.index_cast %26 : index to i32
    %28 = arith.cmpi uge, %27, %c128_i32 : i32
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %30 = memref.load %alloca_4[%arg4] : memref<32xf32>
      %31 = arith.index_cast %arg4 : index to i32
      %32 = arith.cmpi ult, %31, %c64_i32 : i32
      %33 = arith.andi %28, %32 : i1
      %34 = scf.if %33 -> (f32) {
        %35 = arith.addi %arg4, %c64 : index
        %36 = memref.load %alloca[%35] : memref<1xf32, 5>
        %37 = arith.addf %30, %36 : f32
        memref.store %37, %alloca[%arg4] : memref<1xf32, 5>
        scf.yield %37 : f32
      } else {
        scf.yield %30 : f32
      }
      memref.store %34, %alloca_5[%arg4] : memref<32xf32>
      scf.yield
    }
    %29 = gpu.block_id  x
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %30 = memref.load %alloca_5[%arg4] : memref<32xf32>
      %31 = arith.index_cast %arg4 : index to i32
      %32 = arith.cmpi eq, %31, %c0_i32 : i32
      %33 = arith.cmpi ult, %31, %c32_i32 : i32
      scf.if %33 {
        %34 = arith.addi %arg4, %c32 : index
        %35 = memref.load %alloca[%34] : memref<1xf32, 5>
        %36 = arith.addf %30, %35 : f32
        memref.store %36, %alloca[%arg4] : memref<1xf32, 5>
        %37 = arith.addi %arg4, %c16 : index
        %38 = memref.load %alloca[%37] : memref<1xf32, 5>
        %39 = arith.addf %36, %38 : f32
        memref.store %39, %alloca[%arg4] : memref<1xf32, 5>
        %40 = arith.addi %arg4, %c8 : index
        %41 = memref.load %alloca[%40] : memref<1xf32, 5>
        %42 = arith.addf %39, %41 : f32
        memref.store %42, %alloca[%arg4] : memref<1xf32, 5>
        %43 = arith.addi %arg4, %c4 : index
        %44 = memref.load %alloca[%43] : memref<1xf32, 5>
        %45 = arith.addf %42, %44 : f32
        memref.store %45, %alloca[%arg4] : memref<1xf32, 5>
        %46 = arith.addi %arg4, %c2 : index
        %47 = memref.load %alloca[%46] : memref<1xf32, 5>
        %48 = arith.addf %45, %47 : f32
        memref.store %48, %alloca[%arg4] : memref<1xf32, 5>
        %49 = arith.addi %arg4, %c1 : index
        %50 = memref.load %alloca[%49] : memref<1xf32, 5>
        %51 = arith.addf %48, %50 : f32
        memref.store %51, %alloca[%arg4] : memref<1xf32, 5>
      }
      scf.if %32 {
        %34 = memref.load %alloca[%c0] : memref<1xf32, 5>
        memref.store %34, %arg2[%29] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func @_Z20kl_div_kernel_stage2PKfPfif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %cst = arith.constant 0.000000e+00 : f32
    %c4_i32 = arith.constant 4 : i32
    %c512_i32 = arith.constant 512 : i32
    %c256_i32 = arith.constant 256 : i32
    %c128_i32 = arith.constant 128 : i32
    %c64_i32 = arith.constant 64 : i32
    %c32_i32 = arith.constant 32 : i32
    %c0_i32 = arith.constant 0 : i32
    %c-3_i32 = arith.constant -3 : i32
    %c256 = arith.constant 256 : index
    %c128 = arith.constant 128 : index
    %c64 = arith.constant 64 : index
    %c16 = arith.constant 16 : index
    %c8 = arith.constant 8 : index
    %c4 = arith.constant 4 : index
    %c2 = arith.constant 2 : index
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c32 = arith.constant 32 : index
    %alloca = memref.alloca() : memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %0 = arith.cmpi sge, %arg2, %c4_i32 : i32
    %1 = arith.divsi %arg2, %c4_i32 : i32
    %2 = arith.muli %1, %c4_i32 : i32
    %3 = gpu.block_dim  x
    %4 = arith.index_cast %arg2 : i32 to index
    %5 = arith.subi %3, %c1 : index
    %6 = memref.get_global @sdata : memref<1xf32>
    %7 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
    %8 = "polygeist.pointer2memref"(%7) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %9 = arith.addi %arg2, %c-3_i32 : i32
    %10 = gpu.block_dim  x
    %11 = arith.index_cast %10 : index to i32
    %12 = arith.muli %11, %c4_i32 : i32
    %13 = arith.index_cast %9 : i32 to index
    %14 = arith.index_cast %12 : i32 to index
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %28 = "polygeist.subindex"(%alloca, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %29 = arith.index_cast %arg4 : index to i32
      %30 = scf.if %0 -> (f32) {
        %37 = arith.muli %29, %c4_i32 : i32
        %38 = "polygeist.subindex"(%alloca, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %39 = "polygeist.memref2pointer"(%38) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
        %40 = llvm.getelementptr %39[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %41 = llvm.getelementptr %39[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %42 = llvm.getelementptr %39[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        %43 = arith.index_cast %37 : i32 to index
        %44 = scf.for %arg5 = %43 to %13 step %14 iter_args(%arg6 = %cst) -> (f32) {
          %45 = arith.subi %arg5, %43 : index
          %46 = arith.divui %45, %14 : index
          %47 = arith.muli %46, %14 : index
          %48 = arith.addi %43, %47 : index
          %49 = arith.index_cast %48 : index to i32
          %50 = arith.divsi %49, %c4_i32 : i32
          %51 = arith.index_cast %50 : i32 to index
          %52 = "polygeist.subindex"(%8, %51) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          func.call @_ZN6float4C1ERKS_(%28, %52) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
          %53 = llvm.load %39 : !llvm.ptr -> f32
          %54 = llvm.load %40 : !llvm.ptr -> f32
          %55 = arith.addf %53, %54 : f32
          %56 = llvm.load %41 : !llvm.ptr -> f32
          %57 = arith.addf %55, %56 : f32
          %58 = llvm.load %42 : !llvm.ptr -> f32
          %59 = arith.addf %57, %58 : f32
          %60 = arith.addf %arg6, %59 : f32
          scf.yield %60 : f32
        }
        scf.yield %44 : f32
      } else {
        scf.yield %cst : f32
      }
      %31 = arith.addi %29, %2 : i32
      %32 = arith.index_cast %31 : i32 to index
      %33 = arith.subi %4, %32 : index
      %34 = arith.addi %5, %33 : index
      %35 = arith.divui %34, %3 : index
      %36 = scf.for %arg5 = %c0 to %35 step %c1 iter_args(%arg6 = %30) -> (f32) {
        %37 = arith.muli %arg5, %3 : index
        %38 = arith.addi %37, %32 : index
        %39 = memref.load %arg0[%38] : memref<?xf32>
        %40 = arith.addf %arg6, %39 : f32
        scf.yield %40 : f32
      }
      memref.store %36, %6[%arg4] : memref<1xf32>
      scf.yield
    }
    %15 = memref.get_global @sdata : memref<1xf32>
    %16 = gpu.block_dim  x
    %17 = arith.index_cast %16 : index to i32
    %18 = arith.cmpi uge, %17, %c512_i32 : i32
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %28 = arith.index_cast %arg4 : index to i32
      %29 = arith.cmpi ult, %28, %c256_i32 : i32
      %30 = arith.andi %18, %29 : i1
      scf.if %30 {
        %31 = arith.addi %arg4, %c256 : index
        %32 = memref.load %15[%31] : memref<1xf32>
        %33 = memref.load %15[%arg4] : memref<1xf32>
        %34 = arith.addf %33, %32 : f32
        memref.store %34, %15[%arg4] : memref<1xf32>
      }
      scf.yield
    }
    %19 = gpu.block_dim  x
    %20 = arith.index_cast %19 : index to i32
    %21 = memref.get_global @sdata : memref<1xf32>
    %22 = arith.cmpi uge, %20, %c256_i32 : i32
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %28 = arith.index_cast %arg4 : index to i32
      %29 = arith.cmpi ult, %28, %c128_i32 : i32
      %30 = arith.andi %22, %29 : i1
      scf.if %30 {
        %31 = arith.addi %arg4, %c128 : index
        %32 = memref.load %21[%31] : memref<1xf32>
        %33 = memref.load %21[%arg4] : memref<1xf32>
        %34 = arith.addf %33, %32 : f32
        memref.store %34, %21[%arg4] : memref<1xf32>
      }
      scf.yield
    }
    %23 = memref.get_global @sdata : memref<1xf32>
    %24 = gpu.block_dim  x
    %25 = arith.index_cast %24 : index to i32
    %26 = arith.cmpi uge, %25, %c128_i32 : i32
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %28 = arith.index_cast %arg4 : index to i32
      %29 = arith.cmpi ult, %28, %c64_i32 : i32
      %30 = arith.andi %26, %29 : i1
      scf.if %30 {
        %31 = arith.addi %arg4, %c64 : index
        %32 = memref.load %23[%31] : memref<1xf32>
        %33 = memref.load %23[%arg4] : memref<1xf32>
        %34 = arith.addf %33, %32 : f32
        memref.store %34, %23[%arg4] : memref<1xf32>
      }
      scf.yield
    }
    %27 = memref.get_global @sdata : memref<1xf32>
    scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
      %28 = arith.index_cast %arg4 : index to i32
      %29 = arith.cmpi eq, %28, %c0_i32 : i32
      %30 = arith.cmpi ult, %28, %c32_i32 : i32
      scf.if %30 {
        %31 = arith.addi %arg4, %c32 : index
        %32 = memref.load %27[%31] : memref<1xf32>
        %33 = memref.load %27[%arg4] : memref<1xf32>
        %34 = arith.addf %33, %32 : f32
        memref.store %34, %27[%arg4] : memref<1xf32>
        %35 = arith.addi %arg4, %c16 : index
        %36 = memref.load %27[%35] : memref<1xf32>
        %37 = arith.addf %34, %36 : f32
        memref.store %37, %27[%arg4] : memref<1xf32>
        %38 = arith.addi %arg4, %c8 : index
        %39 = memref.load %27[%38] : memref<1xf32>
        %40 = arith.addf %37, %39 : f32
        memref.store %40, %27[%arg4] : memref<1xf32>
        %41 = arith.addi %arg4, %c4 : index
        %42 = memref.load %27[%41] : memref<1xf32>
        %43 = arith.addf %40, %42 : f32
        memref.store %43, %27[%arg4] : memref<1xf32>
        %44 = arith.addi %arg4, %c2 : index
        %45 = memref.load %27[%44] : memref<1xf32>
        %46 = arith.addf %43, %45 : f32
        memref.store %46, %27[%arg4] : memref<1xf32>
        %47 = arith.addi %arg4, %c1 : index
        %48 = memref.load %27[%47] : memref<1xf32>
        %49 = arith.addf %46, %48 : f32
        memref.store %49, %27[%arg4] : memref<1xf32>
      }
      scf.if %29 {
        %31 = memref.load %27[%c0] : memref<1xf32>
        %32 = arith.mulf %31, %arg3 : f32
        memref.store %32, %arg1[%c0] : memref<?xf32>
      }
      scf.yield
    }
    return
  }
  func.func private @_ZN6float4C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
}
[ict-debug] driver.cc: Before my pass process: end

[ict-debug] driver.cc: vectorizeSize = 1

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  memref.global @sdata : memref<1xf32>
  gpu.module @_Z20kl_div_kernel_stage1PKfS0_Pfi_0 {
    gpu.func @_Z20kl_div_kernel_stage1PKfS0_Pfi(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32) {
      %c8_i32 = arith.constant 8 : i32
      %cst = arith.constant 0.000000e+00 : f32
      %c7_i32 = arith.constant 7 : i32
      %c0_i32 = arith.constant 0 : i32
      %c4_i32 = arith.constant 4 : i32
      %c512_i32 = arith.constant 512 : i32
      %c256_i32 = arith.constant 256 : i32
      %c128_i32 = arith.constant 128 : i32
      %c64_i32 = arith.constant 64 : i32
      %c32_i32 = arith.constant 32 : i32
      %c2 = arith.constant 2 : index
      %c256 = arith.constant 256 : index
      %c128 = arith.constant 128 : index
      %c64 = arith.constant 64 : index
      %c16 = arith.constant 16 : index
      %c8 = arith.constant 8 : index
      %c4 = arith.constant 4 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %alloca = memref.alloca() : memref<1xf32, 5>
      %alloca_0 = memref.alloca() : memref<32xf32>
      %alloca_1 = memref.alloca() : memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %alloca_2 = memref.alloca() : memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %alloca_3 = memref.alloca() : memref<32xf32>
      %alloca_4 = memref.alloca() : memref<32xf32>
      %alloca_5 = memref.alloca() : memref<32xf32>
      %0 = gpu.block_id  x
      %1 = arith.index_cast %0 : index to i32
      %2 = gpu.block_dim  x
      %3 = arith.index_cast %2 : index to i32
      %4 = arith.muli %1, %3 : i32
      %5 = arith.muli %4, %c8_i32 : i32
      %6 = gpu.grid_dim  x
      %7 = arith.index_cast %6 : index to i32
      %8 = arith.muli %3, %7 : i32
      %9 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %10 = "polygeist.pointer2memref"(%9) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %11 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %12 = "polygeist.pointer2memref"(%11) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %13 = arith.muli %3, %c7_i32 : i32
      %14 = arith.index_cast %arg3 : i32 to index
      %15 = arith.index_cast %8 : i32 to index
      %16 = arith.subi %15, %c1 : index
      %17 = arith.muli %8, %c8_i32 : i32
      %18 = llvm.mlir.undef : f32
      %19 = llvm.mlir.undef : i32
      scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
        %23 = "polygeist.subindex"(%alloca_1, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %24 = "polygeist.subindex"(%alloca_2, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %25 = arith.index_cast %arg4 : index to i32
        %26 = arith.addi %5, %25 : i32
        %27 = arith.addi %26, %13 : i32
        %28:4 = scf.while (%arg5 = %cst, %arg6 = %27) : (f32, i32) -> (f32, i32, f32, i32) {
          %34 = arith.subi %arg6, %13 : i32
          %35 = arith.cmpi ult, %arg6, %arg3 : i32
          %36 = arith.select %35, %18, %arg5 : f32
          %37 = arith.select %35, %19, %34 : i32
          %38:2 = scf.if %35 -> (f32, i32) {
            %39 = "polygeist.subindex"(%alloca_2, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %40 = "polygeist.memref2pointer"(%39) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %41 = "polygeist.subindex"(%alloca_1, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %42 = "polygeist.memref2pointer"(%41) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %43 = llvm.getelementptr %40[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
            %44 = llvm.getelementptr %42[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
            %45 = llvm.getelementptr %40[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
            %46 = llvm.getelementptr %42[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
            %47 = llvm.getelementptr %40[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
            %48 = llvm.getelementptr %42[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
            %49 = scf.for %arg7 = %c0 to %c2 step %c1 iter_args(%arg8 = %arg5) -> (f32) {
              %51 = arith.index_cast %arg7 : index to i32
              %52 = arith.muli %51, %c4_i32 : i32
              %53 = arith.muli %52, %3 : i32
              %54 = arith.addi %34, %53 : i32
              %55 = arith.divui %54, %c4_i32 : i32
              %56 = arith.index_cast %55 : i32 to index
              %57 = "polygeist.subindex"(%10, %56) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              func.call @_ZN6float4C1ERKS_(%24, %57) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %58 = "polygeist.subindex"(%12, %56) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              func.call @_ZN6float4C1ERKS_(%23, %58) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %59 = llvm.load %40 : !llvm.ptr -> f32
              %60 = math.exp %59 : f32
              %61 = llvm.load %42 : !llvm.ptr -> f32
              %62 = arith.mulf %61, %59 : f32
              %63 = arith.subf %60, %62 : f32
              %64 = arith.addf %arg8, %63 : f32
              %65 = llvm.load %43 : !llvm.ptr -> f32
              %66 = math.exp %65 : f32
              %67 = llvm.load %44 : !llvm.ptr -> f32
              %68 = arith.mulf %67, %65 : f32
              %69 = arith.subf %66, %68 : f32
              %70 = arith.addf %64, %69 : f32
              %71 = llvm.load %45 : !llvm.ptr -> f32
              %72 = math.exp %71 : f32
              %73 = llvm.load %46 : !llvm.ptr -> f32
              %74 = arith.mulf %73, %71 : f32
              %75 = arith.subf %72, %74 : f32
              %76 = arith.addf %70, %75 : f32
              %77 = llvm.load %47 : !llvm.ptr -> f32
              %78 = math.exp %77 : f32
              %79 = llvm.load %48 : !llvm.ptr -> f32
              %80 = arith.mulf %79, %77 : f32
              %81 = arith.subf %78, %80 : f32
              %82 = arith.addf %76, %81 : f32
              scf.yield %82 : f32
            }
            %50 = arith.addi %34, %17 : i32
            scf.yield %49, %50 : f32, i32
          } else {
            scf.yield %arg5, %34 : f32, i32
          }
          scf.condition(%35) %38#0, %38#1, %36, %37 : f32, i32, f32, i32
        } do {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %34 = arith.addi %arg6, %13 : i32
          scf.yield %arg5, %34 : f32, i32
        }
        %29 = arith.index_cast %28#3 : i32 to index
        %30 = arith.subi %14, %29 : index
        %31 = arith.addi %16, %30 : index
        %32 = arith.divui %31, %15 : index
        %33 = scf.for %arg5 = %c0 to %32 step %c1 iter_args(%arg6 = %28#2) -> (f32) {
          %34 = arith.muli %arg5, %15 : index
          %35 = arith.addi %34, %29 : index
          %36 = memref.load %arg0[%35] : memref<?xf32>
          %37 = memref.load %arg1[%35] : memref<?xf32>
          %38 = math.exp %36 : f32
          %39 = arith.mulf %37, %36 : f32
          %40 = arith.subf %38, %39 : f32
          %41 = arith.addf %arg6, %40 : f32
          scf.yield %41 : f32
        }
        memref.store %33, %alloca_0[%arg4] : memref<32xf32>
        memref.store %33, %alloca[%arg4] : memref<1xf32, 5>
        scf.yield
      }
      %20 = arith.cmpi uge, %3, %c512_i32 : i32
      scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_0[%arg4] : memref<32xf32>
        %24 = arith.index_cast %arg4 : index to i32
        %25 = arith.cmpi ult, %24, %c256_i32 : i32
        %26 = arith.andi %20, %25 : i1
        %27 = scf.if %26 -> (f32) {
          %28 = arith.addi %arg4, %c256 : index
          %29 = memref.load %alloca[%28] : memref<1xf32, 5>
          %30 = arith.addf %23, %29 : f32
          memref.store %30, %alloca[%arg4] : memref<1xf32, 5>
          scf.yield %30 : f32
        } else {
          scf.yield %23 : f32
        }
        memref.store %27, %alloca_3[%arg4] : memref<32xf32>
        scf.yield
      }
      %21 = arith.cmpi uge, %3, %c256_i32 : i32
      scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_3[%arg4] : memref<32xf32>
        %24 = arith.index_cast %arg4 : index to i32
        %25 = arith.cmpi ult, %24, %c128_i32 : i32
        %26 = arith.andi %21, %25 : i1
        %27 = scf.if %26 -> (f32) {
          %28 = arith.addi %arg4, %c128 : index
          %29 = memref.load %alloca[%28] : memref<1xf32, 5>
          %30 = arith.addf %23, %29 : f32
          memref.store %30, %alloca[%arg4] : memref<1xf32, 5>
          scf.yield %30 : f32
        } else {
          scf.yield %23 : f32
        }
        memref.store %27, %alloca_4[%arg4] : memref<32xf32>
        scf.yield
      }
      %22 = arith.cmpi uge, %3, %c128_i32 : i32
      scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_4[%arg4] : memref<32xf32>
        %24 = arith.index_cast %arg4 : index to i32
        %25 = arith.cmpi ult, %24, %c64_i32 : i32
        %26 = arith.andi %22, %25 : i1
        %27 = scf.if %26 -> (f32) {
          %28 = arith.addi %arg4, %c64 : index
          %29 = memref.load %alloca[%28] : memref<1xf32, 5>
          %30 = arith.addf %23, %29 : f32
          memref.store %30, %alloca[%arg4] : memref<1xf32, 5>
          scf.yield %30 : f32
        } else {
          scf.yield %23 : f32
        }
        memref.store %27, %alloca_5[%arg4] : memref<32xf32>
        scf.yield
      }
      scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
        %23 = memref.load %alloca_5[%arg4] : memref<32xf32>
        %24 = arith.index_cast %arg4 : index to i32
        %25 = arith.cmpi eq, %24, %c0_i32 : i32
        %26 = arith.cmpi ult, %24, %c32_i32 : i32
        scf.if %26 {
          %27 = arith.addi %arg4, %c32 : index
          %28 = memref.load %alloca[%27] : memref<1xf32, 5>
          %29 = arith.addf %23, %28 : f32
          memref.store %29, %alloca[%arg4] : memref<1xf32, 5>
          %30 = arith.addi %arg4, %c16 : index
          %31 = memref.load %alloca[%30] : memref<1xf32, 5>
          %32 = arith.addf %29, %31 : f32
          memref.store %32, %alloca[%arg4] : memref<1xf32, 5>
          %33 = arith.addi %arg4, %c8 : index
          %34 = memref.load %alloca[%33] : memref<1xf32, 5>
          %35 = arith.addf %32, %34 : f32
          memref.store %35, %alloca[%arg4] : memref<1xf32, 5>
          %36 = arith.addi %arg4, %c4 : index
          %37 = memref.load %alloca[%36] : memref<1xf32, 5>
          %38 = arith.addf %35, %37 : f32
          memref.store %38, %alloca[%arg4] : memref<1xf32, 5>
          %39 = arith.addi %arg4, %c2 : index
          %40 = memref.load %alloca[%39] : memref<1xf32, 5>
          %41 = arith.addf %38, %40 : f32
          memref.store %41, %alloca[%arg4] : memref<1xf32, 5>
          %42 = arith.addi %arg4, %c1 : index
          %43 = memref.load %alloca[%42] : memref<1xf32, 5>
          %44 = arith.addf %41, %43 : f32
          memref.store %44, %alloca[%arg4] : memref<1xf32, 5>
        }
        scf.if %25 {
          %27 = memref.load %alloca[%c0] : memref<1xf32, 5>
          memref.store %27, %arg2[%0] : memref<?xf32>
        }
        scf.yield
      }
      gpu.return
    }
    func.func private @_ZN6float4C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = llvm.load %0 : !llvm.ptr -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      llvm.store %1, %2 : f32, !llvm.ptr
      %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %4 = llvm.load %3 : !llvm.ptr -> f32
      %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      llvm.store %4, %5 : f32, !llvm.ptr
      %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %7 = llvm.load %6 : !llvm.ptr -> f32
      %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      llvm.store %7, %8 : f32, !llvm.ptr
      %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %10 = llvm.load %9 : !llvm.ptr -> f32
      %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      llvm.store %10, %11 : f32, !llvm.ptr
      return
    }
  }
  gpu.module @_Z20kl_div_kernel_stage2PKfPfif_1 {
    gpu.func @_Z20kl_div_kernel_stage2PKfPfif(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32) {
      %cst = arith.constant 0.000000e+00 : f32
      %c4_i32 = arith.constant 4 : i32
      %c512_i32 = arith.constant 512 : i32
      %c256_i32 = arith.constant 256 : i32
      %c128_i32 = arith.constant 128 : i32
      %c64_i32 = arith.constant 64 : i32
      %c32_i32 = arith.constant 32 : i32
      %c0_i32 = arith.constant 0 : i32
      %c-3_i32 = arith.constant -3 : i32
      %c256 = arith.constant 256 : index
      %c128 = arith.constant 128 : index
      %c64 = arith.constant 64 : index
      %c16 = arith.constant 16 : index
      %c8 = arith.constant 8 : index
      %c4 = arith.constant 4 : index
      %c2 = arith.constant 2 : index
      %c0 = arith.constant 0 : index
      %c1 = arith.constant 1 : index
      %c32 = arith.constant 32 : index
      %alloca = memref.alloca() : memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %0 = arith.cmpi sge, %arg2, %c4_i32 : i32
      %1 = arith.divsi %arg2, %c4_i32 : i32
      %2 = arith.muli %1, %c4_i32 : i32
      %3 = gpu.block_dim  x
      %4 = arith.index_cast %arg2 : i32 to index
      %5 = arith.subi %3, %c1 : index
      %6 = memref.get_global @sdata : memref<1xf32>
      %7 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %8 = "polygeist.pointer2memref"(%7) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %9 = arith.addi %arg2, %c-3_i32 : i32
      %10 = arith.index_cast %3 : index to i32
      %11 = arith.muli %10, %c4_i32 : i32
      %12 = arith.index_cast %9 : i32 to index
      %13 = arith.index_cast %11 : i32 to index
      scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
        %17 = "polygeist.subindex"(%alloca, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %18 = arith.index_cast %arg4 : index to i32
        %19 = scf.if %0 -> (f32) {
          %26 = arith.muli %18, %c4_i32 : i32
          %27 = "polygeist.subindex"(%alloca, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %28 = "polygeist.memref2pointer"(%27) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %29 = llvm.getelementptr %28[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %30 = llvm.getelementptr %28[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %31 = llvm.getelementptr %28[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
          %32 = arith.index_cast %26 : i32 to index
          %33 = scf.for %arg5 = %32 to %12 step %13 iter_args(%arg6 = %cst) -> (f32) {
            %34 = arith.subi %arg5, %32 : index
            %35 = arith.divui %34, %13 : index
            %36 = arith.muli %35, %13 : index
            %37 = arith.addi %32, %36 : index
            %38 = arith.index_cast %37 : index to i32
            %39 = arith.divsi %38, %c4_i32 : i32
            %40 = arith.index_cast %39 : i32 to index
            %41 = "polygeist.subindex"(%8, %40) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            func.call @_ZN6float4C1ERKS_(%17, %41) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %42 = llvm.load %28 : !llvm.ptr -> f32
            %43 = llvm.load %29 : !llvm.ptr -> f32
            %44 = arith.addf %42, %43 : f32
            %45 = llvm.load %30 : !llvm.ptr -> f32
            %46 = arith.addf %44, %45 : f32
            %47 = llvm.load %31 : !llvm.ptr -> f32
            %48 = arith.addf %46, %47 : f32
            %49 = arith.addf %arg6, %48 : f32
            scf.yield %49 : f32
          }
          scf.yield %33 : f32
        } else {
          scf.yield %cst : f32
        }
        %20 = arith.addi %18, %2 : i32
        %21 = arith.index_cast %20 : i32 to index
        %22 = arith.subi %4, %21 : index
        %23 = arith.addi %5, %22 : index
        %24 = arith.divui %23, %3 : index
        %25 = scf.for %arg5 = %c0 to %24 step %c1 iter_args(%arg6 = %19) -> (f32) {
          %26 = arith.muli %arg5, %3 : index
          %27 = arith.addi %26, %21 : index
          %28 = memref.load %arg0[%27] : memref<?xf32>
          %29 = arith.addf %arg6, %28 : f32
          scf.yield %29 : f32
        }
        memref.store %25, %6[%arg4] : memref<1xf32>
        scf.yield
      }
      %14 = arith.cmpi uge, %10, %c512_i32 : i32
      scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
        %17 = arith.index_cast %arg4 : index to i32
        %18 = arith.cmpi ult, %17, %c256_i32 : i32
        %19 = arith.andi %14, %18 : i1
        scf.if %19 {
          %20 = arith.addi %arg4, %c256 : index
          %21 = memref.load %6[%20] : memref<1xf32>
          %22 = memref.load %6[%arg4] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %6[%arg4] : memref<1xf32>
        }
        scf.yield
      }
      %15 = arith.cmpi uge, %10, %c256_i32 : i32
      scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
        %17 = arith.index_cast %arg4 : index to i32
        %18 = arith.cmpi ult, %17, %c128_i32 : i32
        %19 = arith.andi %15, %18 : i1
        scf.if %19 {
          %20 = arith.addi %arg4, %c128 : index
          %21 = memref.load %6[%20] : memref<1xf32>
          %22 = memref.load %6[%arg4] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %6[%arg4] : memref<1xf32>
        }
        scf.yield
      }
      %16 = arith.cmpi uge, %10, %c128_i32 : i32
      scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
        %17 = arith.index_cast %arg4 : index to i32
        %18 = arith.cmpi ult, %17, %c64_i32 : i32
        %19 = arith.andi %16, %18 : i1
        scf.if %19 {
          %20 = arith.addi %arg4, %c64 : index
          %21 = memref.load %6[%20] : memref<1xf32>
          %22 = memref.load %6[%arg4] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %6[%arg4] : memref<1xf32>
        }
        scf.yield
      }
      scf.parallel (%arg4) = (%c0) to (%c32) step (%c1) {
        %17 = arith.index_cast %arg4 : index to i32
        %18 = arith.cmpi eq, %17, %c0_i32 : i32
        %19 = arith.cmpi ult, %17, %c32_i32 : i32
        scf.if %19 {
          %20 = arith.addi %arg4, %c32 : index
          %21 = memref.load %6[%20] : memref<1xf32>
          %22 = memref.load %6[%arg4] : memref<1xf32>
          %23 = arith.addf %22, %21 : f32
          memref.store %23, %6[%arg4] : memref<1xf32>
          %24 = arith.addi %arg4, %c16 : index
          %25 = memref.load %6[%24] : memref<1xf32>
          %26 = arith.addf %23, %25 : f32
          memref.store %26, %6[%arg4] : memref<1xf32>
          %27 = arith.addi %arg4, %c8 : index
          %28 = memref.load %6[%27] : memref<1xf32>
          %29 = arith.addf %26, %28 : f32
          memref.store %29, %6[%arg4] : memref<1xf32>
          %30 = arith.addi %arg4, %c4 : index
          %31 = memref.load %6[%30] : memref<1xf32>
          %32 = arith.addf %29, %31 : f32
          memref.store %32, %6[%arg4] : memref<1xf32>
          %33 = arith.addi %arg4, %c2 : index
          %34 = memref.load %6[%33] : memref<1xf32>
          %35 = arith.addf %32, %34 : f32
          memref.store %35, %6[%arg4] : memref<1xf32>
          %36 = arith.addi %arg4, %c1 : index
          %37 = memref.load %6[%36] : memref<1xf32>
          %38 = arith.addf %35, %37 : f32
          memref.store %38, %6[%arg4] : memref<1xf32>
        }
        scf.if %18 {
          %20 = memref.load %6[%c0] : memref<1xf32>
          %21 = arith.mulf %20, %arg3 : f32
          memref.store %21, %arg1[%c0] : memref<?xf32>
        }
        scf.yield
      }
      gpu.return
    }
    memref.global @sdata : memref<1xf32>
    func.func private @_ZN6float4C1ERKS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = llvm.load %0 : !llvm.ptr -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      llvm.store %1, %2 : f32, !llvm.ptr
      %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %4 = llvm.load %3 : !llvm.ptr -> f32
      %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      llvm.store %4, %5 : f32, !llvm.ptr
      %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %7 = llvm.load %6 : !llvm.ptr -> f32
      %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      llvm.store %7, %8 : f32, !llvm.ptr
      %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %10 = llvm.load %9 : !llvm.ptr -> f32
      %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      llvm.store %10, %11 : f32, !llvm.ptr
      return
    }
  }
}
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): Before execute: end

[ict-debug] ConvertPolygeistToNPU:convertScfParallelToScfFor(): replace gpu.block_dim op with thread loop bound

[ict-debug] ConvertPolygeistToNPU:convertScfParallelToScfFor(): replace gpu.grid_dim with npu.block_num

[ict-debug] ConvertPolygeistToNPU:convertScfParallelToScfFor(): replace gpu.block_dim op with thread loop bound

[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize:

"builtin.module"() ({
  "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32):
      %0 = "arith.constant"() <{value = 8 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %2 = "arith.constant"() <{value = 7 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 2 : index}> : () -> index
      %11 = "arith.constant"() <{value = 256 : index}> : () -> index
      %12 = "arith.constant"() <{value = 128 : index}> : () -> index
      %13 = "arith.constant"() <{value = 64 : index}> : () -> index
      %14 = "arith.constant"() <{value = 16 : index}> : () -> index
      %15 = "arith.constant"() <{value = 8 : index}> : () -> index
      %16 = "arith.constant"() <{value = 4 : index}> : () -> index
      %17 = "arith.constant"() <{value = 0 : index}> : () -> index
      %18 = "arith.constant"() <{value = 1 : index}> : () -> index
      %19 = "arith.constant"() <{value = 32 : index}> : () -> index
      %20 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1xf32, 5>
      %21 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %22 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %23 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %24 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %25 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %26 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32>
      %27 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %28 = "arith.index_cast"(%27) : (index) -> i32
      %29 = "arith.constant"() <{value = 32 : index}> : () -> index
      %30 = "arith.index_cast"(%29) : (index) -> i32
      %31 = "arith.muli"(%28, %30) : (i32, i32) -> i32
      %32 = "arith.muli"(%31, %0) : (i32, i32) -> i32
      %33 = "npu.block_num"() : () -> i64
      %34 = "arith.index_cast"(%33) : (i64) -> i32
      %35 = "arith.muli"(%30, %34) : (i32, i32) -> i32
      %36 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %37 = "polygeist.pointer2memref"(%36) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %38 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %39 = "polygeist.pointer2memref"(%38) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %40 = "arith.muli"(%30, %2) : (i32, i32) -> i32
      %41 = "arith.index_cast"(%arg3) : (i32) -> index
      %42 = "arith.index_cast"(%35) : (i32) -> index
      %43 = "arith.subi"(%42, %18) : (index, index) -> index
      %44 = "arith.muli"(%35, %0) : (i32, i32) -> i32
      %45 = "llvm.mlir.undef"() : () -> f32
      %46 = "llvm.mlir.undef"() : () -> i32
      %47 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %47) ({
      ^bb0(%arg4: index):
        %55 = "polygeist.subindex"(%22, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %56 = "polygeist.subindex"(%23, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %57 = "arith.index_cast"(%arg4) : (index) -> i32
        %58 = "arith.addi"(%32, %57) : (i32, i32) -> i32
        %59 = "arith.addi"(%58, %40) : (i32, i32) -> i32
        %60:4 = "scf.while"(%1, %59) ({
        ^bb0(%arg5: f32, %arg6: i32):
          %66 = "arith.subi"(%arg6, %40) : (i32, i32) -> i32
          %67 = "arith.cmpi"(%arg6, %arg3) <{predicate = 6 : i64}> : (i32, i32) -> i1
          %68 = "arith.select"(%67, %45, %arg5) : (i1, f32, f32) -> f32
          %69 = "arith.select"(%67, %46, %66) : (i1, i32, i32) -> i32
          %70:2 = "scf.if"(%67) ({
            %71 = "polygeist.subindex"(%23, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %72 = "polygeist.memref2pointer"(%71) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %73 = "polygeist.subindex"(%22, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %74 = "polygeist.memref2pointer"(%73) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %75 = "llvm.getelementptr"(%72) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %76 = "llvm.getelementptr"(%74) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %77 = "llvm.getelementptr"(%72) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %78 = "llvm.getelementptr"(%74) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %79 = "llvm.getelementptr"(%72) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %80 = "llvm.getelementptr"(%74) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %81 = "scf.for"(%17, %10, %18, %arg5) ({
            ^bb0(%arg7: index, %arg8: f32):
              %83 = "arith.index_cast"(%arg7) : (index) -> i32
              %84 = "arith.muli"(%83, %4) : (i32, i32) -> i32
              %85 = "arith.muli"(%84, %30) : (i32, i32) -> i32
              %86 = "arith.addi"(%66, %85) : (i32, i32) -> i32
              %87 = "arith.divui"(%86, %4) : (i32, i32) -> i32
              %88 = "arith.index_cast"(%87) : (i32) -> index
              %89 = "polygeist.subindex"(%37, %88) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%56, %89) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %90 = "polygeist.subindex"(%39, %88) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%55, %90) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %91 = "llvm.load"(%72) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %92 = "math.exp"(%91) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %93 = "llvm.load"(%74) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %94 = "arith.mulf"(%93, %91) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %95 = "arith.subf"(%92, %94) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %96 = "arith.addf"(%arg8, %95) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %97 = "llvm.load"(%75) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %98 = "math.exp"(%97) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %99 = "llvm.load"(%76) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %100 = "arith.mulf"(%99, %97) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %101 = "arith.subf"(%98, %100) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %102 = "arith.addf"(%96, %101) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %103 = "llvm.load"(%77) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %104 = "math.exp"(%103) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %105 = "llvm.load"(%78) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %106 = "arith.mulf"(%105, %103) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %107 = "arith.subf"(%104, %106) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %108 = "arith.addf"(%102, %107) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %109 = "llvm.load"(%79) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %110 = "math.exp"(%109) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %111 = "llvm.load"(%80) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %112 = "arith.mulf"(%111, %109) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %113 = "arith.subf"(%110, %112) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %114 = "arith.addf"(%108, %113) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              "scf.yield"(%114) : (f32) -> ()
            }) : (index, index, index, f32) -> f32
            %82 = "arith.addi"(%66, %44) : (i32, i32) -> i32
            "scf.yield"(%81, %82) : (f32, i32) -> ()
          }, {
            "scf.yield"(%arg5, %66) : (f32, i32) -> ()
          }) : (i1) -> (f32, i32)
          "scf.condition"(%67, %70#0, %70#1, %68, %69) : (i1, f32, i32, f32, i32) -> ()
        }, {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %66 = "arith.addi"(%arg6, %40) : (i32, i32) -> i32
          "scf.yield"(%arg5, %66) : (f32, i32) -> ()
        }) : (f32, i32) -> (f32, i32, f32, i32)
        %61 = "arith.index_cast"(%60#3) : (i32) -> index
        %62 = "arith.subi"(%41, %61) : (index, index) -> index
        %63 = "arith.addi"(%43, %62) : (index, index) -> index
        %64 = "arith.divui"(%63, %42) : (index, index) -> index
        %65 = "scf.for"(%17, %64, %18, %60#2) ({
        ^bb0(%arg5: index, %arg6: f32):
          %66 = "arith.muli"(%arg5, %42) : (index, index) -> index
          %67 = "arith.addi"(%66, %61) : (index, index) -> index
          %68 = "memref.load"(%arg0, %67) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %69 = "memref.load"(%arg1, %67) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %70 = "math.exp"(%68) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          %71 = "arith.mulf"(%69, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %72 = "arith.subf"(%70, %71) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %73 = "arith.addf"(%arg6, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%73) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%65, %21, %arg4) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
        "memref.store"(%65, %20, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %48 = "arith.cmpi"(%30, %5) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %49 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %49) ({
      ^bb0(%arg4: index):
        %55 = "memref.load"(%21, %arg4) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        %56 = "arith.index_cast"(%arg4) : (index) -> i32
        %57 = "arith.cmpi"(%56, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %58 = "arith.andi"(%48, %57) : (i1, i1) -> i1
        %59 = "scf.if"(%58) ({
          %60 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %61 = "memref.load"(%20, %60) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %62 = "arith.addf"(%55, %61) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%62, %20, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%62) : (f32) -> ()
        }, {
          "scf.yield"(%55) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%59, %24, %arg4) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %50 = "arith.cmpi"(%30, %6) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %51 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %51) ({
      ^bb0(%arg4: index):
        %55 = "memref.load"(%24, %arg4) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        %56 = "arith.index_cast"(%arg4) : (index) -> i32
        %57 = "arith.cmpi"(%56, %7) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %58 = "arith.andi"(%50, %57) : (i1, i1) -> i1
        %59 = "scf.if"(%58) ({
          %60 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %61 = "memref.load"(%20, %60) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %62 = "arith.addf"(%55, %61) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%62, %20, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%62) : (f32) -> ()
        }, {
          "scf.yield"(%55) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%59, %25, %arg4) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %52 = "arith.cmpi"(%30, %7) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %53 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %53) ({
      ^bb0(%arg4: index):
        %55 = "memref.load"(%25, %arg4) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        %56 = "arith.index_cast"(%arg4) : (index) -> i32
        %57 = "arith.cmpi"(%56, %8) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %58 = "arith.andi"(%52, %57) : (i1, i1) -> i1
        %59 = "scf.if"(%58) ({
          %60 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %61 = "memref.load"(%20, %60) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %62 = "arith.addf"(%55, %61) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%62, %20, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%62) : (f32) -> ()
        }, {
          "scf.yield"(%55) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%59, %26, %arg4) <{nontemporal = false}> : (f32, memref<32xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %54 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %54) ({
      ^bb0(%arg4: index):
        %55 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<32xf32>, index) -> f32
        %56 = "arith.index_cast"(%arg4) : (index) -> i32
        %57 = "arith.cmpi"(%56, %3) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %58 = "arith.cmpi"(%56, %9) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%58) ({
          %59 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %60 = "memref.load"(%20, %59) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %61 = "arith.addf"(%55, %60) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%61, %20, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %62 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %63 = "memref.load"(%20, %62) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %64 = "arith.addf"(%61, %63) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%64, %20, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %65 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %66 = "memref.load"(%20, %65) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %67 = "arith.addf"(%64, %66) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%67, %20, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %68 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %69 = "memref.load"(%20, %68) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %70 = "arith.addf"(%67, %69) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%70, %20, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %71 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %72 = "memref.load"(%20, %71) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %73 = "arith.addf"(%70, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%73, %20, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %74 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %75 = "memref.load"(%20, %74) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %76 = "arith.addf"(%73, %75) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%76, %20, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%57) ({
          %59 = "memref.load"(%20, %17) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          "memref.store"(%59, %arg2, %27) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, f32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32):
      %0 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %1 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = -3 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 256 : index}> : () -> index
      %10 = "arith.constant"() <{value = 128 : index}> : () -> index
      %11 = "arith.constant"() <{value = 64 : index}> : () -> index
      %12 = "arith.constant"() <{value = 16 : index}> : () -> index
      %13 = "arith.constant"() <{value = 8 : index}> : () -> index
      %14 = "arith.constant"() <{value = 4 : index}> : () -> index
      %15 = "arith.constant"() <{value = 2 : index}> : () -> index
      %16 = "arith.constant"() <{value = 0 : index}> : () -> index
      %17 = "arith.constant"() <{value = 1 : index}> : () -> index
      %18 = "arith.constant"() <{value = 32 : index}> : () -> index
      %19 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %20 = "arith.cmpi"(%arg2, %1) <{predicate = 5 : i64}> : (i32, i32) -> i1
      %21 = "arith.divsi"(%arg2, %1) : (i32, i32) -> i32
      %22 = "arith.muli"(%21, %1) : (i32, i32) -> i32
      %23 = "arith.constant"() <{value = 32 : index}> : () -> index
      %24 = "arith.index_cast"(%arg2) : (i32) -> index
      %25 = "arith.subi"(%23, %17) : (index, index) -> index
      %26 = "memref.get_global"() <{name = @sdata}> : () -> memref<1xf32>
      %27 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %28 = "polygeist.pointer2memref"(%27) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %29 = "arith.addi"(%arg2, %8) : (i32, i32) -> i32
      %30 = "arith.index_cast"(%23) : (index) -> i32
      %31 = "arith.muli"(%30, %1) : (i32, i32) -> i32
      %32 = "arith.index_cast"(%29) : (i32) -> index
      %33 = "arith.index_cast"(%31) : (i32) -> index
      %34 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %34) ({
      ^bb0(%arg4: index):
        %42 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "scf.if"(%20) ({
          %51 = "arith.muli"(%43, %1) : (i32, i32) -> i32
          %52 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %53 = "polygeist.memref2pointer"(%52) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %54 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
          %55 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
          %56 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
          %57 = "arith.index_cast"(%51) : (i32) -> index
          %58 = "scf.for"(%57, %32, %33, %0) ({
          ^bb0(%arg5: index, %arg6: f32):
            %59 = "arith.subi"(%arg5, %57) : (index, index) -> index
            %60 = "arith.divui"(%59, %33) : (index, index) -> index
            %61 = "arith.muli"(%60, %33) : (index, index) -> index
            %62 = "arith.addi"(%57, %61) : (index, index) -> index
            %63 = "arith.index_cast"(%62) : (index) -> i32
            %64 = "arith.divsi"(%63, %1) : (i32, i32) -> i32
            %65 = "arith.index_cast"(%64) : (i32) -> index
            %66 = "polygeist.subindex"(%28, %65) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            "func.call"(%42, %66) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %67 = "llvm.load"(%53) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %68 = "llvm.load"(%54) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %69 = "arith.addf"(%67, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %70 = "llvm.load"(%55) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %71 = "arith.addf"(%69, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %72 = "llvm.load"(%56) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %73 = "arith.addf"(%71, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %74 = "arith.addf"(%arg6, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "scf.yield"(%74) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          "scf.yield"(%58) : (f32) -> ()
        }, {
          "scf.yield"(%0) : (f32) -> ()
        }) : (i1) -> f32
        %45 = "arith.addi"(%43, %22) : (i32, i32) -> i32
        %46 = "arith.index_cast"(%45) : (i32) -> index
        %47 = "arith.subi"(%24, %46) : (index, index) -> index
        %48 = "arith.addi"(%25, %47) : (index, index) -> index
        %49 = "arith.divui"(%48, %23) : (index, index) -> index
        %50 = "scf.for"(%16, %49, %17, %44) ({
        ^bb0(%arg5: index, %arg6: f32):
          %51 = "arith.muli"(%arg5, %23) : (index, index) -> index
          %52 = "arith.addi"(%51, %46) : (index, index) -> index
          %53 = "memref.load"(%arg0, %52) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %54 = "arith.addf"(%arg6, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%54) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%50, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %35 = "arith.cmpi"(%30, %2) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %36 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %36) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %3) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%35, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %9) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %37 = "arith.cmpi"(%30, %3) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %38 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %38) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %4) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%37, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %39 = "arith.cmpi"(%30, %4) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %40 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %40) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %5) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%39, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %41 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %41) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %7) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %44 = "arith.cmpi"(%42, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %49 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %50 = "memref.load"(%26, %49) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %51 = "arith.addf"(%48, %50) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%51, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %52 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %53 = "memref.load"(%26, %52) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %54 = "arith.addf"(%51, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%54, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %55 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %56 = "memref.load"(%26, %55) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %57 = "arith.addf"(%54, %56) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%57, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %58 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %59 = "memref.load"(%26, %58) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %60 = "arith.addf"(%57, %59) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%60, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %61 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %62 = "memref.load"(%26, %61) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %63 = "arith.addf"(%60, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%43) ({
          %45 = "memref.load"(%26, %16) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %46 = "arith.mulf"(%45, %arg3) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%46, %arg1, %16) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif_1"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After vectorize: end

[ict-debug] MemRefAllocaToNPULowering: process op: 

%20 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1xf32, 5>
[ict-debug] MemRefAllocaToNPULowering: memory space is 5

MemRefAllocaToNPULowering: newAllocaOp: 
%20 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
MemRefAllocaToNPULowering: old allocaOp: 
%21 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1xf32, 5>
MemRefAllocaToNPULowering: module: 
"builtin.module"() ({
  "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32):
      %0 = "arith.constant"() <{value = 8 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %2 = "arith.constant"() <{value = 7 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 2 : index}> : () -> index
      %11 = "arith.constant"() <{value = 256 : index}> : () -> index
      %12 = "arith.constant"() <{value = 128 : index}> : () -> index
      %13 = "arith.constant"() <{value = 64 : index}> : () -> index
      %14 = "arith.constant"() <{value = 16 : index}> : () -> index
      %15 = "arith.constant"() <{value = 8 : index}> : () -> index
      %16 = "arith.constant"() <{value = 4 : index}> : () -> index
      %17 = "arith.constant"() <{value = 0 : index}> : () -> index
      %18 = "arith.constant"() <{value = 1 : index}> : () -> index
      %19 = "arith.constant"() <{value = 32 : index}> : () -> index
      %20 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %21 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1xf32, 5>
      %22 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %23 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %24 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %25 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %26 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %27 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %28 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %29 = "arith.index_cast"(%28) : (index) -> i32
      %30 = "arith.constant"() <{value = 32 : index}> : () -> index
      %31 = "arith.index_cast"(%30) : (index) -> i32
      %32 = "arith.muli"(%29, %31) : (i32, i32) -> i32
      %33 = "arith.muli"(%32, %0) : (i32, i32) -> i32
      %34 = "npu.block_num"() : () -> i64
      %35 = "arith.index_cast"(%34) : (i64) -> i32
      %36 = "arith.muli"(%31, %35) : (i32, i32) -> i32
      %37 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %38 = "polygeist.pointer2memref"(%37) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %39 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %40 = "polygeist.pointer2memref"(%39) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %41 = "arith.muli"(%31, %2) : (i32, i32) -> i32
      %42 = "arith.index_cast"(%arg3) : (i32) -> index
      %43 = "arith.index_cast"(%36) : (i32) -> index
      %44 = "arith.subi"(%43, %18) : (index, index) -> index
      %45 = "arith.muli"(%36, %0) : (i32, i32) -> i32
      %46 = "llvm.mlir.undef"() : () -> f32
      %47 = "llvm.mlir.undef"() : () -> i32
      %48 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %48) ({
      ^bb0(%arg4: index):
        %56 = "polygeist.subindex"(%23, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %57 = "polygeist.subindex"(%24, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %58 = "arith.index_cast"(%arg4) : (index) -> i32
        %59 = "arith.addi"(%33, %58) : (i32, i32) -> i32
        %60 = "arith.addi"(%59, %41) : (i32, i32) -> i32
        %61:4 = "scf.while"(%1, %60) ({
        ^bb0(%arg5: f32, %arg6: i32):
          %67 = "arith.subi"(%arg6, %41) : (i32, i32) -> i32
          %68 = "arith.cmpi"(%arg6, %arg3) <{predicate = 6 : i64}> : (i32, i32) -> i1
          %69 = "arith.select"(%68, %46, %arg5) : (i1, f32, f32) -> f32
          %70 = "arith.select"(%68, %47, %67) : (i1, i32, i32) -> i32
          %71:2 = "scf.if"(%68) ({
            %72 = "polygeist.subindex"(%24, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %73 = "polygeist.memref2pointer"(%72) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %74 = "polygeist.subindex"(%23, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %75 = "polygeist.memref2pointer"(%74) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %76 = "llvm.getelementptr"(%73) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %77 = "llvm.getelementptr"(%75) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %78 = "llvm.getelementptr"(%73) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %79 = "llvm.getelementptr"(%75) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %80 = "llvm.getelementptr"(%73) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %81 = "llvm.getelementptr"(%75) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %82 = "scf.for"(%17, %10, %18, %arg5) ({
            ^bb0(%arg7: index, %arg8: f32):
              %84 = "arith.index_cast"(%arg7) : (index) -> i32
              %85 = "arith.muli"(%84, %4) : (i32, i32) -> i32
              %86 = "arith.muli"(%85, %31) : (i32, i32) -> i32
              %87 = "arith.addi"(%67, %86) : (i32, i32) -> i32
              %88 = "arith.divui"(%87, %4) : (i32, i32) -> i32
              %89 = "arith.index_cast"(%88) : (i32) -> index
              %90 = "polygeist.subindex"(%38, %89) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%57, %90) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %91 = "polygeist.subindex"(%40, %89) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%56, %91) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %92 = "llvm.load"(%73) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %93 = "math.exp"(%92) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %94 = "llvm.load"(%75) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %95 = "arith.mulf"(%94, %92) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %96 = "arith.subf"(%93, %95) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %97 = "arith.addf"(%arg8, %96) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %98 = "llvm.load"(%76) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %99 = "math.exp"(%98) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %100 = "llvm.load"(%77) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %101 = "arith.mulf"(%100, %98) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %102 = "arith.subf"(%99, %101) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %103 = "arith.addf"(%97, %102) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %104 = "llvm.load"(%78) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %105 = "math.exp"(%104) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %106 = "llvm.load"(%79) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %107 = "arith.mulf"(%106, %104) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %108 = "arith.subf"(%105, %107) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %109 = "arith.addf"(%103, %108) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %110 = "llvm.load"(%80) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %111 = "math.exp"(%110) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %112 = "llvm.load"(%81) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %113 = "arith.mulf"(%112, %110) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %114 = "arith.subf"(%111, %113) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %115 = "arith.addf"(%109, %114) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              "scf.yield"(%115) : (f32) -> ()
            }) : (index, index, index, f32) -> f32
            %83 = "arith.addi"(%67, %45) : (i32, i32) -> i32
            "scf.yield"(%82, %83) : (f32, i32) -> ()
          }, {
            "scf.yield"(%arg5, %67) : (f32, i32) -> ()
          }) : (i1) -> (f32, i32)
          "scf.condition"(%68, %71#0, %71#1, %69, %70) : (i1, f32, i32, f32, i32) -> ()
        }, {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %67 = "arith.addi"(%arg6, %41) : (i32, i32) -> i32
          "scf.yield"(%arg5, %67) : (f32, i32) -> ()
        }) : (f32, i32) -> (f32, i32, f32, i32)
        %62 = "arith.index_cast"(%61#3) : (i32) -> index
        %63 = "arith.subi"(%42, %62) : (index, index) -> index
        %64 = "arith.addi"(%44, %63) : (index, index) -> index
        %65 = "arith.divui"(%64, %43) : (index, index) -> index
        %66 = "scf.for"(%17, %65, %18, %61#2) ({
        ^bb0(%arg5: index, %arg6: f32):
          %67 = "arith.muli"(%arg5, %43) : (index, index) -> index
          %68 = "arith.addi"(%67, %62) : (index, index) -> index
          %69 = "memref.load"(%arg0, %68) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %70 = "memref.load"(%arg1, %68) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %71 = "math.exp"(%69) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          %72 = "arith.mulf"(%70, %69) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %73 = "arith.subf"(%71, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %74 = "arith.addf"(%arg6, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%74) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%66, %22, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "memref.store"(%66, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %49 = "arith.cmpi"(%31, %5) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %50 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %50) ({
      ^bb0(%arg4: index):
        %56 = "memref.load"(%22, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %57 = "arith.index_cast"(%arg4) : (index) -> i32
        %58 = "arith.cmpi"(%57, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %59 = "arith.andi"(%49, %58) : (i1, i1) -> i1
        %60 = "scf.if"(%59) ({
          %61 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %62 = "memref.load"(%21, %61) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %63 = "arith.addf"(%56, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%63) : (f32) -> ()
        }, {
          "scf.yield"(%56) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%60, %25, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %51 = "arith.cmpi"(%31, %6) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %52 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %52) ({
      ^bb0(%arg4: index):
        %56 = "memref.load"(%25, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %57 = "arith.index_cast"(%arg4) : (index) -> i32
        %58 = "arith.cmpi"(%57, %7) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %59 = "arith.andi"(%51, %58) : (i1, i1) -> i1
        %60 = "scf.if"(%59) ({
          %61 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %62 = "memref.load"(%21, %61) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %63 = "arith.addf"(%56, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%63) : (f32) -> ()
        }, {
          "scf.yield"(%56) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%60, %26, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %53 = "arith.cmpi"(%31, %7) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %54 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %54) ({
      ^bb0(%arg4: index):
        %56 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %57 = "arith.index_cast"(%arg4) : (index) -> i32
        %58 = "arith.cmpi"(%57, %8) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %59 = "arith.andi"(%53, %58) : (i1, i1) -> i1
        %60 = "scf.if"(%59) ({
          %61 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %62 = "memref.load"(%21, %61) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %63 = "arith.addf"(%56, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%63) : (f32) -> ()
        }, {
          "scf.yield"(%56) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%60, %27, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %55 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %55) ({
      ^bb0(%arg4: index):
        %56 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %57 = "arith.index_cast"(%arg4) : (index) -> i32
        %58 = "arith.cmpi"(%57, %3) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %59 = "arith.cmpi"(%57, %9) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%59) ({
          %60 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %61 = "memref.load"(%21, %60) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %62 = "arith.addf"(%56, %61) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%62, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %63 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %64 = "memref.load"(%21, %63) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %65 = "arith.addf"(%62, %64) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%65, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %66 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %67 = "memref.load"(%21, %66) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %68 = "arith.addf"(%65, %67) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%68, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %69 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %70 = "memref.load"(%21, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "arith.addf"(%68, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%71, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %72 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %73 = "memref.load"(%21, %72) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %74 = "arith.addf"(%71, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%74, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %75 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %76 = "memref.load"(%21, %75) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %77 = "arith.addf"(%74, %76) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%77, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%58) ({
          %60 = "memref.load"(%21, %17) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          "memref.store"(%60, %arg2, %28) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, f32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32):
      %0 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %1 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = -3 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 256 : index}> : () -> index
      %10 = "arith.constant"() <{value = 128 : index}> : () -> index
      %11 = "arith.constant"() <{value = 64 : index}> : () -> index
      %12 = "arith.constant"() <{value = 16 : index}> : () -> index
      %13 = "arith.constant"() <{value = 8 : index}> : () -> index
      %14 = "arith.constant"() <{value = 4 : index}> : () -> index
      %15 = "arith.constant"() <{value = 2 : index}> : () -> index
      %16 = "arith.constant"() <{value = 0 : index}> : () -> index
      %17 = "arith.constant"() <{value = 1 : index}> : () -> index
      %18 = "arith.constant"() <{value = 32 : index}> : () -> index
      %19 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %20 = "arith.cmpi"(%arg2, %1) <{predicate = 5 : i64}> : (i32, i32) -> i1
      %21 = "arith.divsi"(%arg2, %1) : (i32, i32) -> i32
      %22 = "arith.muli"(%21, %1) : (i32, i32) -> i32
      %23 = "arith.constant"() <{value = 32 : index}> : () -> index
      %24 = "arith.index_cast"(%arg2) : (i32) -> index
      %25 = "arith.subi"(%23, %17) : (index, index) -> index
      %26 = "memref.get_global"() <{name = @sdata}> : () -> memref<1xf32>
      %27 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %28 = "polygeist.pointer2memref"(%27) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %29 = "arith.addi"(%arg2, %8) : (i32, i32) -> i32
      %30 = "arith.index_cast"(%23) : (index) -> i32
      %31 = "arith.muli"(%30, %1) : (i32, i32) -> i32
      %32 = "arith.index_cast"(%29) : (i32) -> index
      %33 = "arith.index_cast"(%31) : (i32) -> index
      %34 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %34) ({
      ^bb0(%arg4: index):
        %42 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "scf.if"(%20) ({
          %51 = "arith.muli"(%43, %1) : (i32, i32) -> i32
          %52 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %53 = "polygeist.memref2pointer"(%52) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %54 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
          %55 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
          %56 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
          %57 = "arith.index_cast"(%51) : (i32) -> index
          %58 = "scf.for"(%57, %32, %33, %0) ({
          ^bb0(%arg5: index, %arg6: f32):
            %59 = "arith.subi"(%arg5, %57) : (index, index) -> index
            %60 = "arith.divui"(%59, %33) : (index, index) -> index
            %61 = "arith.muli"(%60, %33) : (index, index) -> index
            %62 = "arith.addi"(%57, %61) : (index, index) -> index
            %63 = "arith.index_cast"(%62) : (index) -> i32
            %64 = "arith.divsi"(%63, %1) : (i32, i32) -> i32
            %65 = "arith.index_cast"(%64) : (i32) -> index
            %66 = "polygeist.subindex"(%28, %65) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            "func.call"(%42, %66) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %67 = "llvm.load"(%53) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %68 = "llvm.load"(%54) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %69 = "arith.addf"(%67, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %70 = "llvm.load"(%55) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %71 = "arith.addf"(%69, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %72 = "llvm.load"(%56) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %73 = "arith.addf"(%71, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %74 = "arith.addf"(%arg6, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "scf.yield"(%74) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          "scf.yield"(%58) : (f32) -> ()
        }, {
          "scf.yield"(%0) : (f32) -> ()
        }) : (i1) -> f32
        %45 = "arith.addi"(%43, %22) : (i32, i32) -> i32
        %46 = "arith.index_cast"(%45) : (i32) -> index
        %47 = "arith.subi"(%24, %46) : (index, index) -> index
        %48 = "arith.addi"(%25, %47) : (index, index) -> index
        %49 = "arith.divui"(%48, %23) : (index, index) -> index
        %50 = "scf.for"(%16, %49, %17, %44) ({
        ^bb0(%arg5: index, %arg6: f32):
          %51 = "arith.muli"(%arg5, %23) : (index, index) -> index
          %52 = "arith.addi"(%51, %46) : (index, index) -> index
          %53 = "memref.load"(%arg0, %52) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %54 = "arith.addf"(%arg6, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%54) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%50, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %35 = "arith.cmpi"(%30, %2) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %36 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %36) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %3) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%35, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %9) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %37 = "arith.cmpi"(%30, %3) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %38 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %38) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %4) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%37, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %39 = "arith.cmpi"(%30, %4) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %40 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %40) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %5) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%39, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %41 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %41) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %7) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %44 = "arith.cmpi"(%42, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %49 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %50 = "memref.load"(%26, %49) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %51 = "arith.addf"(%48, %50) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%51, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %52 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %53 = "memref.load"(%26, %52) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %54 = "arith.addf"(%51, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%54, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %55 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %56 = "memref.load"(%26, %55) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %57 = "arith.addf"(%54, %56) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%57, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %58 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %59 = "memref.load"(%26, %58) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %60 = "arith.addf"(%57, %59) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%60, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %61 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %62 = "memref.load"(%26, %61) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %63 = "arith.addf"(%60, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%43) ({
          %45 = "memref.load"(%26, %16) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %46 = "arith.mulf"(%45, %arg3) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%46, %arg1, %16) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif_1"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
MemRefAllocaToNPULowering: module: end
[ict-debug] MemRefAllocaToNPULowering: process op: 

%22 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
[ict-debug] MemRefAllocaToNPULowering: memory space is 5

MemRefAllocaToNPULowering: newAllocaOp: 
%22 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
MemRefAllocaToNPULowering: old allocaOp: 
%23 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
MemRefAllocaToNPULowering: module: 
"builtin.module"() ({
  "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32):
      %0 = "arith.constant"() <{value = 8 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %2 = "arith.constant"() <{value = 7 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 2 : index}> : () -> index
      %11 = "arith.constant"() <{value = 256 : index}> : () -> index
      %12 = "arith.constant"() <{value = 128 : index}> : () -> index
      %13 = "arith.constant"() <{value = 64 : index}> : () -> index
      %14 = "arith.constant"() <{value = 16 : index}> : () -> index
      %15 = "arith.constant"() <{value = 8 : index}> : () -> index
      %16 = "arith.constant"() <{value = 4 : index}> : () -> index
      %17 = "arith.constant"() <{value = 0 : index}> : () -> index
      %18 = "arith.constant"() <{value = 1 : index}> : () -> index
      %19 = "arith.constant"() <{value = 32 : index}> : () -> index
      %20 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %21 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1xf32, 5>
      %22 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %23 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %24 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %25 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %26 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %27 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %28 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %29 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %30 = "arith.index_cast"(%29) : (index) -> i32
      %31 = "arith.constant"() <{value = 32 : index}> : () -> index
      %32 = "arith.index_cast"(%31) : (index) -> i32
      %33 = "arith.muli"(%30, %32) : (i32, i32) -> i32
      %34 = "arith.muli"(%33, %0) : (i32, i32) -> i32
      %35 = "npu.block_num"() : () -> i64
      %36 = "arith.index_cast"(%35) : (i64) -> i32
      %37 = "arith.muli"(%32, %36) : (i32, i32) -> i32
      %38 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %39 = "polygeist.pointer2memref"(%38) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %40 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %41 = "polygeist.pointer2memref"(%40) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %42 = "arith.muli"(%32, %2) : (i32, i32) -> i32
      %43 = "arith.index_cast"(%arg3) : (i32) -> index
      %44 = "arith.index_cast"(%37) : (i32) -> index
      %45 = "arith.subi"(%44, %18) : (index, index) -> index
      %46 = "arith.muli"(%37, %0) : (i32, i32) -> i32
      %47 = "llvm.mlir.undef"() : () -> f32
      %48 = "llvm.mlir.undef"() : () -> i32
      %49 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %49) ({
      ^bb0(%arg4: index):
        %57 = "polygeist.subindex"(%24, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %58 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %59 = "arith.index_cast"(%arg4) : (index) -> i32
        %60 = "arith.addi"(%34, %59) : (i32, i32) -> i32
        %61 = "arith.addi"(%60, %42) : (i32, i32) -> i32
        %62:4 = "scf.while"(%1, %61) ({
        ^bb0(%arg5: f32, %arg6: i32):
          %68 = "arith.subi"(%arg6, %42) : (i32, i32) -> i32
          %69 = "arith.cmpi"(%arg6, %arg3) <{predicate = 6 : i64}> : (i32, i32) -> i1
          %70 = "arith.select"(%69, %47, %arg5) : (i1, f32, f32) -> f32
          %71 = "arith.select"(%69, %48, %68) : (i1, i32, i32) -> i32
          %72:2 = "scf.if"(%69) ({
            %73 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %74 = "polygeist.memref2pointer"(%73) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %75 = "polygeist.subindex"(%24, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %76 = "polygeist.memref2pointer"(%75) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %77 = "llvm.getelementptr"(%74) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %78 = "llvm.getelementptr"(%76) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %79 = "llvm.getelementptr"(%74) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %80 = "llvm.getelementptr"(%76) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %81 = "llvm.getelementptr"(%74) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %82 = "llvm.getelementptr"(%76) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %83 = "scf.for"(%17, %10, %18, %arg5) ({
            ^bb0(%arg7: index, %arg8: f32):
              %85 = "arith.index_cast"(%arg7) : (index) -> i32
              %86 = "arith.muli"(%85, %4) : (i32, i32) -> i32
              %87 = "arith.muli"(%86, %32) : (i32, i32) -> i32
              %88 = "arith.addi"(%68, %87) : (i32, i32) -> i32
              %89 = "arith.divui"(%88, %4) : (i32, i32) -> i32
              %90 = "arith.index_cast"(%89) : (i32) -> index
              %91 = "polygeist.subindex"(%39, %90) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%58, %91) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %92 = "polygeist.subindex"(%41, %90) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%57, %92) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %93 = "llvm.load"(%74) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %94 = "math.exp"(%93) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %95 = "llvm.load"(%76) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %96 = "arith.mulf"(%95, %93) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %97 = "arith.subf"(%94, %96) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %98 = "arith.addf"(%arg8, %97) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %99 = "llvm.load"(%77) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %100 = "math.exp"(%99) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %101 = "llvm.load"(%78) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %102 = "arith.mulf"(%101, %99) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %103 = "arith.subf"(%100, %102) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %104 = "arith.addf"(%98, %103) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %105 = "llvm.load"(%79) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %106 = "math.exp"(%105) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %107 = "llvm.load"(%80) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %108 = "arith.mulf"(%107, %105) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %109 = "arith.subf"(%106, %108) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %110 = "arith.addf"(%104, %109) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %111 = "llvm.load"(%81) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %112 = "math.exp"(%111) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %113 = "llvm.load"(%82) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %114 = "arith.mulf"(%113, %111) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %115 = "arith.subf"(%112, %114) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %116 = "arith.addf"(%110, %115) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              "scf.yield"(%116) : (f32) -> ()
            }) : (index, index, index, f32) -> f32
            %84 = "arith.addi"(%68, %46) : (i32, i32) -> i32
            "scf.yield"(%83, %84) : (f32, i32) -> ()
          }, {
            "scf.yield"(%arg5, %68) : (f32, i32) -> ()
          }) : (i1) -> (f32, i32)
          "scf.condition"(%69, %72#0, %72#1, %70, %71) : (i1, f32, i32, f32, i32) -> ()
        }, {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %68 = "arith.addi"(%arg6, %42) : (i32, i32) -> i32
          "scf.yield"(%arg5, %68) : (f32, i32) -> ()
        }) : (f32, i32) -> (f32, i32, f32, i32)
        %63 = "arith.index_cast"(%62#3) : (i32) -> index
        %64 = "arith.subi"(%43, %63) : (index, index) -> index
        %65 = "arith.addi"(%45, %64) : (index, index) -> index
        %66 = "arith.divui"(%65, %44) : (index, index) -> index
        %67 = "scf.for"(%17, %66, %18, %62#2) ({
        ^bb0(%arg5: index, %arg6: f32):
          %68 = "arith.muli"(%arg5, %44) : (index, index) -> index
          %69 = "arith.addi"(%68, %63) : (index, index) -> index
          %70 = "memref.load"(%arg0, %69) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %71 = "memref.load"(%arg1, %69) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %72 = "math.exp"(%70) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          %73 = "arith.mulf"(%71, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %74 = "arith.subf"(%72, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %75 = "arith.addf"(%arg6, %74) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%75) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%67, %23, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "memref.store"(%67, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %50 = "arith.cmpi"(%32, %5) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %51 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %51) ({
      ^bb0(%arg4: index):
        %57 = "memref.load"(%23, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %58 = "arith.index_cast"(%arg4) : (index) -> i32
        %59 = "arith.cmpi"(%58, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %60 = "arith.andi"(%50, %59) : (i1, i1) -> i1
        %61 = "scf.if"(%60) ({
          %62 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %63 = "memref.load"(%21, %62) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %64 = "arith.addf"(%57, %63) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%64, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%64) : (f32) -> ()
        }, {
          "scf.yield"(%57) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%61, %26, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %52 = "arith.cmpi"(%32, %6) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %53 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %53) ({
      ^bb0(%arg4: index):
        %57 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %58 = "arith.index_cast"(%arg4) : (index) -> i32
        %59 = "arith.cmpi"(%58, %7) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %60 = "arith.andi"(%52, %59) : (i1, i1) -> i1
        %61 = "scf.if"(%60) ({
          %62 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %63 = "memref.load"(%21, %62) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %64 = "arith.addf"(%57, %63) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%64, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%64) : (f32) -> ()
        }, {
          "scf.yield"(%57) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%61, %27, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %54 = "arith.cmpi"(%32, %7) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %55 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %55) ({
      ^bb0(%arg4: index):
        %57 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %58 = "arith.index_cast"(%arg4) : (index) -> i32
        %59 = "arith.cmpi"(%58, %8) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %60 = "arith.andi"(%54, %59) : (i1, i1) -> i1
        %61 = "scf.if"(%60) ({
          %62 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %63 = "memref.load"(%21, %62) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %64 = "arith.addf"(%57, %63) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%64, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%64) : (f32) -> ()
        }, {
          "scf.yield"(%57) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%61, %28, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %56 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %56) ({
      ^bb0(%arg4: index):
        %57 = "memref.load"(%28, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %58 = "arith.index_cast"(%arg4) : (index) -> i32
        %59 = "arith.cmpi"(%58, %3) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %60 = "arith.cmpi"(%58, %9) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%60) ({
          %61 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %62 = "memref.load"(%21, %61) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %63 = "arith.addf"(%57, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %64 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %65 = "memref.load"(%21, %64) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %66 = "arith.addf"(%63, %65) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%66, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %67 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %68 = "memref.load"(%21, %67) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %69 = "arith.addf"(%66, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%69, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %70 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %71 = "memref.load"(%21, %70) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %72 = "arith.addf"(%69, %71) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%72, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %73 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %74 = "memref.load"(%21, %73) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %75 = "arith.addf"(%72, %74) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%75, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %76 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %77 = "memref.load"(%21, %76) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %78 = "arith.addf"(%75, %77) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%78, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%59) ({
          %61 = "memref.load"(%21, %17) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          "memref.store"(%61, %arg2, %29) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, f32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32):
      %0 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %1 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = -3 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 256 : index}> : () -> index
      %10 = "arith.constant"() <{value = 128 : index}> : () -> index
      %11 = "arith.constant"() <{value = 64 : index}> : () -> index
      %12 = "arith.constant"() <{value = 16 : index}> : () -> index
      %13 = "arith.constant"() <{value = 8 : index}> : () -> index
      %14 = "arith.constant"() <{value = 4 : index}> : () -> index
      %15 = "arith.constant"() <{value = 2 : index}> : () -> index
      %16 = "arith.constant"() <{value = 0 : index}> : () -> index
      %17 = "arith.constant"() <{value = 1 : index}> : () -> index
      %18 = "arith.constant"() <{value = 32 : index}> : () -> index
      %19 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %20 = "arith.cmpi"(%arg2, %1) <{predicate = 5 : i64}> : (i32, i32) -> i1
      %21 = "arith.divsi"(%arg2, %1) : (i32, i32) -> i32
      %22 = "arith.muli"(%21, %1) : (i32, i32) -> i32
      %23 = "arith.constant"() <{value = 32 : index}> : () -> index
      %24 = "arith.index_cast"(%arg2) : (i32) -> index
      %25 = "arith.subi"(%23, %17) : (index, index) -> index
      %26 = "memref.get_global"() <{name = @sdata}> : () -> memref<1xf32>
      %27 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %28 = "polygeist.pointer2memref"(%27) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %29 = "arith.addi"(%arg2, %8) : (i32, i32) -> i32
      %30 = "arith.index_cast"(%23) : (index) -> i32
      %31 = "arith.muli"(%30, %1) : (i32, i32) -> i32
      %32 = "arith.index_cast"(%29) : (i32) -> index
      %33 = "arith.index_cast"(%31) : (i32) -> index
      %34 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %34) ({
      ^bb0(%arg4: index):
        %42 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "scf.if"(%20) ({
          %51 = "arith.muli"(%43, %1) : (i32, i32) -> i32
          %52 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %53 = "polygeist.memref2pointer"(%52) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %54 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
          %55 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
          %56 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
          %57 = "arith.index_cast"(%51) : (i32) -> index
          %58 = "scf.for"(%57, %32, %33, %0) ({
          ^bb0(%arg5: index, %arg6: f32):
            %59 = "arith.subi"(%arg5, %57) : (index, index) -> index
            %60 = "arith.divui"(%59, %33) : (index, index) -> index
            %61 = "arith.muli"(%60, %33) : (index, index) -> index
            %62 = "arith.addi"(%57, %61) : (index, index) -> index
            %63 = "arith.index_cast"(%62) : (index) -> i32
            %64 = "arith.divsi"(%63, %1) : (i32, i32) -> i32
            %65 = "arith.index_cast"(%64) : (i32) -> index
            %66 = "polygeist.subindex"(%28, %65) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            "func.call"(%42, %66) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %67 = "llvm.load"(%53) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %68 = "llvm.load"(%54) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %69 = "arith.addf"(%67, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %70 = "llvm.load"(%55) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %71 = "arith.addf"(%69, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %72 = "llvm.load"(%56) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %73 = "arith.addf"(%71, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %74 = "arith.addf"(%arg6, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "scf.yield"(%74) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          "scf.yield"(%58) : (f32) -> ()
        }, {
          "scf.yield"(%0) : (f32) -> ()
        }) : (i1) -> f32
        %45 = "arith.addi"(%43, %22) : (i32, i32) -> i32
        %46 = "arith.index_cast"(%45) : (i32) -> index
        %47 = "arith.subi"(%24, %46) : (index, index) -> index
        %48 = "arith.addi"(%25, %47) : (index, index) -> index
        %49 = "arith.divui"(%48, %23) : (index, index) -> index
        %50 = "scf.for"(%16, %49, %17, %44) ({
        ^bb0(%arg5: index, %arg6: f32):
          %51 = "arith.muli"(%arg5, %23) : (index, index) -> index
          %52 = "arith.addi"(%51, %46) : (index, index) -> index
          %53 = "memref.load"(%arg0, %52) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %54 = "arith.addf"(%arg6, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%54) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%50, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %35 = "arith.cmpi"(%30, %2) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %36 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %36) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %3) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%35, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %9) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %37 = "arith.cmpi"(%30, %3) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %38 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %38) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %4) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%37, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %39 = "arith.cmpi"(%30, %4) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %40 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %40) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %5) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%39, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %41 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %41) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %7) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %44 = "arith.cmpi"(%42, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %49 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %50 = "memref.load"(%26, %49) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %51 = "arith.addf"(%48, %50) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%51, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %52 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %53 = "memref.load"(%26, %52) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %54 = "arith.addf"(%51, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%54, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %55 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %56 = "memref.load"(%26, %55) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %57 = "arith.addf"(%54, %56) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%57, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %58 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %59 = "memref.load"(%26, %58) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %60 = "arith.addf"(%57, %59) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%60, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %61 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %62 = "memref.load"(%26, %61) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %63 = "arith.addf"(%60, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%43) ({
          %45 = "memref.load"(%26, %16) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %46 = "arith.mulf"(%45, %arg3) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%46, %arg1, %16) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif_1"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
MemRefAllocaToNPULowering: module: end
[ict-debug] MemRefAllocaToNPULowering: process op: 

%24 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
[ict-debug] MemRefAllocaToNPULowering: memory space is 5

MemRefAllocaToNPULowering: newAllocaOp: 
%24 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
MemRefAllocaToNPULowering: old allocaOp: 
%25 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
MemRefAllocaToNPULowering: module: 
"builtin.module"() ({
  "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32):
      %0 = "arith.constant"() <{value = 8 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %2 = "arith.constant"() <{value = 7 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 2 : index}> : () -> index
      %11 = "arith.constant"() <{value = 256 : index}> : () -> index
      %12 = "arith.constant"() <{value = 128 : index}> : () -> index
      %13 = "arith.constant"() <{value = 64 : index}> : () -> index
      %14 = "arith.constant"() <{value = 16 : index}> : () -> index
      %15 = "arith.constant"() <{value = 8 : index}> : () -> index
      %16 = "arith.constant"() <{value = 4 : index}> : () -> index
      %17 = "arith.constant"() <{value = 0 : index}> : () -> index
      %18 = "arith.constant"() <{value = 1 : index}> : () -> index
      %19 = "arith.constant"() <{value = 32 : index}> : () -> index
      %20 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %21 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1xf32, 5>
      %22 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %23 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %24 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %25 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %26 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %27 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %28 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %29 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %30 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %31 = "arith.index_cast"(%30) : (index) -> i32
      %32 = "arith.constant"() <{value = 32 : index}> : () -> index
      %33 = "arith.index_cast"(%32) : (index) -> i32
      %34 = "arith.muli"(%31, %33) : (i32, i32) -> i32
      %35 = "arith.muli"(%34, %0) : (i32, i32) -> i32
      %36 = "npu.block_num"() : () -> i64
      %37 = "arith.index_cast"(%36) : (i64) -> i32
      %38 = "arith.muli"(%33, %37) : (i32, i32) -> i32
      %39 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %40 = "polygeist.pointer2memref"(%39) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %41 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %42 = "polygeist.pointer2memref"(%41) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %43 = "arith.muli"(%33, %2) : (i32, i32) -> i32
      %44 = "arith.index_cast"(%arg3) : (i32) -> index
      %45 = "arith.index_cast"(%38) : (i32) -> index
      %46 = "arith.subi"(%45, %18) : (index, index) -> index
      %47 = "arith.muli"(%38, %0) : (i32, i32) -> i32
      %48 = "llvm.mlir.undef"() : () -> f32
      %49 = "llvm.mlir.undef"() : () -> i32
      %50 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %50) ({
      ^bb0(%arg4: index):
        %58 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %59 = "polygeist.subindex"(%26, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %60 = "arith.index_cast"(%arg4) : (index) -> i32
        %61 = "arith.addi"(%35, %60) : (i32, i32) -> i32
        %62 = "arith.addi"(%61, %43) : (i32, i32) -> i32
        %63:4 = "scf.while"(%1, %62) ({
        ^bb0(%arg5: f32, %arg6: i32):
          %69 = "arith.subi"(%arg6, %43) : (i32, i32) -> i32
          %70 = "arith.cmpi"(%arg6, %arg3) <{predicate = 6 : i64}> : (i32, i32) -> i1
          %71 = "arith.select"(%70, %48, %arg5) : (i1, f32, f32) -> f32
          %72 = "arith.select"(%70, %49, %69) : (i1, i32, i32) -> i32
          %73:2 = "scf.if"(%70) ({
            %74 = "polygeist.subindex"(%26, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %75 = "polygeist.memref2pointer"(%74) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %76 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %77 = "polygeist.memref2pointer"(%76) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %78 = "llvm.getelementptr"(%75) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %79 = "llvm.getelementptr"(%77) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %80 = "llvm.getelementptr"(%75) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %81 = "llvm.getelementptr"(%77) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %82 = "llvm.getelementptr"(%75) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %83 = "llvm.getelementptr"(%77) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %84 = "scf.for"(%17, %10, %18, %arg5) ({
            ^bb0(%arg7: index, %arg8: f32):
              %86 = "arith.index_cast"(%arg7) : (index) -> i32
              %87 = "arith.muli"(%86, %4) : (i32, i32) -> i32
              %88 = "arith.muli"(%87, %33) : (i32, i32) -> i32
              %89 = "arith.addi"(%69, %88) : (i32, i32) -> i32
              %90 = "arith.divui"(%89, %4) : (i32, i32) -> i32
              %91 = "arith.index_cast"(%90) : (i32) -> index
              %92 = "polygeist.subindex"(%40, %91) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%59, %92) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %93 = "polygeist.subindex"(%42, %91) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%58, %93) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %94 = "llvm.load"(%75) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %95 = "math.exp"(%94) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %96 = "llvm.load"(%77) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %97 = "arith.mulf"(%96, %94) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %98 = "arith.subf"(%95, %97) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %99 = "arith.addf"(%arg8, %98) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %100 = "llvm.load"(%78) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %101 = "math.exp"(%100) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %102 = "llvm.load"(%79) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %103 = "arith.mulf"(%102, %100) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %104 = "arith.subf"(%101, %103) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %105 = "arith.addf"(%99, %104) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %106 = "llvm.load"(%80) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %107 = "math.exp"(%106) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %108 = "llvm.load"(%81) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %109 = "arith.mulf"(%108, %106) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %110 = "arith.subf"(%107, %109) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %111 = "arith.addf"(%105, %110) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %112 = "llvm.load"(%82) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %113 = "math.exp"(%112) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %114 = "llvm.load"(%83) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %115 = "arith.mulf"(%114, %112) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %116 = "arith.subf"(%113, %115) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %117 = "arith.addf"(%111, %116) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              "scf.yield"(%117) : (f32) -> ()
            }) : (index, index, index, f32) -> f32
            %85 = "arith.addi"(%69, %47) : (i32, i32) -> i32
            "scf.yield"(%84, %85) : (f32, i32) -> ()
          }, {
            "scf.yield"(%arg5, %69) : (f32, i32) -> ()
          }) : (i1) -> (f32, i32)
          "scf.condition"(%70, %73#0, %73#1, %71, %72) : (i1, f32, i32, f32, i32) -> ()
        }, {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %69 = "arith.addi"(%arg6, %43) : (i32, i32) -> i32
          "scf.yield"(%arg5, %69) : (f32, i32) -> ()
        }) : (f32, i32) -> (f32, i32, f32, i32)
        %64 = "arith.index_cast"(%63#3) : (i32) -> index
        %65 = "arith.subi"(%44, %64) : (index, index) -> index
        %66 = "arith.addi"(%46, %65) : (index, index) -> index
        %67 = "arith.divui"(%66, %45) : (index, index) -> index
        %68 = "scf.for"(%17, %67, %18, %63#2) ({
        ^bb0(%arg5: index, %arg6: f32):
          %69 = "arith.muli"(%arg5, %45) : (index, index) -> index
          %70 = "arith.addi"(%69, %64) : (index, index) -> index
          %71 = "memref.load"(%arg0, %70) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %72 = "memref.load"(%arg1, %70) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %73 = "math.exp"(%71) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          %74 = "arith.mulf"(%72, %71) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %75 = "arith.subf"(%73, %74) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %76 = "arith.addf"(%arg6, %75) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%76) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%68, %23, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "memref.store"(%68, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %51 = "arith.cmpi"(%33, %5) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %52 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %52) ({
      ^bb0(%arg4: index):
        %58 = "memref.load"(%23, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %59 = "arith.index_cast"(%arg4) : (index) -> i32
        %60 = "arith.cmpi"(%59, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %61 = "arith.andi"(%51, %60) : (i1, i1) -> i1
        %62 = "scf.if"(%61) ({
          %63 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %64 = "memref.load"(%21, %63) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %65 = "arith.addf"(%58, %64) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%65, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%65) : (f32) -> ()
        }, {
          "scf.yield"(%58) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%62, %27, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %53 = "arith.cmpi"(%33, %6) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %54 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %54) ({
      ^bb0(%arg4: index):
        %58 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %59 = "arith.index_cast"(%arg4) : (index) -> i32
        %60 = "arith.cmpi"(%59, %7) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %61 = "arith.andi"(%53, %60) : (i1, i1) -> i1
        %62 = "scf.if"(%61) ({
          %63 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %64 = "memref.load"(%21, %63) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %65 = "arith.addf"(%58, %64) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%65, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%65) : (f32) -> ()
        }, {
          "scf.yield"(%58) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%62, %28, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %55 = "arith.cmpi"(%33, %7) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %56 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %56) ({
      ^bb0(%arg4: index):
        %58 = "memref.load"(%28, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %59 = "arith.index_cast"(%arg4) : (index) -> i32
        %60 = "arith.cmpi"(%59, %8) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %61 = "arith.andi"(%55, %60) : (i1, i1) -> i1
        %62 = "scf.if"(%61) ({
          %63 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %64 = "memref.load"(%21, %63) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %65 = "arith.addf"(%58, %64) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%65, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%65) : (f32) -> ()
        }, {
          "scf.yield"(%58) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%62, %29, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %57 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %57) ({
      ^bb0(%arg4: index):
        %58 = "memref.load"(%29, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %59 = "arith.index_cast"(%arg4) : (index) -> i32
        %60 = "arith.cmpi"(%59, %3) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %61 = "arith.cmpi"(%59, %9) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%61) ({
          %62 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %63 = "memref.load"(%21, %62) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %64 = "arith.addf"(%58, %63) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%64, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %65 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %66 = "memref.load"(%21, %65) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %67 = "arith.addf"(%64, %66) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%67, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %68 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %69 = "memref.load"(%21, %68) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %70 = "arith.addf"(%67, %69) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%70, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %71 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %72 = "memref.load"(%21, %71) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %73 = "arith.addf"(%70, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%73, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %74 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %75 = "memref.load"(%21, %74) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %76 = "arith.addf"(%73, %75) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%76, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %77 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %78 = "memref.load"(%21, %77) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %79 = "arith.addf"(%76, %78) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%79, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%60) ({
          %62 = "memref.load"(%21, %17) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          "memref.store"(%62, %arg2, %30) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, f32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32):
      %0 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %1 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = -3 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 256 : index}> : () -> index
      %10 = "arith.constant"() <{value = 128 : index}> : () -> index
      %11 = "arith.constant"() <{value = 64 : index}> : () -> index
      %12 = "arith.constant"() <{value = 16 : index}> : () -> index
      %13 = "arith.constant"() <{value = 8 : index}> : () -> index
      %14 = "arith.constant"() <{value = 4 : index}> : () -> index
      %15 = "arith.constant"() <{value = 2 : index}> : () -> index
      %16 = "arith.constant"() <{value = 0 : index}> : () -> index
      %17 = "arith.constant"() <{value = 1 : index}> : () -> index
      %18 = "arith.constant"() <{value = 32 : index}> : () -> index
      %19 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %20 = "arith.cmpi"(%arg2, %1) <{predicate = 5 : i64}> : (i32, i32) -> i1
      %21 = "arith.divsi"(%arg2, %1) : (i32, i32) -> i32
      %22 = "arith.muli"(%21, %1) : (i32, i32) -> i32
      %23 = "arith.constant"() <{value = 32 : index}> : () -> index
      %24 = "arith.index_cast"(%arg2) : (i32) -> index
      %25 = "arith.subi"(%23, %17) : (index, index) -> index
      %26 = "memref.get_global"() <{name = @sdata}> : () -> memref<1xf32>
      %27 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %28 = "polygeist.pointer2memref"(%27) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %29 = "arith.addi"(%arg2, %8) : (i32, i32) -> i32
      %30 = "arith.index_cast"(%23) : (index) -> i32
      %31 = "arith.muli"(%30, %1) : (i32, i32) -> i32
      %32 = "arith.index_cast"(%29) : (i32) -> index
      %33 = "arith.index_cast"(%31) : (i32) -> index
      %34 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %34) ({
      ^bb0(%arg4: index):
        %42 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "scf.if"(%20) ({
          %51 = "arith.muli"(%43, %1) : (i32, i32) -> i32
          %52 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %53 = "polygeist.memref2pointer"(%52) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %54 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
          %55 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
          %56 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
          %57 = "arith.index_cast"(%51) : (i32) -> index
          %58 = "scf.for"(%57, %32, %33, %0) ({
          ^bb0(%arg5: index, %arg6: f32):
            %59 = "arith.subi"(%arg5, %57) : (index, index) -> index
            %60 = "arith.divui"(%59, %33) : (index, index) -> index
            %61 = "arith.muli"(%60, %33) : (index, index) -> index
            %62 = "arith.addi"(%57, %61) : (index, index) -> index
            %63 = "arith.index_cast"(%62) : (index) -> i32
            %64 = "arith.divsi"(%63, %1) : (i32, i32) -> i32
            %65 = "arith.index_cast"(%64) : (i32) -> index
            %66 = "polygeist.subindex"(%28, %65) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            "func.call"(%42, %66) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %67 = "llvm.load"(%53) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %68 = "llvm.load"(%54) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %69 = "arith.addf"(%67, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %70 = "llvm.load"(%55) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %71 = "arith.addf"(%69, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %72 = "llvm.load"(%56) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %73 = "arith.addf"(%71, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %74 = "arith.addf"(%arg6, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "scf.yield"(%74) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          "scf.yield"(%58) : (f32) -> ()
        }, {
          "scf.yield"(%0) : (f32) -> ()
        }) : (i1) -> f32
        %45 = "arith.addi"(%43, %22) : (i32, i32) -> i32
        %46 = "arith.index_cast"(%45) : (i32) -> index
        %47 = "arith.subi"(%24, %46) : (index, index) -> index
        %48 = "arith.addi"(%25, %47) : (index, index) -> index
        %49 = "arith.divui"(%48, %23) : (index, index) -> index
        %50 = "scf.for"(%16, %49, %17, %44) ({
        ^bb0(%arg5: index, %arg6: f32):
          %51 = "arith.muli"(%arg5, %23) : (index, index) -> index
          %52 = "arith.addi"(%51, %46) : (index, index) -> index
          %53 = "memref.load"(%arg0, %52) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %54 = "arith.addf"(%arg6, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%54) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%50, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %35 = "arith.cmpi"(%30, %2) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %36 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %36) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %3) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%35, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %9) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %37 = "arith.cmpi"(%30, %3) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %38 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %38) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %4) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%37, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %39 = "arith.cmpi"(%30, %4) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %40 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %40) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %5) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%39, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %41 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %41) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %7) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %44 = "arith.cmpi"(%42, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %49 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %50 = "memref.load"(%26, %49) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %51 = "arith.addf"(%48, %50) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%51, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %52 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %53 = "memref.load"(%26, %52) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %54 = "arith.addf"(%51, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%54, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %55 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %56 = "memref.load"(%26, %55) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %57 = "arith.addf"(%54, %56) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%57, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %58 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %59 = "memref.load"(%26, %58) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %60 = "arith.addf"(%57, %59) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%60, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %61 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %62 = "memref.load"(%26, %61) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %63 = "arith.addf"(%60, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%43) ({
          %45 = "memref.load"(%26, %16) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %46 = "arith.mulf"(%45, %arg3) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%46, %arg1, %16) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif_1"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
MemRefAllocaToNPULowering: module: end
[ict-debug] MemRefAllocaToNPULowering: process op: 

%26 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
[ict-debug] MemRefAllocaToNPULowering: memory space is 5

MemRefAllocaToNPULowering: newAllocaOp: 
%26 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
MemRefAllocaToNPULowering: old allocaOp: 
%27 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
MemRefAllocaToNPULowering: module: 
"builtin.module"() ({
  "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32):
      %0 = "arith.constant"() <{value = 8 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %2 = "arith.constant"() <{value = 7 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 2 : index}> : () -> index
      %11 = "arith.constant"() <{value = 256 : index}> : () -> index
      %12 = "arith.constant"() <{value = 128 : index}> : () -> index
      %13 = "arith.constant"() <{value = 64 : index}> : () -> index
      %14 = "arith.constant"() <{value = 16 : index}> : () -> index
      %15 = "arith.constant"() <{value = 8 : index}> : () -> index
      %16 = "arith.constant"() <{value = 4 : index}> : () -> index
      %17 = "arith.constant"() <{value = 0 : index}> : () -> index
      %18 = "arith.constant"() <{value = 1 : index}> : () -> index
      %19 = "arith.constant"() <{value = 32 : index}> : () -> index
      %20 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %21 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1xf32, 5>
      %22 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %23 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %24 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %25 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %26 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %27 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %28 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %29 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %30 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %31 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %32 = "arith.index_cast"(%31) : (index) -> i32
      %33 = "arith.constant"() <{value = 32 : index}> : () -> index
      %34 = "arith.index_cast"(%33) : (index) -> i32
      %35 = "arith.muli"(%32, %34) : (i32, i32) -> i32
      %36 = "arith.muli"(%35, %0) : (i32, i32) -> i32
      %37 = "npu.block_num"() : () -> i64
      %38 = "arith.index_cast"(%37) : (i64) -> i32
      %39 = "arith.muli"(%34, %38) : (i32, i32) -> i32
      %40 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %41 = "polygeist.pointer2memref"(%40) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %42 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %43 = "polygeist.pointer2memref"(%42) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %44 = "arith.muli"(%34, %2) : (i32, i32) -> i32
      %45 = "arith.index_cast"(%arg3) : (i32) -> index
      %46 = "arith.index_cast"(%39) : (i32) -> index
      %47 = "arith.subi"(%46, %18) : (index, index) -> index
      %48 = "arith.muli"(%39, %0) : (i32, i32) -> i32
      %49 = "llvm.mlir.undef"() : () -> f32
      %50 = "llvm.mlir.undef"() : () -> i32
      %51 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %51) ({
      ^bb0(%arg4: index):
        %59 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %60 = "polygeist.subindex"(%27, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %61 = "arith.index_cast"(%arg4) : (index) -> i32
        %62 = "arith.addi"(%36, %61) : (i32, i32) -> i32
        %63 = "arith.addi"(%62, %44) : (i32, i32) -> i32
        %64:4 = "scf.while"(%1, %63) ({
        ^bb0(%arg5: f32, %arg6: i32):
          %70 = "arith.subi"(%arg6, %44) : (i32, i32) -> i32
          %71 = "arith.cmpi"(%arg6, %arg3) <{predicate = 6 : i64}> : (i32, i32) -> i1
          %72 = "arith.select"(%71, %49, %arg5) : (i1, f32, f32) -> f32
          %73 = "arith.select"(%71, %50, %70) : (i1, i32, i32) -> i32
          %74:2 = "scf.if"(%71) ({
            %75 = "polygeist.subindex"(%27, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %76 = "polygeist.memref2pointer"(%75) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %77 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %78 = "polygeist.memref2pointer"(%77) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %79 = "llvm.getelementptr"(%76) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %80 = "llvm.getelementptr"(%78) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %81 = "llvm.getelementptr"(%76) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %82 = "llvm.getelementptr"(%78) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %83 = "llvm.getelementptr"(%76) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %84 = "llvm.getelementptr"(%78) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %85 = "scf.for"(%17, %10, %18, %arg5) ({
            ^bb0(%arg7: index, %arg8: f32):
              %87 = "arith.index_cast"(%arg7) : (index) -> i32
              %88 = "arith.muli"(%87, %4) : (i32, i32) -> i32
              %89 = "arith.muli"(%88, %34) : (i32, i32) -> i32
              %90 = "arith.addi"(%70, %89) : (i32, i32) -> i32
              %91 = "arith.divui"(%90, %4) : (i32, i32) -> i32
              %92 = "arith.index_cast"(%91) : (i32) -> index
              %93 = "polygeist.subindex"(%41, %92) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%60, %93) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %94 = "polygeist.subindex"(%43, %92) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%59, %94) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %95 = "llvm.load"(%76) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %96 = "math.exp"(%95) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %97 = "llvm.load"(%78) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %98 = "arith.mulf"(%97, %95) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %99 = "arith.subf"(%96, %98) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %100 = "arith.addf"(%arg8, %99) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %101 = "llvm.load"(%79) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %102 = "math.exp"(%101) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %103 = "llvm.load"(%80) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %104 = "arith.mulf"(%103, %101) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %105 = "arith.subf"(%102, %104) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %106 = "arith.addf"(%100, %105) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %107 = "llvm.load"(%81) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %108 = "math.exp"(%107) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %109 = "llvm.load"(%82) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %110 = "arith.mulf"(%109, %107) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %111 = "arith.subf"(%108, %110) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %112 = "arith.addf"(%106, %111) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %113 = "llvm.load"(%83) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %114 = "math.exp"(%113) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %115 = "llvm.load"(%84) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %116 = "arith.mulf"(%115, %113) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %117 = "arith.subf"(%114, %116) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %118 = "arith.addf"(%112, %117) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              "scf.yield"(%118) : (f32) -> ()
            }) : (index, index, index, f32) -> f32
            %86 = "arith.addi"(%70, %48) : (i32, i32) -> i32
            "scf.yield"(%85, %86) : (f32, i32) -> ()
          }, {
            "scf.yield"(%arg5, %70) : (f32, i32) -> ()
          }) : (i1) -> (f32, i32)
          "scf.condition"(%71, %74#0, %74#1, %72, %73) : (i1, f32, i32, f32, i32) -> ()
        }, {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %70 = "arith.addi"(%arg6, %44) : (i32, i32) -> i32
          "scf.yield"(%arg5, %70) : (f32, i32) -> ()
        }) : (f32, i32) -> (f32, i32, f32, i32)
        %65 = "arith.index_cast"(%64#3) : (i32) -> index
        %66 = "arith.subi"(%45, %65) : (index, index) -> index
        %67 = "arith.addi"(%47, %66) : (index, index) -> index
        %68 = "arith.divui"(%67, %46) : (index, index) -> index
        %69 = "scf.for"(%17, %68, %18, %64#2) ({
        ^bb0(%arg5: index, %arg6: f32):
          %70 = "arith.muli"(%arg5, %46) : (index, index) -> index
          %71 = "arith.addi"(%70, %65) : (index, index) -> index
          %72 = "memref.load"(%arg0, %71) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %73 = "memref.load"(%arg1, %71) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %74 = "math.exp"(%72) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          %75 = "arith.mulf"(%73, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %76 = "arith.subf"(%74, %75) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %77 = "arith.addf"(%arg6, %76) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%77) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%69, %23, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "memref.store"(%69, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %52 = "arith.cmpi"(%34, %5) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %53 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %53) ({
      ^bb0(%arg4: index):
        %59 = "memref.load"(%23, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %60 = "arith.index_cast"(%arg4) : (index) -> i32
        %61 = "arith.cmpi"(%60, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %62 = "arith.andi"(%52, %61) : (i1, i1) -> i1
        %63 = "scf.if"(%62) ({
          %64 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %65 = "memref.load"(%21, %64) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %66 = "arith.addf"(%59, %65) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%66, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%66) : (f32) -> ()
        }, {
          "scf.yield"(%59) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%63, %28, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %54 = "arith.cmpi"(%34, %6) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %55 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %55) ({
      ^bb0(%arg4: index):
        %59 = "memref.load"(%28, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %60 = "arith.index_cast"(%arg4) : (index) -> i32
        %61 = "arith.cmpi"(%60, %7) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %62 = "arith.andi"(%54, %61) : (i1, i1) -> i1
        %63 = "scf.if"(%62) ({
          %64 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %65 = "memref.load"(%21, %64) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %66 = "arith.addf"(%59, %65) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%66, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%66) : (f32) -> ()
        }, {
          "scf.yield"(%59) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%63, %29, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %56 = "arith.cmpi"(%34, %7) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %57 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %57) ({
      ^bb0(%arg4: index):
        %59 = "memref.load"(%29, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %60 = "arith.index_cast"(%arg4) : (index) -> i32
        %61 = "arith.cmpi"(%60, %8) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %62 = "arith.andi"(%56, %61) : (i1, i1) -> i1
        %63 = "scf.if"(%62) ({
          %64 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %65 = "memref.load"(%21, %64) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %66 = "arith.addf"(%59, %65) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%66, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%66) : (f32) -> ()
        }, {
          "scf.yield"(%59) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%63, %30, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %58 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %58) ({
      ^bb0(%arg4: index):
        %59 = "memref.load"(%30, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %60 = "arith.index_cast"(%arg4) : (index) -> i32
        %61 = "arith.cmpi"(%60, %3) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %62 = "arith.cmpi"(%60, %9) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%62) ({
          %63 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %64 = "memref.load"(%21, %63) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %65 = "arith.addf"(%59, %64) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%65, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %66 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %67 = "memref.load"(%21, %66) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %68 = "arith.addf"(%65, %67) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%68, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %69 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %70 = "memref.load"(%21, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "arith.addf"(%68, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%71, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %72 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %73 = "memref.load"(%21, %72) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %74 = "arith.addf"(%71, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%74, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %75 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %76 = "memref.load"(%21, %75) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %77 = "arith.addf"(%74, %76) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%77, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %78 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %79 = "memref.load"(%21, %78) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %80 = "arith.addf"(%77, %79) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%80, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%61) ({
          %63 = "memref.load"(%21, %17) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          "memref.store"(%63, %arg2, %31) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, f32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32):
      %0 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %1 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = -3 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 256 : index}> : () -> index
      %10 = "arith.constant"() <{value = 128 : index}> : () -> index
      %11 = "arith.constant"() <{value = 64 : index}> : () -> index
      %12 = "arith.constant"() <{value = 16 : index}> : () -> index
      %13 = "arith.constant"() <{value = 8 : index}> : () -> index
      %14 = "arith.constant"() <{value = 4 : index}> : () -> index
      %15 = "arith.constant"() <{value = 2 : index}> : () -> index
      %16 = "arith.constant"() <{value = 0 : index}> : () -> index
      %17 = "arith.constant"() <{value = 1 : index}> : () -> index
      %18 = "arith.constant"() <{value = 32 : index}> : () -> index
      %19 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %20 = "arith.cmpi"(%arg2, %1) <{predicate = 5 : i64}> : (i32, i32) -> i1
      %21 = "arith.divsi"(%arg2, %1) : (i32, i32) -> i32
      %22 = "arith.muli"(%21, %1) : (i32, i32) -> i32
      %23 = "arith.constant"() <{value = 32 : index}> : () -> index
      %24 = "arith.index_cast"(%arg2) : (i32) -> index
      %25 = "arith.subi"(%23, %17) : (index, index) -> index
      %26 = "memref.get_global"() <{name = @sdata}> : () -> memref<1xf32>
      %27 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %28 = "polygeist.pointer2memref"(%27) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %29 = "arith.addi"(%arg2, %8) : (i32, i32) -> i32
      %30 = "arith.index_cast"(%23) : (index) -> i32
      %31 = "arith.muli"(%30, %1) : (i32, i32) -> i32
      %32 = "arith.index_cast"(%29) : (i32) -> index
      %33 = "arith.index_cast"(%31) : (i32) -> index
      %34 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %34) ({
      ^bb0(%arg4: index):
        %42 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "scf.if"(%20) ({
          %51 = "arith.muli"(%43, %1) : (i32, i32) -> i32
          %52 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %53 = "polygeist.memref2pointer"(%52) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %54 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
          %55 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
          %56 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
          %57 = "arith.index_cast"(%51) : (i32) -> index
          %58 = "scf.for"(%57, %32, %33, %0) ({
          ^bb0(%arg5: index, %arg6: f32):
            %59 = "arith.subi"(%arg5, %57) : (index, index) -> index
            %60 = "arith.divui"(%59, %33) : (index, index) -> index
            %61 = "arith.muli"(%60, %33) : (index, index) -> index
            %62 = "arith.addi"(%57, %61) : (index, index) -> index
            %63 = "arith.index_cast"(%62) : (index) -> i32
            %64 = "arith.divsi"(%63, %1) : (i32, i32) -> i32
            %65 = "arith.index_cast"(%64) : (i32) -> index
            %66 = "polygeist.subindex"(%28, %65) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            "func.call"(%42, %66) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %67 = "llvm.load"(%53) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %68 = "llvm.load"(%54) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %69 = "arith.addf"(%67, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %70 = "llvm.load"(%55) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %71 = "arith.addf"(%69, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %72 = "llvm.load"(%56) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %73 = "arith.addf"(%71, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %74 = "arith.addf"(%arg6, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "scf.yield"(%74) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          "scf.yield"(%58) : (f32) -> ()
        }, {
          "scf.yield"(%0) : (f32) -> ()
        }) : (i1) -> f32
        %45 = "arith.addi"(%43, %22) : (i32, i32) -> i32
        %46 = "arith.index_cast"(%45) : (i32) -> index
        %47 = "arith.subi"(%24, %46) : (index, index) -> index
        %48 = "arith.addi"(%25, %47) : (index, index) -> index
        %49 = "arith.divui"(%48, %23) : (index, index) -> index
        %50 = "scf.for"(%16, %49, %17, %44) ({
        ^bb0(%arg5: index, %arg6: f32):
          %51 = "arith.muli"(%arg5, %23) : (index, index) -> index
          %52 = "arith.addi"(%51, %46) : (index, index) -> index
          %53 = "memref.load"(%arg0, %52) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %54 = "arith.addf"(%arg6, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%54) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%50, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %35 = "arith.cmpi"(%30, %2) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %36 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %36) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %3) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%35, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %9) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %37 = "arith.cmpi"(%30, %3) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %38 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %38) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %4) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%37, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %39 = "arith.cmpi"(%30, %4) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %40 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %40) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %5) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%39, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %41 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %41) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %7) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %44 = "arith.cmpi"(%42, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %49 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %50 = "memref.load"(%26, %49) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %51 = "arith.addf"(%48, %50) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%51, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %52 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %53 = "memref.load"(%26, %52) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %54 = "arith.addf"(%51, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%54, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %55 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %56 = "memref.load"(%26, %55) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %57 = "arith.addf"(%54, %56) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%57, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %58 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %59 = "memref.load"(%26, %58) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %60 = "arith.addf"(%57, %59) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%60, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %61 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %62 = "memref.load"(%26, %61) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %63 = "arith.addf"(%60, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%43) ({
          %45 = "memref.load"(%26, %16) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %46 = "arith.mulf"(%45, %arg3) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%46, %arg1, %16) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif_1"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
MemRefAllocaToNPULowering: module: end
[ict-debug] MemRefAllocaToNPULowering: process op: 

%28 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
[ict-debug] MemRefAllocaToNPULowering: memory space is 5

MemRefAllocaToNPULowering: newAllocaOp: 
%28 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
MemRefAllocaToNPULowering: old allocaOp: 
%29 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
MemRefAllocaToNPULowering: module: 
"builtin.module"() ({
  "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32):
      %0 = "arith.constant"() <{value = 8 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %2 = "arith.constant"() <{value = 7 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 2 : index}> : () -> index
      %11 = "arith.constant"() <{value = 256 : index}> : () -> index
      %12 = "arith.constant"() <{value = 128 : index}> : () -> index
      %13 = "arith.constant"() <{value = 64 : index}> : () -> index
      %14 = "arith.constant"() <{value = 16 : index}> : () -> index
      %15 = "arith.constant"() <{value = 8 : index}> : () -> index
      %16 = "arith.constant"() <{value = 4 : index}> : () -> index
      %17 = "arith.constant"() <{value = 0 : index}> : () -> index
      %18 = "arith.constant"() <{value = 1 : index}> : () -> index
      %19 = "arith.constant"() <{value = 32 : index}> : () -> index
      %20 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %21 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1xf32, 5>
      %22 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %23 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %24 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %25 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %26 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %27 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %28 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %29 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %30 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %31 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %32 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %33 = "arith.index_cast"(%32) : (index) -> i32
      %34 = "arith.constant"() <{value = 32 : index}> : () -> index
      %35 = "arith.index_cast"(%34) : (index) -> i32
      %36 = "arith.muli"(%33, %35) : (i32, i32) -> i32
      %37 = "arith.muli"(%36, %0) : (i32, i32) -> i32
      %38 = "npu.block_num"() : () -> i64
      %39 = "arith.index_cast"(%38) : (i64) -> i32
      %40 = "arith.muli"(%35, %39) : (i32, i32) -> i32
      %41 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %42 = "polygeist.pointer2memref"(%41) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %43 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %44 = "polygeist.pointer2memref"(%43) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %45 = "arith.muli"(%35, %2) : (i32, i32) -> i32
      %46 = "arith.index_cast"(%arg3) : (i32) -> index
      %47 = "arith.index_cast"(%40) : (i32) -> index
      %48 = "arith.subi"(%47, %18) : (index, index) -> index
      %49 = "arith.muli"(%40, %0) : (i32, i32) -> i32
      %50 = "llvm.mlir.undef"() : () -> f32
      %51 = "llvm.mlir.undef"() : () -> i32
      %52 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %52) ({
      ^bb0(%arg4: index):
        %60 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %61 = "polygeist.subindex"(%27, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %62 = "arith.index_cast"(%arg4) : (index) -> i32
        %63 = "arith.addi"(%37, %62) : (i32, i32) -> i32
        %64 = "arith.addi"(%63, %45) : (i32, i32) -> i32
        %65:4 = "scf.while"(%1, %64) ({
        ^bb0(%arg5: f32, %arg6: i32):
          %71 = "arith.subi"(%arg6, %45) : (i32, i32) -> i32
          %72 = "arith.cmpi"(%arg6, %arg3) <{predicate = 6 : i64}> : (i32, i32) -> i1
          %73 = "arith.select"(%72, %50, %arg5) : (i1, f32, f32) -> f32
          %74 = "arith.select"(%72, %51, %71) : (i1, i32, i32) -> i32
          %75:2 = "scf.if"(%72) ({
            %76 = "polygeist.subindex"(%27, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %77 = "polygeist.memref2pointer"(%76) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %78 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %79 = "polygeist.memref2pointer"(%78) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %80 = "llvm.getelementptr"(%77) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %81 = "llvm.getelementptr"(%79) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %82 = "llvm.getelementptr"(%77) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %83 = "llvm.getelementptr"(%79) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %84 = "llvm.getelementptr"(%77) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %85 = "llvm.getelementptr"(%79) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %86 = "scf.for"(%17, %10, %18, %arg5) ({
            ^bb0(%arg7: index, %arg8: f32):
              %88 = "arith.index_cast"(%arg7) : (index) -> i32
              %89 = "arith.muli"(%88, %4) : (i32, i32) -> i32
              %90 = "arith.muli"(%89, %35) : (i32, i32) -> i32
              %91 = "arith.addi"(%71, %90) : (i32, i32) -> i32
              %92 = "arith.divui"(%91, %4) : (i32, i32) -> i32
              %93 = "arith.index_cast"(%92) : (i32) -> index
              %94 = "polygeist.subindex"(%42, %93) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%61, %94) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %95 = "polygeist.subindex"(%44, %93) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%60, %95) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %96 = "llvm.load"(%77) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %97 = "math.exp"(%96) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %98 = "llvm.load"(%79) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %99 = "arith.mulf"(%98, %96) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %100 = "arith.subf"(%97, %99) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %101 = "arith.addf"(%arg8, %100) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %102 = "llvm.load"(%80) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %103 = "math.exp"(%102) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %104 = "llvm.load"(%81) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %105 = "arith.mulf"(%104, %102) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %106 = "arith.subf"(%103, %105) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %107 = "arith.addf"(%101, %106) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %108 = "llvm.load"(%82) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %109 = "math.exp"(%108) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %110 = "llvm.load"(%83) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %111 = "arith.mulf"(%110, %108) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %112 = "arith.subf"(%109, %111) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %113 = "arith.addf"(%107, %112) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %114 = "llvm.load"(%84) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %115 = "math.exp"(%114) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %116 = "llvm.load"(%85) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %117 = "arith.mulf"(%116, %114) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %118 = "arith.subf"(%115, %117) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %119 = "arith.addf"(%113, %118) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              "scf.yield"(%119) : (f32) -> ()
            }) : (index, index, index, f32) -> f32
            %87 = "arith.addi"(%71, %49) : (i32, i32) -> i32
            "scf.yield"(%86, %87) : (f32, i32) -> ()
          }, {
            "scf.yield"(%arg5, %71) : (f32, i32) -> ()
          }) : (i1) -> (f32, i32)
          "scf.condition"(%72, %75#0, %75#1, %73, %74) : (i1, f32, i32, f32, i32) -> ()
        }, {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %71 = "arith.addi"(%arg6, %45) : (i32, i32) -> i32
          "scf.yield"(%arg5, %71) : (f32, i32) -> ()
        }) : (f32, i32) -> (f32, i32, f32, i32)
        %66 = "arith.index_cast"(%65#3) : (i32) -> index
        %67 = "arith.subi"(%46, %66) : (index, index) -> index
        %68 = "arith.addi"(%48, %67) : (index, index) -> index
        %69 = "arith.divui"(%68, %47) : (index, index) -> index
        %70 = "scf.for"(%17, %69, %18, %65#2) ({
        ^bb0(%arg5: index, %arg6: f32):
          %71 = "arith.muli"(%arg5, %47) : (index, index) -> index
          %72 = "arith.addi"(%71, %66) : (index, index) -> index
          %73 = "memref.load"(%arg0, %72) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %74 = "memref.load"(%arg1, %72) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %75 = "math.exp"(%73) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          %76 = "arith.mulf"(%74, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %77 = "arith.subf"(%75, %76) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %78 = "arith.addf"(%arg6, %77) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%78) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%70, %23, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "memref.store"(%70, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %53 = "arith.cmpi"(%35, %5) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %54 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %54) ({
      ^bb0(%arg4: index):
        %60 = "memref.load"(%23, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %61 = "arith.index_cast"(%arg4) : (index) -> i32
        %62 = "arith.cmpi"(%61, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %63 = "arith.andi"(%53, %62) : (i1, i1) -> i1
        %64 = "scf.if"(%63) ({
          %65 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %66 = "memref.load"(%21, %65) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %67 = "arith.addf"(%60, %66) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%67, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%67) : (f32) -> ()
        }, {
          "scf.yield"(%60) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%64, %29, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %55 = "arith.cmpi"(%35, %6) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %56 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %56) ({
      ^bb0(%arg4: index):
        %60 = "memref.load"(%29, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %61 = "arith.index_cast"(%arg4) : (index) -> i32
        %62 = "arith.cmpi"(%61, %7) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %63 = "arith.andi"(%55, %62) : (i1, i1) -> i1
        %64 = "scf.if"(%63) ({
          %65 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %66 = "memref.load"(%21, %65) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %67 = "arith.addf"(%60, %66) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%67, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%67) : (f32) -> ()
        }, {
          "scf.yield"(%60) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%64, %30, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %57 = "arith.cmpi"(%35, %7) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %58 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %58) ({
      ^bb0(%arg4: index):
        %60 = "memref.load"(%30, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %61 = "arith.index_cast"(%arg4) : (index) -> i32
        %62 = "arith.cmpi"(%61, %8) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %63 = "arith.andi"(%57, %62) : (i1, i1) -> i1
        %64 = "scf.if"(%63) ({
          %65 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %66 = "memref.load"(%21, %65) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %67 = "arith.addf"(%60, %66) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%67, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%67) : (f32) -> ()
        }, {
          "scf.yield"(%60) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%64, %31, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %59 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %59) ({
      ^bb0(%arg4: index):
        %60 = "memref.load"(%31, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %61 = "arith.index_cast"(%arg4) : (index) -> i32
        %62 = "arith.cmpi"(%61, %3) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %63 = "arith.cmpi"(%61, %9) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%63) ({
          %64 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %65 = "memref.load"(%21, %64) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %66 = "arith.addf"(%60, %65) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%66, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %67 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %68 = "memref.load"(%21, %67) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %69 = "arith.addf"(%66, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%69, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %70 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %71 = "memref.load"(%21, %70) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %72 = "arith.addf"(%69, %71) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%72, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %73 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %74 = "memref.load"(%21, %73) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %75 = "arith.addf"(%72, %74) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%75, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %76 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %77 = "memref.load"(%21, %76) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %78 = "arith.addf"(%75, %77) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%78, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %79 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %80 = "memref.load"(%21, %79) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %81 = "arith.addf"(%78, %80) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%81, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%62) ({
          %64 = "memref.load"(%21, %17) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          "memref.store"(%64, %arg2, %32) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, f32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32):
      %0 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %1 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = -3 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 256 : index}> : () -> index
      %10 = "arith.constant"() <{value = 128 : index}> : () -> index
      %11 = "arith.constant"() <{value = 64 : index}> : () -> index
      %12 = "arith.constant"() <{value = 16 : index}> : () -> index
      %13 = "arith.constant"() <{value = 8 : index}> : () -> index
      %14 = "arith.constant"() <{value = 4 : index}> : () -> index
      %15 = "arith.constant"() <{value = 2 : index}> : () -> index
      %16 = "arith.constant"() <{value = 0 : index}> : () -> index
      %17 = "arith.constant"() <{value = 1 : index}> : () -> index
      %18 = "arith.constant"() <{value = 32 : index}> : () -> index
      %19 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %20 = "arith.cmpi"(%arg2, %1) <{predicate = 5 : i64}> : (i32, i32) -> i1
      %21 = "arith.divsi"(%arg2, %1) : (i32, i32) -> i32
      %22 = "arith.muli"(%21, %1) : (i32, i32) -> i32
      %23 = "arith.constant"() <{value = 32 : index}> : () -> index
      %24 = "arith.index_cast"(%arg2) : (i32) -> index
      %25 = "arith.subi"(%23, %17) : (index, index) -> index
      %26 = "memref.get_global"() <{name = @sdata}> : () -> memref<1xf32>
      %27 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %28 = "polygeist.pointer2memref"(%27) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %29 = "arith.addi"(%arg2, %8) : (i32, i32) -> i32
      %30 = "arith.index_cast"(%23) : (index) -> i32
      %31 = "arith.muli"(%30, %1) : (i32, i32) -> i32
      %32 = "arith.index_cast"(%29) : (i32) -> index
      %33 = "arith.index_cast"(%31) : (i32) -> index
      %34 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %34) ({
      ^bb0(%arg4: index):
        %42 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "scf.if"(%20) ({
          %51 = "arith.muli"(%43, %1) : (i32, i32) -> i32
          %52 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %53 = "polygeist.memref2pointer"(%52) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %54 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
          %55 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
          %56 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
          %57 = "arith.index_cast"(%51) : (i32) -> index
          %58 = "scf.for"(%57, %32, %33, %0) ({
          ^bb0(%arg5: index, %arg6: f32):
            %59 = "arith.subi"(%arg5, %57) : (index, index) -> index
            %60 = "arith.divui"(%59, %33) : (index, index) -> index
            %61 = "arith.muli"(%60, %33) : (index, index) -> index
            %62 = "arith.addi"(%57, %61) : (index, index) -> index
            %63 = "arith.index_cast"(%62) : (index) -> i32
            %64 = "arith.divsi"(%63, %1) : (i32, i32) -> i32
            %65 = "arith.index_cast"(%64) : (i32) -> index
            %66 = "polygeist.subindex"(%28, %65) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            "func.call"(%42, %66) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %67 = "llvm.load"(%53) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %68 = "llvm.load"(%54) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %69 = "arith.addf"(%67, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %70 = "llvm.load"(%55) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %71 = "arith.addf"(%69, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %72 = "llvm.load"(%56) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %73 = "arith.addf"(%71, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %74 = "arith.addf"(%arg6, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "scf.yield"(%74) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          "scf.yield"(%58) : (f32) -> ()
        }, {
          "scf.yield"(%0) : (f32) -> ()
        }) : (i1) -> f32
        %45 = "arith.addi"(%43, %22) : (i32, i32) -> i32
        %46 = "arith.index_cast"(%45) : (i32) -> index
        %47 = "arith.subi"(%24, %46) : (index, index) -> index
        %48 = "arith.addi"(%25, %47) : (index, index) -> index
        %49 = "arith.divui"(%48, %23) : (index, index) -> index
        %50 = "scf.for"(%16, %49, %17, %44) ({
        ^bb0(%arg5: index, %arg6: f32):
          %51 = "arith.muli"(%arg5, %23) : (index, index) -> index
          %52 = "arith.addi"(%51, %46) : (index, index) -> index
          %53 = "memref.load"(%arg0, %52) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %54 = "arith.addf"(%arg6, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%54) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%50, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %35 = "arith.cmpi"(%30, %2) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %36 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %36) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %3) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%35, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %9) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %37 = "arith.cmpi"(%30, %3) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %38 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %38) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %4) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%37, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %39 = "arith.cmpi"(%30, %4) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %40 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %40) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %5) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%39, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %41 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %41) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %7) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %44 = "arith.cmpi"(%42, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %49 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %50 = "memref.load"(%26, %49) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %51 = "arith.addf"(%48, %50) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%51, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %52 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %53 = "memref.load"(%26, %52) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %54 = "arith.addf"(%51, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%54, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %55 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %56 = "memref.load"(%26, %55) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %57 = "arith.addf"(%54, %56) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%57, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %58 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %59 = "memref.load"(%26, %58) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %60 = "arith.addf"(%57, %59) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%60, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %61 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %62 = "memref.load"(%26, %61) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %63 = "arith.addf"(%60, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%43) ({
          %45 = "memref.load"(%26, %16) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %46 = "arith.mulf"(%45, %arg3) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%46, %arg1, %16) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif_1"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
MemRefAllocaToNPULowering: module: end
[ict-debug] MemRefAllocaToNPULowering: process op: 

%30 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
[ict-debug] MemRefAllocaToNPULowering: memory space is 5

MemRefAllocaToNPULowering: newAllocaOp: 
%30 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
MemRefAllocaToNPULowering: old allocaOp: 
%31 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
MemRefAllocaToNPULowering: module: 
"builtin.module"() ({
  "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32):
      %0 = "arith.constant"() <{value = 8 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %2 = "arith.constant"() <{value = 7 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 2 : index}> : () -> index
      %11 = "arith.constant"() <{value = 256 : index}> : () -> index
      %12 = "arith.constant"() <{value = 128 : index}> : () -> index
      %13 = "arith.constant"() <{value = 64 : index}> : () -> index
      %14 = "arith.constant"() <{value = 16 : index}> : () -> index
      %15 = "arith.constant"() <{value = 8 : index}> : () -> index
      %16 = "arith.constant"() <{value = 4 : index}> : () -> index
      %17 = "arith.constant"() <{value = 0 : index}> : () -> index
      %18 = "arith.constant"() <{value = 1 : index}> : () -> index
      %19 = "arith.constant"() <{value = 32 : index}> : () -> index
      %20 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %21 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1xf32, 5>
      %22 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %23 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %24 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %25 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %26 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %27 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %28 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %29 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %30 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %31 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %32 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %33 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %34 = "arith.index_cast"(%33) : (index) -> i32
      %35 = "arith.constant"() <{value = 32 : index}> : () -> index
      %36 = "arith.index_cast"(%35) : (index) -> i32
      %37 = "arith.muli"(%34, %36) : (i32, i32) -> i32
      %38 = "arith.muli"(%37, %0) : (i32, i32) -> i32
      %39 = "npu.block_num"() : () -> i64
      %40 = "arith.index_cast"(%39) : (i64) -> i32
      %41 = "arith.muli"(%36, %40) : (i32, i32) -> i32
      %42 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %43 = "polygeist.pointer2memref"(%42) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %44 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %45 = "polygeist.pointer2memref"(%44) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %46 = "arith.muli"(%36, %2) : (i32, i32) -> i32
      %47 = "arith.index_cast"(%arg3) : (i32) -> index
      %48 = "arith.index_cast"(%41) : (i32) -> index
      %49 = "arith.subi"(%48, %18) : (index, index) -> index
      %50 = "arith.muli"(%41, %0) : (i32, i32) -> i32
      %51 = "llvm.mlir.undef"() : () -> f32
      %52 = "llvm.mlir.undef"() : () -> i32
      %53 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %53) ({
      ^bb0(%arg4: index):
        %61 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %62 = "polygeist.subindex"(%27, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %63 = "arith.index_cast"(%arg4) : (index) -> i32
        %64 = "arith.addi"(%38, %63) : (i32, i32) -> i32
        %65 = "arith.addi"(%64, %46) : (i32, i32) -> i32
        %66:4 = "scf.while"(%1, %65) ({
        ^bb0(%arg5: f32, %arg6: i32):
          %72 = "arith.subi"(%arg6, %46) : (i32, i32) -> i32
          %73 = "arith.cmpi"(%arg6, %arg3) <{predicate = 6 : i64}> : (i32, i32) -> i1
          %74 = "arith.select"(%73, %51, %arg5) : (i1, f32, f32) -> f32
          %75 = "arith.select"(%73, %52, %72) : (i1, i32, i32) -> i32
          %76:2 = "scf.if"(%73) ({
            %77 = "polygeist.subindex"(%27, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %78 = "polygeist.memref2pointer"(%77) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %79 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %80 = "polygeist.memref2pointer"(%79) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %81 = "llvm.getelementptr"(%78) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %82 = "llvm.getelementptr"(%80) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %83 = "llvm.getelementptr"(%78) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %84 = "llvm.getelementptr"(%80) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %85 = "llvm.getelementptr"(%78) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %86 = "llvm.getelementptr"(%80) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %87 = "scf.for"(%17, %10, %18, %arg5) ({
            ^bb0(%arg7: index, %arg8: f32):
              %89 = "arith.index_cast"(%arg7) : (index) -> i32
              %90 = "arith.muli"(%89, %4) : (i32, i32) -> i32
              %91 = "arith.muli"(%90, %36) : (i32, i32) -> i32
              %92 = "arith.addi"(%72, %91) : (i32, i32) -> i32
              %93 = "arith.divui"(%92, %4) : (i32, i32) -> i32
              %94 = "arith.index_cast"(%93) : (i32) -> index
              %95 = "polygeist.subindex"(%43, %94) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%62, %95) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %96 = "polygeist.subindex"(%45, %94) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%61, %96) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %97 = "llvm.load"(%78) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %98 = "math.exp"(%97) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %99 = "llvm.load"(%80) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %100 = "arith.mulf"(%99, %97) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %101 = "arith.subf"(%98, %100) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %102 = "arith.addf"(%arg8, %101) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %103 = "llvm.load"(%81) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %104 = "math.exp"(%103) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %105 = "llvm.load"(%82) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %106 = "arith.mulf"(%105, %103) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %107 = "arith.subf"(%104, %106) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %108 = "arith.addf"(%102, %107) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %109 = "llvm.load"(%83) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %110 = "math.exp"(%109) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %111 = "llvm.load"(%84) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %112 = "arith.mulf"(%111, %109) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %113 = "arith.subf"(%110, %112) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %114 = "arith.addf"(%108, %113) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %115 = "llvm.load"(%85) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %116 = "math.exp"(%115) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %117 = "llvm.load"(%86) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %118 = "arith.mulf"(%117, %115) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %119 = "arith.subf"(%116, %118) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %120 = "arith.addf"(%114, %119) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              "scf.yield"(%120) : (f32) -> ()
            }) : (index, index, index, f32) -> f32
            %88 = "arith.addi"(%72, %50) : (i32, i32) -> i32
            "scf.yield"(%87, %88) : (f32, i32) -> ()
          }, {
            "scf.yield"(%arg5, %72) : (f32, i32) -> ()
          }) : (i1) -> (f32, i32)
          "scf.condition"(%73, %76#0, %76#1, %74, %75) : (i1, f32, i32, f32, i32) -> ()
        }, {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %72 = "arith.addi"(%arg6, %46) : (i32, i32) -> i32
          "scf.yield"(%arg5, %72) : (f32, i32) -> ()
        }) : (f32, i32) -> (f32, i32, f32, i32)
        %67 = "arith.index_cast"(%66#3) : (i32) -> index
        %68 = "arith.subi"(%47, %67) : (index, index) -> index
        %69 = "arith.addi"(%49, %68) : (index, index) -> index
        %70 = "arith.divui"(%69, %48) : (index, index) -> index
        %71 = "scf.for"(%17, %70, %18, %66#2) ({
        ^bb0(%arg5: index, %arg6: f32):
          %72 = "arith.muli"(%arg5, %48) : (index, index) -> index
          %73 = "arith.addi"(%72, %67) : (index, index) -> index
          %74 = "memref.load"(%arg0, %73) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %75 = "memref.load"(%arg1, %73) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %76 = "math.exp"(%74) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          %77 = "arith.mulf"(%75, %74) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %78 = "arith.subf"(%76, %77) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %79 = "arith.addf"(%arg6, %78) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%79) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%71, %23, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "memref.store"(%71, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %54 = "arith.cmpi"(%36, %5) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %55 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %55) ({
      ^bb0(%arg4: index):
        %61 = "memref.load"(%23, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %62 = "arith.index_cast"(%arg4) : (index) -> i32
        %63 = "arith.cmpi"(%62, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %64 = "arith.andi"(%54, %63) : (i1, i1) -> i1
        %65 = "scf.if"(%64) ({
          %66 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %67 = "memref.load"(%21, %66) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %68 = "arith.addf"(%61, %67) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%68, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%68) : (f32) -> ()
        }, {
          "scf.yield"(%61) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%65, %29, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %56 = "arith.cmpi"(%36, %6) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %57 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %57) ({
      ^bb0(%arg4: index):
        %61 = "memref.load"(%29, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %62 = "arith.index_cast"(%arg4) : (index) -> i32
        %63 = "arith.cmpi"(%62, %7) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %64 = "arith.andi"(%56, %63) : (i1, i1) -> i1
        %65 = "scf.if"(%64) ({
          %66 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %67 = "memref.load"(%21, %66) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %68 = "arith.addf"(%61, %67) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%68, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%68) : (f32) -> ()
        }, {
          "scf.yield"(%61) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%65, %31, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %58 = "arith.cmpi"(%36, %7) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %59 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %59) ({
      ^bb0(%arg4: index):
        %61 = "memref.load"(%31, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %62 = "arith.index_cast"(%arg4) : (index) -> i32
        %63 = "arith.cmpi"(%62, %8) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %64 = "arith.andi"(%58, %63) : (i1, i1) -> i1
        %65 = "scf.if"(%64) ({
          %66 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %67 = "memref.load"(%21, %66) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %68 = "arith.addf"(%61, %67) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%68, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%68) : (f32) -> ()
        }, {
          "scf.yield"(%61) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%65, %32, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %60 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %60) ({
      ^bb0(%arg4: index):
        %61 = "memref.load"(%32, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %62 = "arith.index_cast"(%arg4) : (index) -> i32
        %63 = "arith.cmpi"(%62, %3) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %64 = "arith.cmpi"(%62, %9) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%64) ({
          %65 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %66 = "memref.load"(%21, %65) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %67 = "arith.addf"(%61, %66) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%67, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %68 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %69 = "memref.load"(%21, %68) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %70 = "arith.addf"(%67, %69) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%70, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %71 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %72 = "memref.load"(%21, %71) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %73 = "arith.addf"(%70, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%73, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %74 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %75 = "memref.load"(%21, %74) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %76 = "arith.addf"(%73, %75) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%76, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %77 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %78 = "memref.load"(%21, %77) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %79 = "arith.addf"(%76, %78) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%79, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %80 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %81 = "memref.load"(%21, %80) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %82 = "arith.addf"(%79, %81) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%82, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%63) ({
          %65 = "memref.load"(%21, %17) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          "memref.store"(%65, %arg2, %33) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, f32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32):
      %0 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %1 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = -3 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 256 : index}> : () -> index
      %10 = "arith.constant"() <{value = 128 : index}> : () -> index
      %11 = "arith.constant"() <{value = 64 : index}> : () -> index
      %12 = "arith.constant"() <{value = 16 : index}> : () -> index
      %13 = "arith.constant"() <{value = 8 : index}> : () -> index
      %14 = "arith.constant"() <{value = 4 : index}> : () -> index
      %15 = "arith.constant"() <{value = 2 : index}> : () -> index
      %16 = "arith.constant"() <{value = 0 : index}> : () -> index
      %17 = "arith.constant"() <{value = 1 : index}> : () -> index
      %18 = "arith.constant"() <{value = 32 : index}> : () -> index
      %19 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %20 = "arith.cmpi"(%arg2, %1) <{predicate = 5 : i64}> : (i32, i32) -> i1
      %21 = "arith.divsi"(%arg2, %1) : (i32, i32) -> i32
      %22 = "arith.muli"(%21, %1) : (i32, i32) -> i32
      %23 = "arith.constant"() <{value = 32 : index}> : () -> index
      %24 = "arith.index_cast"(%arg2) : (i32) -> index
      %25 = "arith.subi"(%23, %17) : (index, index) -> index
      %26 = "memref.get_global"() <{name = @sdata}> : () -> memref<1xf32>
      %27 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %28 = "polygeist.pointer2memref"(%27) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %29 = "arith.addi"(%arg2, %8) : (i32, i32) -> i32
      %30 = "arith.index_cast"(%23) : (index) -> i32
      %31 = "arith.muli"(%30, %1) : (i32, i32) -> i32
      %32 = "arith.index_cast"(%29) : (i32) -> index
      %33 = "arith.index_cast"(%31) : (i32) -> index
      %34 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %34) ({
      ^bb0(%arg4: index):
        %42 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "scf.if"(%20) ({
          %51 = "arith.muli"(%43, %1) : (i32, i32) -> i32
          %52 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %53 = "polygeist.memref2pointer"(%52) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %54 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
          %55 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
          %56 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
          %57 = "arith.index_cast"(%51) : (i32) -> index
          %58 = "scf.for"(%57, %32, %33, %0) ({
          ^bb0(%arg5: index, %arg6: f32):
            %59 = "arith.subi"(%arg5, %57) : (index, index) -> index
            %60 = "arith.divui"(%59, %33) : (index, index) -> index
            %61 = "arith.muli"(%60, %33) : (index, index) -> index
            %62 = "arith.addi"(%57, %61) : (index, index) -> index
            %63 = "arith.index_cast"(%62) : (index) -> i32
            %64 = "arith.divsi"(%63, %1) : (i32, i32) -> i32
            %65 = "arith.index_cast"(%64) : (i32) -> index
            %66 = "polygeist.subindex"(%28, %65) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            "func.call"(%42, %66) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %67 = "llvm.load"(%53) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %68 = "llvm.load"(%54) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %69 = "arith.addf"(%67, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %70 = "llvm.load"(%55) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %71 = "arith.addf"(%69, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %72 = "llvm.load"(%56) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %73 = "arith.addf"(%71, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %74 = "arith.addf"(%arg6, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "scf.yield"(%74) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          "scf.yield"(%58) : (f32) -> ()
        }, {
          "scf.yield"(%0) : (f32) -> ()
        }) : (i1) -> f32
        %45 = "arith.addi"(%43, %22) : (i32, i32) -> i32
        %46 = "arith.index_cast"(%45) : (i32) -> index
        %47 = "arith.subi"(%24, %46) : (index, index) -> index
        %48 = "arith.addi"(%25, %47) : (index, index) -> index
        %49 = "arith.divui"(%48, %23) : (index, index) -> index
        %50 = "scf.for"(%16, %49, %17, %44) ({
        ^bb0(%arg5: index, %arg6: f32):
          %51 = "arith.muli"(%arg5, %23) : (index, index) -> index
          %52 = "arith.addi"(%51, %46) : (index, index) -> index
          %53 = "memref.load"(%arg0, %52) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %54 = "arith.addf"(%arg6, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%54) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%50, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %35 = "arith.cmpi"(%30, %2) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %36 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %36) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %3) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%35, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %9) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %37 = "arith.cmpi"(%30, %3) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %38 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %38) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %4) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%37, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %39 = "arith.cmpi"(%30, %4) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %40 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %40) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %5) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%39, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %41 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %41) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %7) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %44 = "arith.cmpi"(%42, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %49 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %50 = "memref.load"(%26, %49) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %51 = "arith.addf"(%48, %50) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%51, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %52 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %53 = "memref.load"(%26, %52) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %54 = "arith.addf"(%51, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%54, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %55 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %56 = "memref.load"(%26, %55) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %57 = "arith.addf"(%54, %56) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%57, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %58 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %59 = "memref.load"(%26, %58) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %60 = "arith.addf"(%57, %59) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%60, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %61 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %62 = "memref.load"(%26, %61) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %63 = "arith.addf"(%60, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%43) ({
          %45 = "memref.load"(%26, %16) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %46 = "arith.mulf"(%45, %arg3) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%46, %arg1, %16) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif_1"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
MemRefAllocaToNPULowering: module: end
[ict-debug] MemRefAllocaToNPULowering: process op: 

%32 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
[ict-debug] MemRefAllocaToNPULowering: memory space is 5

MemRefAllocaToNPULowering: newAllocaOp: 
%32 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
MemRefAllocaToNPULowering: old allocaOp: 
%33 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
MemRefAllocaToNPULowering: module: 
"builtin.module"() ({
  "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32):
      %0 = "arith.constant"() <{value = 8 : i32}> : () -> i32
      %1 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %2 = "arith.constant"() <{value = 7 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 2 : index}> : () -> index
      %11 = "arith.constant"() <{value = 256 : index}> : () -> index
      %12 = "arith.constant"() <{value = 128 : index}> : () -> index
      %13 = "arith.constant"() <{value = 64 : index}> : () -> index
      %14 = "arith.constant"() <{value = 16 : index}> : () -> index
      %15 = "arith.constant"() <{value = 8 : index}> : () -> index
      %16 = "arith.constant"() <{value = 4 : index}> : () -> index
      %17 = "arith.constant"() <{value = 0 : index}> : () -> index
      %18 = "arith.constant"() <{value = 1 : index}> : () -> index
      %19 = "arith.constant"() <{value = 32 : index}> : () -> index
      %20 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %21 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<1xf32, 5>
      %22 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %23 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %24 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %25 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %26 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %27 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %28 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %29 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %30 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %31 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %32 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %33 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32xf32, 5>
      %34 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
      %35 = "arith.index_cast"(%34) : (index) -> i32
      %36 = "arith.constant"() <{value = 32 : index}> : () -> index
      %37 = "arith.index_cast"(%36) : (index) -> i32
      %38 = "arith.muli"(%35, %37) : (i32, i32) -> i32
      %39 = "arith.muli"(%38, %0) : (i32, i32) -> i32
      %40 = "npu.block_num"() : () -> i64
      %41 = "arith.index_cast"(%40) : (i64) -> i32
      %42 = "arith.muli"(%37, %41) : (i32, i32) -> i32
      %43 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %44 = "polygeist.pointer2memref"(%43) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %45 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %46 = "polygeist.pointer2memref"(%45) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %47 = "arith.muli"(%37, %2) : (i32, i32) -> i32
      %48 = "arith.index_cast"(%arg3) : (i32) -> index
      %49 = "arith.index_cast"(%42) : (i32) -> index
      %50 = "arith.subi"(%49, %18) : (index, index) -> index
      %51 = "arith.muli"(%42, %0) : (i32, i32) -> i32
      %52 = "llvm.mlir.undef"() : () -> f32
      %53 = "llvm.mlir.undef"() : () -> i32
      %54 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %54) ({
      ^bb0(%arg4: index):
        %62 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %63 = "polygeist.subindex"(%27, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %64 = "arith.index_cast"(%arg4) : (index) -> i32
        %65 = "arith.addi"(%39, %64) : (i32, i32) -> i32
        %66 = "arith.addi"(%65, %47) : (i32, i32) -> i32
        %67:4 = "scf.while"(%1, %66) ({
        ^bb0(%arg5: f32, %arg6: i32):
          %73 = "arith.subi"(%arg6, %47) : (i32, i32) -> i32
          %74 = "arith.cmpi"(%arg6, %arg3) <{predicate = 6 : i64}> : (i32, i32) -> i1
          %75 = "arith.select"(%74, %52, %arg5) : (i1, f32, f32) -> f32
          %76 = "arith.select"(%74, %53, %73) : (i1, i32, i32) -> i32
          %77:2 = "scf.if"(%74) ({
            %78 = "polygeist.subindex"(%27, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %79 = "polygeist.memref2pointer"(%78) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %80 = "polygeist.subindex"(%25, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            %81 = "polygeist.memref2pointer"(%80) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
            %82 = "llvm.getelementptr"(%79) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %83 = "llvm.getelementptr"(%81) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %84 = "llvm.getelementptr"(%79) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %85 = "llvm.getelementptr"(%81) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %86 = "llvm.getelementptr"(%79) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %87 = "llvm.getelementptr"(%81) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %88 = "scf.for"(%17, %10, %18, %arg5) ({
            ^bb0(%arg7: index, %arg8: f32):
              %90 = "arith.index_cast"(%arg7) : (index) -> i32
              %91 = "arith.muli"(%90, %4) : (i32, i32) -> i32
              %92 = "arith.muli"(%91, %37) : (i32, i32) -> i32
              %93 = "arith.addi"(%73, %92) : (i32, i32) -> i32
              %94 = "arith.divui"(%93, %4) : (i32, i32) -> i32
              %95 = "arith.index_cast"(%94) : (i32) -> index
              %96 = "polygeist.subindex"(%44, %95) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%63, %96) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %97 = "polygeist.subindex"(%46, %95) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%62, %97) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %98 = "llvm.load"(%79) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %99 = "math.exp"(%98) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %100 = "llvm.load"(%81) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %101 = "arith.mulf"(%100, %98) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %102 = "arith.subf"(%99, %101) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %103 = "arith.addf"(%arg8, %102) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %104 = "llvm.load"(%82) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %105 = "math.exp"(%104) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %106 = "llvm.load"(%83) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %107 = "arith.mulf"(%106, %104) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %108 = "arith.subf"(%105, %107) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %109 = "arith.addf"(%103, %108) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %110 = "llvm.load"(%84) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %111 = "math.exp"(%110) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %112 = "llvm.load"(%85) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %113 = "arith.mulf"(%112, %110) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %114 = "arith.subf"(%111, %113) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %115 = "arith.addf"(%109, %114) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %116 = "llvm.load"(%86) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %117 = "math.exp"(%116) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
              %118 = "llvm.load"(%87) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %119 = "arith.mulf"(%118, %116) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %120 = "arith.subf"(%117, %119) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              %121 = "arith.addf"(%115, %120) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
              "scf.yield"(%121) : (f32) -> ()
            }) : (index, index, index, f32) -> f32
            %89 = "arith.addi"(%73, %51) : (i32, i32) -> i32
            "scf.yield"(%88, %89) : (f32, i32) -> ()
          }, {
            "scf.yield"(%arg5, %73) : (f32, i32) -> ()
          }) : (i1) -> (f32, i32)
          "scf.condition"(%74, %77#0, %77#1, %75, %76) : (i1, f32, i32, f32, i32) -> ()
        }, {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %73 = "arith.addi"(%arg6, %47) : (i32, i32) -> i32
          "scf.yield"(%arg5, %73) : (f32, i32) -> ()
        }) : (f32, i32) -> (f32, i32, f32, i32)
        %68 = "arith.index_cast"(%67#3) : (i32) -> index
        %69 = "arith.subi"(%48, %68) : (index, index) -> index
        %70 = "arith.addi"(%50, %69) : (index, index) -> index
        %71 = "arith.divui"(%70, %49) : (index, index) -> index
        %72 = "scf.for"(%17, %71, %18, %67#2) ({
        ^bb0(%arg5: index, %arg6: f32):
          %73 = "arith.muli"(%arg5, %49) : (index, index) -> index
          %74 = "arith.addi"(%73, %68) : (index, index) -> index
          %75 = "memref.load"(%arg0, %74) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %76 = "memref.load"(%arg1, %74) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %77 = "math.exp"(%75) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
          %78 = "arith.mulf"(%76, %75) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %79 = "arith.subf"(%77, %78) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          %80 = "arith.addf"(%arg6, %79) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%80) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%72, %23, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "memref.store"(%72, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %55 = "arith.cmpi"(%37, %5) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %56 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %56) ({
      ^bb0(%arg4: index):
        %62 = "memref.load"(%23, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %63 = "arith.index_cast"(%arg4) : (index) -> i32
        %64 = "arith.cmpi"(%63, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %65 = "arith.andi"(%55, %64) : (i1, i1) -> i1
        %66 = "scf.if"(%65) ({
          %67 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %68 = "memref.load"(%21, %67) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %69 = "arith.addf"(%62, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%69, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%69) : (f32) -> ()
        }, {
          "scf.yield"(%62) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%66, %29, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %57 = "arith.cmpi"(%37, %6) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %58 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %58) ({
      ^bb0(%arg4: index):
        %62 = "memref.load"(%29, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %63 = "arith.index_cast"(%arg4) : (index) -> i32
        %64 = "arith.cmpi"(%63, %7) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %65 = "arith.andi"(%57, %64) : (i1, i1) -> i1
        %66 = "scf.if"(%65) ({
          %67 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %68 = "memref.load"(%21, %67) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %69 = "arith.addf"(%62, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%69, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%69) : (f32) -> ()
        }, {
          "scf.yield"(%62) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%66, %31, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %59 = "arith.cmpi"(%37, %7) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %60 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %60) ({
      ^bb0(%arg4: index):
        %62 = "memref.load"(%31, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %63 = "arith.index_cast"(%arg4) : (index) -> i32
        %64 = "arith.cmpi"(%63, %8) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %65 = "arith.andi"(%59, %64) : (i1, i1) -> i1
        %66 = "scf.if"(%65) ({
          %67 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %68 = "memref.load"(%21, %67) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %69 = "arith.addf"(%62, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%69, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%69) : (f32) -> ()
        }, {
          "scf.yield"(%62) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%66, %33, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %61 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %61) ({
      ^bb0(%arg4: index):
        %62 = "memref.load"(%33, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %63 = "arith.index_cast"(%arg4) : (index) -> i32
        %64 = "arith.cmpi"(%63, %3) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %65 = "arith.cmpi"(%63, %9) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%65) ({
          %66 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %67 = "memref.load"(%21, %66) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %68 = "arith.addf"(%62, %67) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%68, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %69 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %70 = "memref.load"(%21, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "arith.addf"(%68, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%71, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %72 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %73 = "memref.load"(%21, %72) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %74 = "arith.addf"(%71, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%74, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %75 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %76 = "memref.load"(%21, %75) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %77 = "arith.addf"(%74, %76) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%77, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %78 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %79 = "memref.load"(%21, %78) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %80 = "arith.addf"(%77, %79) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%80, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %81 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %82 = "memref.load"(%21, %81) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %83 = "arith.addf"(%80, %82) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%83, %21, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%64) ({
          %66 = "memref.load"(%21, %17) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          "memref.store"(%66, %arg2, %34) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, f32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32):
      %0 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %1 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = -3 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 256 : index}> : () -> index
      %10 = "arith.constant"() <{value = 128 : index}> : () -> index
      %11 = "arith.constant"() <{value = 64 : index}> : () -> index
      %12 = "arith.constant"() <{value = 16 : index}> : () -> index
      %13 = "arith.constant"() <{value = 8 : index}> : () -> index
      %14 = "arith.constant"() <{value = 4 : index}> : () -> index
      %15 = "arith.constant"() <{value = 2 : index}> : () -> index
      %16 = "arith.constant"() <{value = 0 : index}> : () -> index
      %17 = "arith.constant"() <{value = 1 : index}> : () -> index
      %18 = "arith.constant"() <{value = 32 : index}> : () -> index
      %19 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %20 = "arith.cmpi"(%arg2, %1) <{predicate = 5 : i64}> : (i32, i32) -> i1
      %21 = "arith.divsi"(%arg2, %1) : (i32, i32) -> i32
      %22 = "arith.muli"(%21, %1) : (i32, i32) -> i32
      %23 = "arith.constant"() <{value = 32 : index}> : () -> index
      %24 = "arith.index_cast"(%arg2) : (i32) -> index
      %25 = "arith.subi"(%23, %17) : (index, index) -> index
      %26 = "memref.get_global"() <{name = @sdata}> : () -> memref<1xf32>
      %27 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %28 = "polygeist.pointer2memref"(%27) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %29 = "arith.addi"(%arg2, %8) : (i32, i32) -> i32
      %30 = "arith.index_cast"(%23) : (index) -> i32
      %31 = "arith.muli"(%30, %1) : (i32, i32) -> i32
      %32 = "arith.index_cast"(%29) : (i32) -> index
      %33 = "arith.index_cast"(%31) : (i32) -> index
      %34 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %34) ({
      ^bb0(%arg4: index):
        %42 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "scf.if"(%20) ({
          %51 = "arith.muli"(%43, %1) : (i32, i32) -> i32
          %52 = "polygeist.subindex"(%19, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %53 = "polygeist.memref2pointer"(%52) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %54 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
          %55 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
          %56 = "llvm.getelementptr"(%53) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
          %57 = "arith.index_cast"(%51) : (i32) -> index
          %58 = "scf.for"(%57, %32, %33, %0) ({
          ^bb0(%arg5: index, %arg6: f32):
            %59 = "arith.subi"(%arg5, %57) : (index, index) -> index
            %60 = "arith.divui"(%59, %33) : (index, index) -> index
            %61 = "arith.muli"(%60, %33) : (index, index) -> index
            %62 = "arith.addi"(%57, %61) : (index, index) -> index
            %63 = "arith.index_cast"(%62) : (index) -> i32
            %64 = "arith.divsi"(%63, %1) : (i32, i32) -> i32
            %65 = "arith.index_cast"(%64) : (i32) -> index
            %66 = "polygeist.subindex"(%28, %65) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            "func.call"(%42, %66) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %67 = "llvm.load"(%53) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %68 = "llvm.load"(%54) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %69 = "arith.addf"(%67, %68) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %70 = "llvm.load"(%55) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %71 = "arith.addf"(%69, %70) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %72 = "llvm.load"(%56) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %73 = "arith.addf"(%71, %72) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %74 = "arith.addf"(%arg6, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "scf.yield"(%74) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          "scf.yield"(%58) : (f32) -> ()
        }, {
          "scf.yield"(%0) : (f32) -> ()
        }) : (i1) -> f32
        %45 = "arith.addi"(%43, %22) : (i32, i32) -> i32
        %46 = "arith.index_cast"(%45) : (i32) -> index
        %47 = "arith.subi"(%24, %46) : (index, index) -> index
        %48 = "arith.addi"(%25, %47) : (index, index) -> index
        %49 = "arith.divui"(%48, %23) : (index, index) -> index
        %50 = "scf.for"(%16, %49, %17, %44) ({
        ^bb0(%arg5: index, %arg6: f32):
          %51 = "arith.muli"(%arg5, %23) : (index, index) -> index
          %52 = "arith.addi"(%51, %46) : (index, index) -> index
          %53 = "memref.load"(%arg0, %52) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %54 = "arith.addf"(%arg6, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%54) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%50, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %35 = "arith.cmpi"(%30, %2) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %36 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %36) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %3) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%35, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %9) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %37 = "arith.cmpi"(%30, %3) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %38 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %38) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %4) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%37, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %39 = "arith.cmpi"(%30, %4) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %40 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %40) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %5) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %44 = "arith.andi"(%39, %43) : (i1, i1) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %41 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %41) ({
      ^bb0(%arg4: index):
        %42 = "arith.index_cast"(%arg4) : (index) -> i32
        %43 = "arith.cmpi"(%42, %7) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %44 = "arith.cmpi"(%42, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%44) ({
          %45 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %46 = "memref.load"(%26, %45) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "memref.load"(%26, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "arith.addf"(%47, %46) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%48, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %49 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %50 = "memref.load"(%26, %49) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %51 = "arith.addf"(%48, %50) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%51, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %52 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %53 = "memref.load"(%26, %52) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %54 = "arith.addf"(%51, %53) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%54, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %55 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %56 = "memref.load"(%26, %55) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %57 = "arith.addf"(%54, %56) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%57, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %58 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %59 = "memref.load"(%26, %58) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %60 = "arith.addf"(%57, %59) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%60, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %61 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %62 = "memref.load"(%26, %61) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %63 = "arith.addf"(%60, %62) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%63, %26, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%43) ({
          %45 = "memref.load"(%26, %16) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %46 = "arith.mulf"(%45, %arg3) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%46, %arg1, %16) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif_1"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
MemRefAllocaToNPULowering: module: end
[ict-debug] GPUBlockIdToNPULowering: process op: 

%34 = "gpu.block_id"() <{dimension = #gpu<dim x>}> : () -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%36 = "arith.index_cast"(%35) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%44 = "arith.index_cast"(%43) : (i64) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%58 = "arith.index_cast"(%arg3) : (i32) -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%60 = "arith.index_cast"(%48) : (i32) -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%83 = "arith.index_cast"(%arg4) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%119 = "arith.index_cast"(%arg7) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%125 = "arith.index_cast"(%124) : (i32) -> index
[ict-debug] ArithUnaryOpToNPULowering: process op: 

%135 = "math.exp"(%134) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
[ict-debug] ArithUnaryOpToNPULowering: met scalar unary op, need vector help process.

[ict-debug] ArithUnaryOpToNPULowering: process op: 

%145 = "math.exp"(%144) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
[ict-debug] ArithUnaryOpToNPULowering: met scalar unary op, need vector help process.

[ict-debug] ArithUnaryOpToNPULowering: process op: 

%155 = "math.exp"(%154) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
[ict-debug] ArithUnaryOpToNPULowering: met scalar unary op, need vector help process.

[ict-debug] ArithUnaryOpToNPULowering: process op: 

%165 = "math.exp"(%164) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
[ict-debug] ArithUnaryOpToNPULowering: met scalar unary op, need vector help process.

[ict-debug] CastLikeOpToNPULowering: process op: 

%88 = "arith.index_cast"(%87#3) : (i32) -> index
[ict-debug] ArithUnaryOpToNPULowering: process op: 

%98 = "math.exp"(%96) <{fastmath = #arith.fastmath<none>}> : (f32) -> f32
[ict-debug] ArithUnaryOpToNPULowering: met scalar unary op, need vector help process.

[ict-debug] CastLikeOpToNPULowering: process op: 

%76 = "arith.index_cast"(%arg4) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%76 = "arith.index_cast"(%arg4) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%76 = "arith.index_cast"(%arg4) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%76 = "arith.index_cast"(%arg4) : (index) -> i32
[ict-debug] MemRefAllocaToNPULowering: process op: 

%alloca = memref.alloca() : memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
[ict-debug] MemRefAllocaToNPULowering: memory space is 5

MemRefAllocaToNPULowering: newAllocaOp: 
%0 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
MemRefAllocaToNPULowering: old allocaOp: 
%alloca = memref.alloca() : memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
MemRefAllocaToNPULowering: module: 
"builtin.module"() ({
  "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32):
      %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %1 = "builtin.unrealized_conversion_cast"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %2 = "arith.constant"() <{value = 8 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %4 = "arith.constant"() <{value = 7 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %11 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %12 = "arith.constant"() <{value = 2 : index}> : () -> index
      %13 = "arith.constant"() <{value = 256 : index}> : () -> index
      %14 = "arith.constant"() <{value = 128 : index}> : () -> index
      %15 = "arith.constant"() <{value = 64 : index}> : () -> index
      %16 = "arith.constant"() <{value = 16 : index}> : () -> index
      %17 = "arith.constant"() <{value = 8 : index}> : () -> index
      %18 = "arith.constant"() <{value = 4 : index}> : () -> index
      %19 = "arith.constant"() <{value = 0 : index}> : () -> index
      %20 = "arith.constant"() <{value = 1 : index}> : () -> index
      %21 = "arith.constant"() <{value = 32 : index}> : () -> index
      %22 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %23 = "builtin.unrealized_conversion_cast"(%22) : (!llvm.ptr<6>) -> memref<1xf32, 5>
      %24 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %25 = "builtin.unrealized_conversion_cast"(%24) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %26 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %27 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %28 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %29 = "builtin.unrealized_conversion_cast"(%28) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %30 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %31 = "builtin.unrealized_conversion_cast"(%30) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %32 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %33 = "builtin.unrealized_conversion_cast"(%32) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %34 = "npu.block_id"() : () -> i64
      %35 = "builtin.unrealized_conversion_cast"(%34) : (i64) -> index
      %36 = "emitc.cast"(%34) : (i64) -> i32
      %37 = "arith.constant"() <{value = 32 : index}> : () -> index
      %38 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %39 = "arith.muli"(%36, %38) : (i32, i32) -> i32
      %40 = "arith.muli"(%39, %2) : (i32, i32) -> i32
      %41 = "npu.block_num"() : () -> i64
      %42 = "emitc.cast"(%41) : (i64) -> i32
      %43 = "arith.muli"(%38, %42) : (i32, i32) -> i32
      %44 = "llvm.bitcast"(%0) : (!llvm.ptr) -> !llvm.ptr
      %45 = "llvm.bitcast"(%44) : (!llvm.ptr) -> !llvm.ptr
      %46 = "llvm.bitcast"(%1) : (!llvm.ptr) -> !llvm.ptr
      %47 = "llvm.bitcast"(%46) : (!llvm.ptr) -> !llvm.ptr
      %48 = "arith.muli"(%38, %4) : (i32, i32) -> i32
      %49 = "emitc.cast"(%arg3) : (i32) -> index
      %50 = "emitc.cast"(%43) : (i32) -> index
      %51 = "arith.subi"(%50, %20) : (index, index) -> index
      %52 = "arith.muli"(%43, %2) : (i32, i32) -> i32
      %53 = "llvm.mlir.undef"() : () -> f32
      %54 = "llvm.mlir.undef"() : () -> i32
      %55 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %55) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "arith.constant"() <{value = 0 : i64}> : () -> i64
        %65 = "llvm.getelementptr"(%26, %63, %64) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
        %66 = "llvm.bitcast"(%65) : (!llvm.ptr<6>) -> !llvm.ptr
        %67 = "builtin.unrealized_conversion_cast"(%66) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %68 = "arith.constant"() <{value = 0 : i64}> : () -> i64
        %69 = "llvm.getelementptr"(%27, %63, %68) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
        %70 = "llvm.bitcast"(%69) : (!llvm.ptr<6>) -> !llvm.ptr
        %71 = "builtin.unrealized_conversion_cast"(%70) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %72 = "emitc.cast"(%63) : (i64) -> i32
        %73 = "arith.addi"(%40, %72) : (i32, i32) -> i32
        %74 = "arith.addi"(%73, %48) : (i32, i32) -> i32
        %75:4 = "scf.while"(%3, %74) ({
        ^bb0(%arg5: f32, %arg6: i32):
          %81 = "arith.subi"(%arg6, %48) : (i32, i32) -> i32
          %82 = "arith.cmpi"(%arg6, %arg3) <{predicate = 6 : i64}> : (i32, i32) -> i1
          %83 = "arith.select"(%82, %53, %arg5) : (i1, f32, f32) -> f32
          %84 = "arith.select"(%82, %54, %81) : (i1, i32, i32) -> i32
          %85:2 = "scf.if"(%82) ({
            %86 = "arith.constant"() <{value = 0 : i64}> : () -> i64
            %87 = "llvm.getelementptr"(%27, %63, %86) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
            %88 = "llvm.bitcast"(%87) : (!llvm.ptr<6>) -> !llvm.ptr
            %89 = "llvm.bitcast"(%88) : (!llvm.ptr) -> !llvm.ptr
            %90 = "arith.constant"() <{value = 0 : i64}> : () -> i64
            %91 = "llvm.getelementptr"(%26, %63, %90) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
            %92 = "llvm.bitcast"(%91) : (!llvm.ptr<6>) -> !llvm.ptr
            %93 = "llvm.bitcast"(%92) : (!llvm.ptr) -> !llvm.ptr
            %94 = "llvm.getelementptr"(%89) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %95 = "llvm.getelementptr"(%93) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %96 = "llvm.getelementptr"(%89) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %97 = "llvm.getelementptr"(%93) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %98 = "llvm.getelementptr"(%89) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %99 = "llvm.getelementptr"(%93) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %100 = "scf.for"(%19, %12, %20, %arg5) ({
            ^bb0(%arg7: index, %arg8: f32):
              %102 = "builtin.unrealized_conversion_cast"(%arg7) : (index) -> i64
              %103 = "emitc.cast"(%102) : (i64) -> i32
              %104 = "arith.muli"(%103, %6) : (i32, i32) -> i32
              %105 = "arith.muli"(%104, %38) : (i32, i32) -> i32
              %106 = "arith.addi"(%81, %105) : (i32, i32) -> i32
              %107 = "arith.divui"(%106, %6) : (i32, i32) -> i32
              %108 = "emitc.cast"(%107) : (i32) -> index
              %109 = "builtin.unrealized_conversion_cast"(%108) : (index) -> i64
              %110 = "llvm.getelementptr"(%45, %109) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: -2147483648>}> : (!llvm.ptr, i64) -> !llvm.ptr
              %111 = "llvm.bitcast"(%110) : (!llvm.ptr) -> !llvm.ptr
              %112 = "builtin.unrealized_conversion_cast"(%111) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%71, %112) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %113 = "llvm.getelementptr"(%47, %109) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: -2147483648>}> : (!llvm.ptr, i64) -> !llvm.ptr
              %114 = "llvm.bitcast"(%113) : (!llvm.ptr) -> !llvm.ptr
              %115 = "builtin.unrealized_conversion_cast"(%114) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%67, %115) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %116 = "llvm.load"(%89) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %117 = "emitc.call"(%116) <{callee = "expf"}> : (f32) -> f32
              %118 = "llvm.load"(%93) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %119 = "emitc.mul"(%118, %116) : (f32, f32) -> f32
              %120 = "emitc.sub"(%117, %119) : (f32, f32) -> f32
              %121 = "emitc.add"(%arg8, %120) : (f32, f32) -> f32
              %122 = "llvm.load"(%94) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %123 = "emitc.call"(%122) <{callee = "expf"}> : (f32) -> f32
              %124 = "llvm.load"(%95) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %125 = "emitc.mul"(%124, %122) : (f32, f32) -> f32
              %126 = "emitc.sub"(%123, %125) : (f32, f32) -> f32
              %127 = "emitc.add"(%121, %126) : (f32, f32) -> f32
              %128 = "llvm.load"(%96) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %129 = "emitc.call"(%128) <{callee = "expf"}> : (f32) -> f32
              %130 = "llvm.load"(%97) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %131 = "emitc.mul"(%130, %128) : (f32, f32) -> f32
              %132 = "emitc.sub"(%129, %131) : (f32, f32) -> f32
              %133 = "emitc.add"(%127, %132) : (f32, f32) -> f32
              %134 = "llvm.load"(%98) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %135 = "emitc.call"(%134) <{callee = "expf"}> : (f32) -> f32
              %136 = "llvm.load"(%99) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %137 = "emitc.mul"(%136, %134) : (f32, f32) -> f32
              %138 = "emitc.sub"(%135, %137) : (f32, f32) -> f32
              %139 = "emitc.add"(%133, %138) : (f32, f32) -> f32
              "scf.yield"(%139) : (f32) -> ()
            }) : (index, index, index, f32) -> f32
            %101 = "arith.addi"(%81, %52) : (i32, i32) -> i32
            "scf.yield"(%100, %101) : (f32, i32) -> ()
          }, {
            "scf.yield"(%arg5, %81) : (f32, i32) -> ()
          }) : (i1) -> (f32, i32)
          "scf.condition"(%82, %85#0, %85#1, %83, %84) : (i1, f32, i32, f32, i32) -> ()
        }, {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %81 = "arith.addi"(%arg6, %48) : (i32, i32) -> i32
          "scf.yield"(%arg5, %81) : (f32, i32) -> ()
        }) : (f32, i32) -> (f32, i32, f32, i32)
        %76 = "emitc.cast"(%75#3) : (i32) -> index
        %77 = "arith.subi"(%49, %76) : (index, index) -> index
        %78 = "arith.addi"(%51, %77) : (index, index) -> index
        %79 = "arith.divui"(%78, %50) : (index, index) -> index
        %80 = "scf.for"(%19, %79, %20, %75#2) ({
        ^bb0(%arg5: index, %arg6: f32):
          %81 = "arith.muli"(%arg5, %50) : (index, index) -> index
          %82 = "arith.addi"(%81, %76) : (index, index) -> index
          %83 = "memref.load"(%arg0, %82) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %84 = "memref.load"(%arg1, %82) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %85 = "emitc.call"(%83) <{callee = "expf"}> : (f32) -> f32
          %86 = "emitc.mul"(%84, %83) : (f32, f32) -> f32
          %87 = "emitc.sub"(%85, %86) : (f32, f32) -> f32
          %88 = "emitc.add"(%arg6, %87) : (f32, f32) -> f32
          "scf.yield"(%88) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%80, %25, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "memref.store"(%80, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %56 = "arith.cmpi"(%38, %7) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %57 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %57) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%25, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %8) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %67 = "arith.andi"(%56, %66) : (i1, i1) -> i1
        %68 = "scf.if"(%67) ({
          %69 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %70 = "memref.load"(%23, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "emitc.add"(%64, %70) : (f32, f32) -> f32
          "memref.store"(%71, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%71) : (f32) -> ()
        }, {
          "scf.yield"(%64) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%68, %29, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %58 = "arith.cmpi"(%38, %8) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %59 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %59) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%29, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %9) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %67 = "arith.andi"(%58, %66) : (i1, i1) -> i1
        %68 = "scf.if"(%67) ({
          %69 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %70 = "memref.load"(%23, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "emitc.add"(%64, %70) : (f32, f32) -> f32
          "memref.store"(%71, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%71) : (f32) -> ()
        }, {
          "scf.yield"(%64) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%68, %31, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %60 = "arith.cmpi"(%38, %9) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %61 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %61) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%31, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %10) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %67 = "arith.andi"(%60, %66) : (i1, i1) -> i1
        %68 = "scf.if"(%67) ({
          %69 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %70 = "memref.load"(%23, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "emitc.add"(%64, %70) : (f32, f32) -> f32
          "memref.store"(%71, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%71) : (f32) -> ()
        }, {
          "scf.yield"(%64) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%68, %33, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %62 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %62) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%33, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %5) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %67 = "arith.cmpi"(%65, %11) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%67) ({
          %68 = "arith.addi"(%arg4, %21) : (index, index) -> index
          %69 = "memref.load"(%23, %68) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %70 = "emitc.add"(%64, %69) : (f32, f32) -> f32
          "memref.store"(%70, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %71 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %72 = "memref.load"(%23, %71) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %73 = "emitc.add"(%70, %72) : (f32, f32) -> f32
          "memref.store"(%73, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %74 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %75 = "memref.load"(%23, %74) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %76 = "emitc.add"(%73, %75) : (f32, f32) -> f32
          "memref.store"(%76, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %77 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %78 = "memref.load"(%23, %77) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %79 = "emitc.add"(%76, %78) : (f32, f32) -> f32
          "memref.store"(%79, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %80 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %81 = "memref.load"(%23, %80) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %82 = "emitc.add"(%79, %81) : (f32, f32) -> f32
          "memref.store"(%82, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %83 = "arith.addi"(%arg4, %20) : (index, index) -> index
          %84 = "memref.load"(%23, %83) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %85 = "emitc.add"(%82, %84) : (f32, f32) -> f32
          "memref.store"(%85, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%66) ({
          %68 = "memref.load"(%23, %19) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          "memref.store"(%68, %arg2, %35) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, f32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32):
      %0 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %1 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %2 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = -3 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 256 : index}> : () -> index
      %10 = "arith.constant"() <{value = 128 : index}> : () -> index
      %11 = "arith.constant"() <{value = 64 : index}> : () -> index
      %12 = "arith.constant"() <{value = 16 : index}> : () -> index
      %13 = "arith.constant"() <{value = 8 : index}> : () -> index
      %14 = "arith.constant"() <{value = 4 : index}> : () -> index
      %15 = "arith.constant"() <{value = 2 : index}> : () -> index
      %16 = "arith.constant"() <{value = 0 : index}> : () -> index
      %17 = "arith.constant"() <{value = 1 : index}> : () -> index
      %18 = "arith.constant"() <{value = 32 : index}> : () -> index
      %19 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %20 = "memref.alloca"() <{operandSegmentSizes = array<i32: 0, 0>}> : () -> memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>
      %21 = "arith.cmpi"(%arg2, %1) <{predicate = 5 : i64}> : (i32, i32) -> i1
      %22 = "arith.divsi"(%arg2, %1) : (i32, i32) -> i32
      %23 = "arith.muli"(%22, %1) : (i32, i32) -> i32
      %24 = "arith.constant"() <{value = 32 : index}> : () -> index
      %25 = "arith.index_cast"(%arg2) : (i32) -> index
      %26 = "arith.subi"(%24, %17) : (index, index) -> index
      %27 = "memref.get_global"() <{name = @sdata}> : () -> memref<1xf32>
      %28 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %29 = "polygeist.pointer2memref"(%28) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %30 = "arith.addi"(%arg2, %8) : (i32, i32) -> i32
      %31 = "arith.index_cast"(%24) : (index) -> i32
      %32 = "arith.muli"(%31, %1) : (i32, i32) -> i32
      %33 = "arith.index_cast"(%30) : (i32) -> index
      %34 = "arith.index_cast"(%32) : (i32) -> index
      %35 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %35) ({
      ^bb0(%arg4: index):
        %43 = "polygeist.subindex"(%20, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %44 = "arith.index_cast"(%arg4) : (index) -> i32
        %45 = "scf.if"(%21) ({
          %52 = "arith.muli"(%44, %1) : (i32, i32) -> i32
          %53 = "polygeist.subindex"(%20, %arg4) : (memref<32x1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, 5>, index) -> memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
          %54 = "polygeist.memref2pointer"(%53) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
          %55 = "llvm.getelementptr"(%54) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
          %56 = "llvm.getelementptr"(%54) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
          %57 = "llvm.getelementptr"(%54) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
          %58 = "arith.index_cast"(%52) : (i32) -> index
          %59 = "scf.for"(%58, %33, %34, %0) ({
          ^bb0(%arg5: index, %arg6: f32):
            %60 = "arith.subi"(%arg5, %58) : (index, index) -> index
            %61 = "arith.divui"(%60, %34) : (index, index) -> index
            %62 = "arith.muli"(%61, %34) : (index, index) -> index
            %63 = "arith.addi"(%58, %62) : (index, index) -> index
            %64 = "arith.index_cast"(%63) : (index) -> i32
            %65 = "arith.divsi"(%64, %1) : (i32, i32) -> i32
            %66 = "arith.index_cast"(%65) : (i32) -> index
            %67 = "polygeist.subindex"(%29, %66) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            "func.call"(%43, %67) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %68 = "llvm.load"(%54) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %69 = "llvm.load"(%55) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %70 = "arith.addf"(%68, %69) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %71 = "llvm.load"(%56) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %72 = "arith.addf"(%70, %71) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %73 = "llvm.load"(%57) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %74 = "arith.addf"(%72, %73) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            %75 = "arith.addf"(%arg6, %74) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
            "scf.yield"(%75) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          "scf.yield"(%59) : (f32) -> ()
        }, {
          "scf.yield"(%0) : (f32) -> ()
        }) : (i1) -> f32
        %46 = "arith.addi"(%44, %23) : (i32, i32) -> i32
        %47 = "arith.index_cast"(%46) : (i32) -> index
        %48 = "arith.subi"(%25, %47) : (index, index) -> index
        %49 = "arith.addi"(%26, %48) : (index, index) -> index
        %50 = "arith.divui"(%49, %24) : (index, index) -> index
        %51 = "scf.for"(%16, %50, %17, %45) ({
        ^bb0(%arg5: index, %arg6: f32):
          %52 = "arith.muli"(%arg5, %24) : (index, index) -> index
          %53 = "arith.addi"(%52, %47) : (index, index) -> index
          %54 = "memref.load"(%arg0, %53) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %55 = "arith.addf"(%arg6, %54) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "scf.yield"(%55) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%51, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %36 = "arith.cmpi"(%31, %2) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %37 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %37) ({
      ^bb0(%arg4: index):
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "arith.cmpi"(%43, %3) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %45 = "arith.andi"(%36, %44) : (i1, i1) -> i1
        "scf.if"(%45) ({
          %46 = "arith.addi"(%arg4, %9) : (index, index) -> index
          %47 = "memref.load"(%27, %46) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "arith.addf"(%48, %47) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%49, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %38 = "arith.cmpi"(%31, %3) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %39 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %39) ({
      ^bb0(%arg4: index):
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "arith.cmpi"(%43, %4) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %45 = "arith.andi"(%38, %44) : (i1, i1) -> i1
        "scf.if"(%45) ({
          %46 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %47 = "memref.load"(%27, %46) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "arith.addf"(%48, %47) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%49, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %40 = "arith.cmpi"(%31, %4) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %41 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %41) ({
      ^bb0(%arg4: index):
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "arith.cmpi"(%43, %5) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %45 = "arith.andi"(%40, %44) : (i1, i1) -> i1
        "scf.if"(%45) ({
          %46 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %47 = "memref.load"(%27, %46) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "arith.addf"(%48, %47) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%49, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %42 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%16, %18, %42) ({
      ^bb0(%arg4: index):
        %43 = "arith.index_cast"(%arg4) : (index) -> i32
        %44 = "arith.cmpi"(%43, %7) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %45 = "arith.cmpi"(%43, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%45) ({
          %46 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %47 = "memref.load"(%27, %46) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "arith.addf"(%48, %47) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%49, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %50 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %51 = "memref.load"(%27, %50) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %52 = "arith.addf"(%49, %51) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%52, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %53 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %54 = "memref.load"(%27, %53) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %55 = "arith.addf"(%52, %54) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%55, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %56 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %57 = "memref.load"(%27, %56) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %58 = "arith.addf"(%55, %57) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%58, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %59 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %60 = "memref.load"(%27, %59) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %61 = "arith.addf"(%58, %60) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%61, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %62 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %63 = "memref.load"(%27, %62) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %64 = "arith.addf"(%61, %63) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%64, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%44) ({
          %46 = "memref.load"(%27, %16) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %47 = "arith.mulf"(%46, %arg3) <{fastmath = #arith.fastmath<none>}> : (f32, f32) -> f32
          "memref.store"(%47, %arg1, %16) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif_1"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
MemRefAllocaToNPULowering: module: end
[ict-debug] CastLikeOpToNPULowering: process op: 

%4 = arith.index_cast %arg2 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%16 = arith.index_cast %13 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%18 = arith.index_cast %15 : i32 to index
[ict-debug] CastLikeOpToNPULowering: process op: 

%55 = "arith.index_cast"(%arg4) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%74 = "arith.index_cast"(%64) : (i32) -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%82 = "arith.index_cast"(%80) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%85 = "arith.index_cast"(%84) : (i32) -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%59 = "arith.index_cast"(%58) : (i32) -> index
[ict-debug] CastLikeOpToNPULowering: process op: 

%51 = "arith.index_cast"(%arg4) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%51 = "arith.index_cast"(%arg4) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%51 = "arith.index_cast"(%arg4) : (index) -> i32
[ict-debug] CastLikeOpToNPULowering: process op: 

%51 = "arith.index_cast"(%arg4) : (index) -> i32
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU:

"builtin.module"() ({
  "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32):
      %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %1 = "builtin.unrealized_conversion_cast"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %2 = "arith.constant"() <{value = 8 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %4 = "arith.constant"() <{value = 7 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %11 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %12 = "arith.constant"() <{value = 2 : index}> : () -> index
      %13 = "arith.constant"() <{value = 256 : index}> : () -> index
      %14 = "arith.constant"() <{value = 128 : index}> : () -> index
      %15 = "arith.constant"() <{value = 64 : index}> : () -> index
      %16 = "arith.constant"() <{value = 16 : index}> : () -> index
      %17 = "arith.constant"() <{value = 8 : index}> : () -> index
      %18 = "arith.constant"() <{value = 4 : index}> : () -> index
      %19 = "arith.constant"() <{value = 0 : index}> : () -> index
      %20 = "arith.constant"() <{value = 1 : index}> : () -> index
      %21 = "arith.constant"() <{value = 32 : index}> : () -> index
      %22 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %23 = "builtin.unrealized_conversion_cast"(%22) : (!llvm.ptr<6>) -> memref<1xf32, 5>
      %24 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %25 = "builtin.unrealized_conversion_cast"(%24) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %26 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %27 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %28 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %29 = "builtin.unrealized_conversion_cast"(%28) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %30 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %31 = "builtin.unrealized_conversion_cast"(%30) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %32 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %33 = "builtin.unrealized_conversion_cast"(%32) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %34 = "npu.block_id"() : () -> i64
      %35 = "builtin.unrealized_conversion_cast"(%34) : (i64) -> index
      %36 = "emitc.cast"(%34) : (i64) -> i32
      %37 = "arith.constant"() <{value = 32 : index}> : () -> index
      %38 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %39 = "arith.muli"(%36, %38) : (i32, i32) -> i32
      %40 = "arith.muli"(%39, %2) : (i32, i32) -> i32
      %41 = "npu.block_num"() : () -> i64
      %42 = "emitc.cast"(%41) : (i64) -> i32
      %43 = "arith.muli"(%38, %42) : (i32, i32) -> i32
      %44 = "llvm.bitcast"(%0) : (!llvm.ptr) -> !llvm.ptr
      %45 = "llvm.bitcast"(%44) : (!llvm.ptr) -> !llvm.ptr
      %46 = "llvm.bitcast"(%1) : (!llvm.ptr) -> !llvm.ptr
      %47 = "llvm.bitcast"(%46) : (!llvm.ptr) -> !llvm.ptr
      %48 = "arith.muli"(%38, %4) : (i32, i32) -> i32
      %49 = "emitc.cast"(%arg3) : (i32) -> index
      %50 = "emitc.cast"(%43) : (i32) -> index
      %51 = "arith.subi"(%50, %20) : (index, index) -> index
      %52 = "arith.muli"(%43, %2) : (i32, i32) -> i32
      %53 = "llvm.mlir.undef"() : () -> f32
      %54 = "llvm.mlir.undef"() : () -> i32
      %55 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %55) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "arith.constant"() <{value = 0 : i64}> : () -> i64
        %65 = "llvm.getelementptr"(%26, %63, %64) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
        %66 = "llvm.bitcast"(%65) : (!llvm.ptr<6>) -> !llvm.ptr
        %67 = "builtin.unrealized_conversion_cast"(%66) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %68 = "arith.constant"() <{value = 0 : i64}> : () -> i64
        %69 = "llvm.getelementptr"(%27, %63, %68) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
        %70 = "llvm.bitcast"(%69) : (!llvm.ptr<6>) -> !llvm.ptr
        %71 = "builtin.unrealized_conversion_cast"(%70) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %72 = "emitc.cast"(%63) : (i64) -> i32
        %73 = "arith.addi"(%40, %72) : (i32, i32) -> i32
        %74 = "arith.addi"(%73, %48) : (i32, i32) -> i32
        %75:4 = "scf.while"(%3, %74) ({
        ^bb0(%arg5: f32, %arg6: i32):
          %81 = "arith.subi"(%arg6, %48) : (i32, i32) -> i32
          %82 = "arith.cmpi"(%arg6, %arg3) <{predicate = 6 : i64}> : (i32, i32) -> i1
          %83 = "arith.select"(%82, %53, %arg5) : (i1, f32, f32) -> f32
          %84 = "arith.select"(%82, %54, %81) : (i1, i32, i32) -> i32
          %85:2 = "scf.if"(%82) ({
            %86 = "arith.constant"() <{value = 0 : i64}> : () -> i64
            %87 = "llvm.getelementptr"(%27, %63, %86) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
            %88 = "llvm.bitcast"(%87) : (!llvm.ptr<6>) -> !llvm.ptr
            %89 = "llvm.bitcast"(%88) : (!llvm.ptr) -> !llvm.ptr
            %90 = "arith.constant"() <{value = 0 : i64}> : () -> i64
            %91 = "llvm.getelementptr"(%26, %63, %90) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
            %92 = "llvm.bitcast"(%91) : (!llvm.ptr<6>) -> !llvm.ptr
            %93 = "llvm.bitcast"(%92) : (!llvm.ptr) -> !llvm.ptr
            %94 = "llvm.getelementptr"(%89) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %95 = "llvm.getelementptr"(%93) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %96 = "llvm.getelementptr"(%89) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %97 = "llvm.getelementptr"(%93) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %98 = "llvm.getelementptr"(%89) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %99 = "llvm.getelementptr"(%93) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %100 = "scf.for"(%19, %12, %20, %arg5) ({
            ^bb0(%arg7: index, %arg8: f32):
              %102 = "builtin.unrealized_conversion_cast"(%arg7) : (index) -> i64
              %103 = "emitc.cast"(%102) : (i64) -> i32
              %104 = "arith.muli"(%103, %6) : (i32, i32) -> i32
              %105 = "arith.muli"(%104, %38) : (i32, i32) -> i32
              %106 = "arith.addi"(%81, %105) : (i32, i32) -> i32
              %107 = "arith.divui"(%106, %6) : (i32, i32) -> i32
              %108 = "emitc.cast"(%107) : (i32) -> index
              %109 = "builtin.unrealized_conversion_cast"(%108) : (index) -> i64
              %110 = "llvm.getelementptr"(%45, %109) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: -2147483648>}> : (!llvm.ptr, i64) -> !llvm.ptr
              %111 = "llvm.bitcast"(%110) : (!llvm.ptr) -> !llvm.ptr
              %112 = "builtin.unrealized_conversion_cast"(%111) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%71, %112) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %113 = "llvm.getelementptr"(%47, %109) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: -2147483648>}> : (!llvm.ptr, i64) -> !llvm.ptr
              %114 = "llvm.bitcast"(%113) : (!llvm.ptr) -> !llvm.ptr
              %115 = "builtin.unrealized_conversion_cast"(%114) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%67, %115) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %116 = "llvm.load"(%89) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %117 = "emitc.call"(%116) <{callee = "expf"}> : (f32) -> f32
              %118 = "llvm.load"(%93) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %119 = "emitc.mul"(%118, %116) : (f32, f32) -> f32
              %120 = "emitc.sub"(%117, %119) : (f32, f32) -> f32
              %121 = "emitc.add"(%arg8, %120) : (f32, f32) -> f32
              %122 = "llvm.load"(%94) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %123 = "emitc.call"(%122) <{callee = "expf"}> : (f32) -> f32
              %124 = "llvm.load"(%95) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %125 = "emitc.mul"(%124, %122) : (f32, f32) -> f32
              %126 = "emitc.sub"(%123, %125) : (f32, f32) -> f32
              %127 = "emitc.add"(%121, %126) : (f32, f32) -> f32
              %128 = "llvm.load"(%96) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %129 = "emitc.call"(%128) <{callee = "expf"}> : (f32) -> f32
              %130 = "llvm.load"(%97) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %131 = "emitc.mul"(%130, %128) : (f32, f32) -> f32
              %132 = "emitc.sub"(%129, %131) : (f32, f32) -> f32
              %133 = "emitc.add"(%127, %132) : (f32, f32) -> f32
              %134 = "llvm.load"(%98) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %135 = "emitc.call"(%134) <{callee = "expf"}> : (f32) -> f32
              %136 = "llvm.load"(%99) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %137 = "emitc.mul"(%136, %134) : (f32, f32) -> f32
              %138 = "emitc.sub"(%135, %137) : (f32, f32) -> f32
              %139 = "emitc.add"(%133, %138) : (f32, f32) -> f32
              "scf.yield"(%139) : (f32) -> ()
            }) : (index, index, index, f32) -> f32
            %101 = "arith.addi"(%81, %52) : (i32, i32) -> i32
            "scf.yield"(%100, %101) : (f32, i32) -> ()
          }, {
            "scf.yield"(%arg5, %81) : (f32, i32) -> ()
          }) : (i1) -> (f32, i32)
          "scf.condition"(%82, %85#0, %85#1, %83, %84) : (i1, f32, i32, f32, i32) -> ()
        }, {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %81 = "arith.addi"(%arg6, %48) : (i32, i32) -> i32
          "scf.yield"(%arg5, %81) : (f32, i32) -> ()
        }) : (f32, i32) -> (f32, i32, f32, i32)
        %76 = "emitc.cast"(%75#3) : (i32) -> index
        %77 = "arith.subi"(%49, %76) : (index, index) -> index
        %78 = "arith.addi"(%51, %77) : (index, index) -> index
        %79 = "arith.divui"(%78, %50) : (index, index) -> index
        %80 = "scf.for"(%19, %79, %20, %75#2) ({
        ^bb0(%arg5: index, %arg6: f32):
          %81 = "arith.muli"(%arg5, %50) : (index, index) -> index
          %82 = "arith.addi"(%81, %76) : (index, index) -> index
          %83 = "memref.load"(%arg0, %82) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %84 = "memref.load"(%arg1, %82) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %85 = "emitc.call"(%83) <{callee = "expf"}> : (f32) -> f32
          %86 = "emitc.mul"(%84, %83) : (f32, f32) -> f32
          %87 = "emitc.sub"(%85, %86) : (f32, f32) -> f32
          %88 = "emitc.add"(%arg6, %87) : (f32, f32) -> f32
          "scf.yield"(%88) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%80, %25, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "memref.store"(%80, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %56 = "arith.cmpi"(%38, %7) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %57 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %57) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%25, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %8) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %67 = "arith.andi"(%56, %66) : (i1, i1) -> i1
        %68 = "scf.if"(%67) ({
          %69 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %70 = "memref.load"(%23, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "emitc.add"(%64, %70) : (f32, f32) -> f32
          "memref.store"(%71, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%71) : (f32) -> ()
        }, {
          "scf.yield"(%64) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%68, %29, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %58 = "arith.cmpi"(%38, %8) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %59 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %59) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%29, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %9) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %67 = "arith.andi"(%58, %66) : (i1, i1) -> i1
        %68 = "scf.if"(%67) ({
          %69 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %70 = "memref.load"(%23, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "emitc.add"(%64, %70) : (f32, f32) -> f32
          "memref.store"(%71, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%71) : (f32) -> ()
        }, {
          "scf.yield"(%64) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%68, %31, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %60 = "arith.cmpi"(%38, %9) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %61 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %61) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%31, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %10) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %67 = "arith.andi"(%60, %66) : (i1, i1) -> i1
        %68 = "scf.if"(%67) ({
          %69 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %70 = "memref.load"(%23, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "emitc.add"(%64, %70) : (f32, f32) -> f32
          "memref.store"(%71, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%71) : (f32) -> ()
        }, {
          "scf.yield"(%64) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%68, %33, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %62 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %62) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%33, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %5) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %67 = "arith.cmpi"(%65, %11) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%67) ({
          %68 = "arith.addi"(%arg4, %21) : (index, index) -> index
          %69 = "memref.load"(%23, %68) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %70 = "emitc.add"(%64, %69) : (f32, f32) -> f32
          "memref.store"(%70, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %71 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %72 = "memref.load"(%23, %71) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %73 = "emitc.add"(%70, %72) : (f32, f32) -> f32
          "memref.store"(%73, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %74 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %75 = "memref.load"(%23, %74) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %76 = "emitc.add"(%73, %75) : (f32, f32) -> f32
          "memref.store"(%76, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %77 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %78 = "memref.load"(%23, %77) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %79 = "emitc.add"(%76, %78) : (f32, f32) -> f32
          "memref.store"(%79, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %80 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %81 = "memref.load"(%23, %80) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %82 = "emitc.add"(%79, %81) : (f32, f32) -> f32
          "memref.store"(%82, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %83 = "arith.addi"(%arg4, %20) : (index, index) -> index
          %84 = "memref.load"(%23, %83) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %85 = "emitc.add"(%82, %84) : (f32, f32) -> f32
          "memref.store"(%85, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%66) ({
          %68 = "memref.load"(%23, %19) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          "memref.store"(%68, %arg2, %35) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, f32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32):
      %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %1 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %2 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = -3 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 256 : index}> : () -> index
      %11 = "arith.constant"() <{value = 128 : index}> : () -> index
      %12 = "arith.constant"() <{value = 64 : index}> : () -> index
      %13 = "arith.constant"() <{value = 16 : index}> : () -> index
      %14 = "arith.constant"() <{value = 8 : index}> : () -> index
      %15 = "arith.constant"() <{value = 4 : index}> : () -> index
      %16 = "arith.constant"() <{value = 2 : index}> : () -> index
      %17 = "arith.constant"() <{value = 0 : index}> : () -> index
      %18 = "arith.constant"() <{value = 1 : index}> : () -> index
      %19 = "arith.constant"() <{value = 32 : index}> : () -> index
      %20 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %21 = "arith.cmpi"(%arg2, %2) <{predicate = 5 : i64}> : (i32, i32) -> i1
      %22 = "arith.divsi"(%arg2, %2) : (i32, i32) -> i32
      %23 = "arith.muli"(%22, %2) : (i32, i32) -> i32
      %24 = "arith.constant"() <{value = 32 : index}> : () -> index
      %25 = "emitc.cast"(%arg2) : (i32) -> index
      %26 = "arith.subi"(%24, %18) : (index, index) -> index
      %27 = "memref.get_global"() <{name = @sdata}> : () -> memref<1xf32>
      %28 = "llvm.bitcast"(%0) : (!llvm.ptr) -> !llvm.ptr
      %29 = "llvm.bitcast"(%28) : (!llvm.ptr) -> !llvm.ptr
      %30 = "arith.addi"(%arg2, %9) : (i32, i32) -> i32
      %31 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %32 = "arith.muli"(%31, %2) : (i32, i32) -> i32
      %33 = "emitc.cast"(%30) : (i32) -> index
      %34 = "emitc.cast"(%32) : (i32) -> index
      %35 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %35) ({
      ^bb0(%arg4: index):
        %43 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %44 = "arith.constant"() <{value = 0 : i64}> : () -> i64
        %45 = "llvm.getelementptr"(%20, %43, %44) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
        %46 = "llvm.bitcast"(%45) : (!llvm.ptr<6>) -> !llvm.ptr
        %47 = "builtin.unrealized_conversion_cast"(%46) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %48 = "emitc.cast"(%43) : (i64) -> i32
        %49 = "scf.if"(%21) ({
          %56 = "arith.muli"(%48, %2) : (i32, i32) -> i32
          %57 = "arith.constant"() <{value = 0 : i64}> : () -> i64
          %58 = "llvm.getelementptr"(%20, %43, %57) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
          %59 = "llvm.bitcast"(%58) : (!llvm.ptr<6>) -> !llvm.ptr
          %60 = "llvm.bitcast"(%59) : (!llvm.ptr) -> !llvm.ptr
          %61 = "llvm.getelementptr"(%60) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
          %62 = "llvm.getelementptr"(%60) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
          %63 = "llvm.getelementptr"(%60) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
          %64 = "emitc.cast"(%56) : (i32) -> index
          %65 = "scf.for"(%64, %33, %34, %1) ({
          ^bb0(%arg5: index, %arg6: f32):
            %66 = "arith.subi"(%arg5, %64) : (index, index) -> index
            %67 = "arith.divui"(%66, %34) : (index, index) -> index
            %68 = "arith.muli"(%67, %34) : (index, index) -> index
            %69 = "arith.addi"(%64, %68) : (index, index) -> index
            %70 = "builtin.unrealized_conversion_cast"(%69) : (index) -> i64
            %71 = "emitc.cast"(%70) : (i64) -> i32
            %72 = "arith.divsi"(%71, %2) : (i32, i32) -> i32
            %73 = "emitc.cast"(%72) : (i32) -> index
            %74 = "builtin.unrealized_conversion_cast"(%73) : (index) -> i64
            %75 = "llvm.getelementptr"(%29, %74) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: -2147483648>}> : (!llvm.ptr, i64) -> !llvm.ptr
            %76 = "llvm.bitcast"(%75) : (!llvm.ptr) -> !llvm.ptr
            %77 = "builtin.unrealized_conversion_cast"(%76) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            "func.call"(%47, %77) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %78 = "llvm.load"(%60) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %79 = "llvm.load"(%61) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %80 = "emitc.add"(%78, %79) : (f32, f32) -> f32
            %81 = "llvm.load"(%62) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %82 = "emitc.add"(%80, %81) : (f32, f32) -> f32
            %83 = "llvm.load"(%63) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %84 = "emitc.add"(%82, %83) : (f32, f32) -> f32
            %85 = "emitc.add"(%arg6, %84) : (f32, f32) -> f32
            "scf.yield"(%85) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          "scf.yield"(%65) : (f32) -> ()
        }, {
          "scf.yield"(%1) : (f32) -> ()
        }) : (i1) -> f32
        %50 = "arith.addi"(%48, %23) : (i32, i32) -> i32
        %51 = "emitc.cast"(%50) : (i32) -> index
        %52 = "arith.subi"(%25, %51) : (index, index) -> index
        %53 = "arith.addi"(%26, %52) : (index, index) -> index
        %54 = "arith.divui"(%53, %24) : (index, index) -> index
        %55 = "scf.for"(%17, %54, %18, %49) ({
        ^bb0(%arg5: index, %arg6: f32):
          %56 = "arith.muli"(%arg5, %24) : (index, index) -> index
          %57 = "arith.addi"(%56, %51) : (index, index) -> index
          %58 = "memref.load"(%arg0, %57) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %59 = "emitc.add"(%arg6, %58) : (f32, f32) -> f32
          "scf.yield"(%59) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%55, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %36 = "arith.cmpi"(%31, %3) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %37 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %37) ({
      ^bb0(%arg4: index):
        %43 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %44 = "emitc.cast"(%43) : (i64) -> i32
        %45 = "arith.cmpi"(%44, %4) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %46 = "arith.andi"(%36, %45) : (i1, i1) -> i1
        "scf.if"(%46) ({
          %47 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %48 = "memref.load"(%27, %47) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %50 = "emitc.add"(%49, %48) : (f32, f32) -> f32
          "memref.store"(%50, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %38 = "arith.cmpi"(%31, %4) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %39 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %39) ({
      ^bb0(%arg4: index):
        %43 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %44 = "emitc.cast"(%43) : (i64) -> i32
        %45 = "arith.cmpi"(%44, %5) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %46 = "arith.andi"(%38, %45) : (i1, i1) -> i1
        "scf.if"(%46) ({
          %47 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %48 = "memref.load"(%27, %47) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %50 = "emitc.add"(%49, %48) : (f32, f32) -> f32
          "memref.store"(%50, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %40 = "arith.cmpi"(%31, %5) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %41 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %41) ({
      ^bb0(%arg4: index):
        %43 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %44 = "emitc.cast"(%43) : (i64) -> i32
        %45 = "arith.cmpi"(%44, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %46 = "arith.andi"(%40, %45) : (i1, i1) -> i1
        "scf.if"(%46) ({
          %47 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %48 = "memref.load"(%27, %47) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %50 = "emitc.add"(%49, %48) : (f32, f32) -> f32
          "memref.store"(%50, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %42 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %42) ({
      ^bb0(%arg4: index):
        %43 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %44 = "emitc.cast"(%43) : (i64) -> i32
        %45 = "arith.cmpi"(%44, %8) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %46 = "arith.cmpi"(%44, %7) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%46) ({
          %47 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %48 = "memref.load"(%27, %47) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %50 = "emitc.add"(%49, %48) : (f32, f32) -> f32
          "memref.store"(%50, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %51 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %52 = "memref.load"(%27, %51) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %53 = "emitc.add"(%50, %52) : (f32, f32) -> f32
          "memref.store"(%53, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %54 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %55 = "memref.load"(%27, %54) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %56 = "emitc.add"(%53, %55) : (f32, f32) -> f32
          "memref.store"(%56, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %57 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %58 = "memref.load"(%27, %57) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %59 = "emitc.add"(%56, %58) : (f32, f32) -> f32
          "memref.store"(%59, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %60 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %61 = "memref.load"(%27, %60) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %62 = "emitc.add"(%59, %61) : (f32, f32) -> f32
          "memref.store"(%62, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %63 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %64 = "memref.load"(%27, %63) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %65 = "emitc.add"(%62, %64) : (f32, f32) -> f32
          "memref.store"(%65, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%45) ({
          %47 = "memref.load"(%27, %17) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "emitc.mul"(%47, %arg3) : (f32, f32) -> f32
          "memref.store"(%48, %arg1, %17) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif_1"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
[ict-debug] ConvertPolygeistToNPUPass::runOnOperation(): After convert to NPU: end

loc("./cuda_ops/98_KLDivLoss.cu":36:13): error: 'llvm.bitcast' op cannot cast pointers of different address spaces, use 'llvm.addrspacecast' instead
"builtin.module"() ({
  "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, memref<?xf32>, i32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: i32):
      %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %1 = "builtin.unrealized_conversion_cast"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %2 = "arith.constant"() <{value = 8 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %4 = "arith.constant"() <{value = 7 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %11 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %12 = "arith.constant"() <{value = 2 : index}> : () -> index
      %13 = "arith.constant"() <{value = 256 : index}> : () -> index
      %14 = "arith.constant"() <{value = 128 : index}> : () -> index
      %15 = "arith.constant"() <{value = 64 : index}> : () -> index
      %16 = "arith.constant"() <{value = 16 : index}> : () -> index
      %17 = "arith.constant"() <{value = 8 : index}> : () -> index
      %18 = "arith.constant"() <{value = 4 : index}> : () -> index
      %19 = "arith.constant"() <{value = 0 : index}> : () -> index
      %20 = "arith.constant"() <{value = 1 : index}> : () -> index
      %21 = "arith.constant"() <{value = 32 : index}> : () -> index
      %22 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %23 = "builtin.unrealized_conversion_cast"(%22) : (!llvm.ptr<6>) -> memref<1xf32, 5>
      %24 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %25 = "builtin.unrealized_conversion_cast"(%24) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %26 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %27 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %28 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %29 = "builtin.unrealized_conversion_cast"(%28) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %30 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %31 = "builtin.unrealized_conversion_cast"(%30) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %32 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %33 = "builtin.unrealized_conversion_cast"(%32) : (!llvm.ptr<6>) -> memref<32xf32, 5>
      %34 = "npu.block_id"() : () -> i64
      %35 = "builtin.unrealized_conversion_cast"(%34) : (i64) -> index
      %36 = "emitc.cast"(%34) : (i64) -> i32
      %37 = "arith.constant"() <{value = 32 : index}> : () -> index
      %38 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %39 = "arith.muli"(%36, %38) : (i32, i32) -> i32
      %40 = "arith.muli"(%39, %2) : (i32, i32) -> i32
      %41 = "npu.block_num"() : () -> i64
      %42 = "emitc.cast"(%41) : (i64) -> i32
      %43 = "arith.muli"(%38, %42) : (i32, i32) -> i32
      %44 = "llvm.bitcast"(%0) : (!llvm.ptr) -> !llvm.ptr
      %45 = "llvm.bitcast"(%44) : (!llvm.ptr) -> !llvm.ptr
      %46 = "llvm.bitcast"(%1) : (!llvm.ptr) -> !llvm.ptr
      %47 = "llvm.bitcast"(%46) : (!llvm.ptr) -> !llvm.ptr
      %48 = "arith.muli"(%38, %4) : (i32, i32) -> i32
      %49 = "emitc.cast"(%arg3) : (i32) -> index
      %50 = "emitc.cast"(%43) : (i32) -> index
      %51 = "arith.subi"(%50, %20) : (index, index) -> index
      %52 = "arith.muli"(%43, %2) : (i32, i32) -> i32
      %53 = "llvm.mlir.undef"() : () -> f32
      %54 = "llvm.mlir.undef"() : () -> i32
      %55 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %55) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "arith.constant"() <{value = 0 : i64}> : () -> i64
        %65 = "llvm.getelementptr"(%26, %63, %64) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
        %66 = "llvm.bitcast"(%65) : (!llvm.ptr<6>) -> !llvm.ptr
        %67 = "builtin.unrealized_conversion_cast"(%66) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %68 = "arith.constant"() <{value = 0 : i64}> : () -> i64
        %69 = "llvm.getelementptr"(%27, %63, %68) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
        %70 = "llvm.bitcast"(%69) : (!llvm.ptr<6>) -> !llvm.ptr
        %71 = "builtin.unrealized_conversion_cast"(%70) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %72 = "emitc.cast"(%63) : (i64) -> i32
        %73 = "arith.addi"(%40, %72) : (i32, i32) -> i32
        %74 = "arith.addi"(%73, %48) : (i32, i32) -> i32
        %75:4 = "scf.while"(%3, %74) ({
        ^bb0(%arg5: f32, %arg6: i32):
          %81 = "arith.subi"(%arg6, %48) : (i32, i32) -> i32
          %82 = "arith.cmpi"(%arg6, %arg3) <{predicate = 6 : i64}> : (i32, i32) -> i1
          %83 = "arith.select"(%82, %53, %arg5) : (i1, f32, f32) -> f32
          %84 = "arith.select"(%82, %54, %81) : (i1, i32, i32) -> i32
          %85:2 = "scf.if"(%82) ({
            %86 = "arith.constant"() <{value = 0 : i64}> : () -> i64
            %87 = "llvm.getelementptr"(%27, %63, %86) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
            %88 = "llvm.bitcast"(%87) : (!llvm.ptr<6>) -> !llvm.ptr
            %89 = "llvm.bitcast"(%88) : (!llvm.ptr) -> !llvm.ptr
            %90 = "arith.constant"() <{value = 0 : i64}> : () -> i64
            %91 = "llvm.getelementptr"(%26, %63, %90) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
            %92 = "llvm.bitcast"(%91) : (!llvm.ptr<6>) -> !llvm.ptr
            %93 = "llvm.bitcast"(%92) : (!llvm.ptr) -> !llvm.ptr
            %94 = "llvm.getelementptr"(%89) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %95 = "llvm.getelementptr"(%93) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
            %96 = "llvm.getelementptr"(%89) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %97 = "llvm.getelementptr"(%93) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
            %98 = "llvm.getelementptr"(%89) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %99 = "llvm.getelementptr"(%93) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
            %100 = "scf.for"(%19, %12, %20, %arg5) ({
            ^bb0(%arg7: index, %arg8: f32):
              %102 = "builtin.unrealized_conversion_cast"(%arg7) : (index) -> i64
              %103 = "emitc.cast"(%102) : (i64) -> i32
              %104 = "arith.muli"(%103, %6) : (i32, i32) -> i32
              %105 = "arith.muli"(%104, %38) : (i32, i32) -> i32
              %106 = "arith.addi"(%81, %105) : (i32, i32) -> i32
              %107 = "arith.divui"(%106, %6) : (i32, i32) -> i32
              %108 = "emitc.cast"(%107) : (i32) -> index
              %109 = "builtin.unrealized_conversion_cast"(%108) : (index) -> i64
              %110 = "llvm.getelementptr"(%45, %109) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: -2147483648>}> : (!llvm.ptr, i64) -> !llvm.ptr
              %111 = "llvm.bitcast"(%110) : (!llvm.ptr) -> !llvm.ptr
              %112 = "builtin.unrealized_conversion_cast"(%111) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%71, %112) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %113 = "llvm.getelementptr"(%47, %109) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: -2147483648>}> : (!llvm.ptr, i64) -> !llvm.ptr
              %114 = "llvm.bitcast"(%113) : (!llvm.ptr) -> !llvm.ptr
              %115 = "builtin.unrealized_conversion_cast"(%114) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
              "func.call"(%67, %115) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
              %116 = "llvm.load"(%89) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %117 = "emitc.call"(%116) <{callee = "expf"}> : (f32) -> f32
              %118 = "llvm.load"(%93) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %119 = "emitc.mul"(%118, %116) : (f32, f32) -> f32
              %120 = "emitc.sub"(%117, %119) : (f32, f32) -> f32
              %121 = "emitc.add"(%arg8, %120) : (f32, f32) -> f32
              %122 = "llvm.load"(%94) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %123 = "emitc.call"(%122) <{callee = "expf"}> : (f32) -> f32
              %124 = "llvm.load"(%95) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %125 = "emitc.mul"(%124, %122) : (f32, f32) -> f32
              %126 = "emitc.sub"(%123, %125) : (f32, f32) -> f32
              %127 = "emitc.add"(%121, %126) : (f32, f32) -> f32
              %128 = "llvm.load"(%96) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %129 = "emitc.call"(%128) <{callee = "expf"}> : (f32) -> f32
              %130 = "llvm.load"(%97) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %131 = "emitc.mul"(%130, %128) : (f32, f32) -> f32
              %132 = "emitc.sub"(%129, %131) : (f32, f32) -> f32
              %133 = "emitc.add"(%127, %132) : (f32, f32) -> f32
              %134 = "llvm.load"(%98) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %135 = "emitc.call"(%134) <{callee = "expf"}> : (f32) -> f32
              %136 = "llvm.load"(%99) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
              %137 = "emitc.mul"(%136, %134) : (f32, f32) -> f32
              %138 = "emitc.sub"(%135, %137) : (f32, f32) -> f32
              %139 = "emitc.add"(%133, %138) : (f32, f32) -> f32
              "scf.yield"(%139) : (f32) -> ()
            }) : (index, index, index, f32) -> f32
            %101 = "arith.addi"(%81, %52) : (i32, i32) -> i32
            "scf.yield"(%100, %101) : (f32, i32) -> ()
          }, {
            "scf.yield"(%arg5, %81) : (f32, i32) -> ()
          }) : (i1) -> (f32, i32)
          "scf.condition"(%82, %85#0, %85#1, %83, %84) : (i1, f32, i32, f32, i32) -> ()
        }, {
        ^bb0(%arg5: f32, %arg6: i32, %arg7: f32, %arg8: i32):
          %81 = "arith.addi"(%arg6, %48) : (i32, i32) -> i32
          "scf.yield"(%arg5, %81) : (f32, i32) -> ()
        }) : (f32, i32) -> (f32, i32, f32, i32)
        %76 = "emitc.cast"(%75#3) : (i32) -> index
        %77 = "arith.subi"(%49, %76) : (index, index) -> index
        %78 = "arith.addi"(%51, %77) : (index, index) -> index
        %79 = "arith.divui"(%78, %50) : (index, index) -> index
        %80 = "scf.for"(%19, %79, %20, %75#2) ({
        ^bb0(%arg5: index, %arg6: f32):
          %81 = "arith.muli"(%arg5, %50) : (index, index) -> index
          %82 = "arith.addi"(%81, %76) : (index, index) -> index
          %83 = "memref.load"(%arg0, %82) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %84 = "memref.load"(%arg1, %82) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %85 = "emitc.call"(%83) <{callee = "expf"}> : (f32) -> f32
          %86 = "emitc.mul"(%84, %83) : (f32, f32) -> f32
          %87 = "emitc.sub"(%85, %86) : (f32, f32) -> f32
          %88 = "emitc.add"(%arg6, %87) : (f32, f32) -> f32
          "scf.yield"(%88) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%80, %25, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "memref.store"(%80, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %56 = "arith.cmpi"(%38, %7) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %57 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %57) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%25, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %8) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %67 = "arith.andi"(%56, %66) : (i1, i1) -> i1
        %68 = "scf.if"(%67) ({
          %69 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %70 = "memref.load"(%23, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "emitc.add"(%64, %70) : (f32, f32) -> f32
          "memref.store"(%71, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%71) : (f32) -> ()
        }, {
          "scf.yield"(%64) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%68, %29, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %58 = "arith.cmpi"(%38, %8) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %59 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %59) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%29, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %9) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %67 = "arith.andi"(%58, %66) : (i1, i1) -> i1
        %68 = "scf.if"(%67) ({
          %69 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %70 = "memref.load"(%23, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "emitc.add"(%64, %70) : (f32, f32) -> f32
          "memref.store"(%71, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%71) : (f32) -> ()
        }, {
          "scf.yield"(%64) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%68, %31, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %60 = "arith.cmpi"(%38, %9) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %61 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %61) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%31, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %10) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %67 = "arith.andi"(%60, %66) : (i1, i1) -> i1
        %68 = "scf.if"(%67) ({
          %69 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %70 = "memref.load"(%23, %69) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %71 = "emitc.add"(%64, %70) : (f32, f32) -> f32
          "memref.store"(%71, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"(%71) : (f32) -> ()
        }, {
          "scf.yield"(%64) : (f32) -> ()
        }) : (i1) -> f32
        "memref.store"(%68, %33, %arg4) <{nontemporal = false}> : (f32, memref<32xf32, 5>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %62 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%19, %21, %62) ({
      ^bb0(%arg4: index):
        %63 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %64 = "memref.load"(%33, %arg4) <{nontemporal = false}> : (memref<32xf32, 5>, index) -> f32
        %65 = "emitc.cast"(%63) : (i64) -> i32
        %66 = "arith.cmpi"(%65, %5) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %67 = "arith.cmpi"(%65, %11) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%67) ({
          %68 = "arith.addi"(%arg4, %21) : (index, index) -> index
          %69 = "memref.load"(%23, %68) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %70 = "emitc.add"(%64, %69) : (f32, f32) -> f32
          "memref.store"(%70, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %71 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %72 = "memref.load"(%23, %71) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %73 = "emitc.add"(%70, %72) : (f32, f32) -> f32
          "memref.store"(%73, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %74 = "arith.addi"(%arg4, %17) : (index, index) -> index
          %75 = "memref.load"(%23, %74) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %76 = "emitc.add"(%73, %75) : (f32, f32) -> f32
          "memref.store"(%76, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %77 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %78 = "memref.load"(%23, %77) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %79 = "emitc.add"(%76, %78) : (f32, f32) -> f32
          "memref.store"(%79, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %80 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %81 = "memref.load"(%23, %80) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %82 = "emitc.add"(%79, %81) : (f32, f32) -> f32
          "memref.store"(%82, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          %83 = "arith.addi"(%arg4, %20) : (index, index) -> index
          %84 = "memref.load"(%23, %83) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          %85 = "emitc.add"(%82, %84) : (f32, f32) -> f32
          "memref.store"(%85, %23, %arg4) <{nontemporal = false}> : (f32, memref<1xf32, 5>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%66) ({
          %68 = "memref.load"(%23, %19) <{nontemporal = false}> : (memref<1xf32, 5>, index) -> f32
          "memref.store"(%68, %arg2, %35) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi", workgroup_attributions = 0 : i64} : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage1PKfS0_Pfi_0"} : () -> ()
  "gpu.module"() ({
    "gpu.func"() <{function_type = (memref<?xf32>, memref<?xf32>, i32, f32) -> ()}> ({
    ^bb0(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: i32, %arg3: f32):
      %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %1 = "arith.constant"() <{value = 0.000000e+00 : f32}> : () -> f32
      %2 = "arith.constant"() <{value = 4 : i32}> : () -> i32
      %3 = "arith.constant"() <{value = 512 : i32}> : () -> i32
      %4 = "arith.constant"() <{value = 256 : i32}> : () -> i32
      %5 = "arith.constant"() <{value = 128 : i32}> : () -> i32
      %6 = "arith.constant"() <{value = 64 : i32}> : () -> i32
      %7 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %8 = "arith.constant"() <{value = 0 : i32}> : () -> i32
      %9 = "arith.constant"() <{value = -3 : i32}> : () -> i32
      %10 = "arith.constant"() <{value = 256 : index}> : () -> index
      %11 = "arith.constant"() <{value = 128 : index}> : () -> index
      %12 = "arith.constant"() <{value = 64 : index}> : () -> index
      %13 = "arith.constant"() <{value = 16 : index}> : () -> index
      %14 = "arith.constant"() <{value = 8 : index}> : () -> index
      %15 = "arith.constant"() <{value = 4 : index}> : () -> index
      %16 = "arith.constant"() <{value = 2 : index}> : () -> index
      %17 = "arith.constant"() <{value = 0 : index}> : () -> index
      %18 = "arith.constant"() <{value = 1 : index}> : () -> index
      %19 = "arith.constant"() <{value = 32 : index}> : () -> index
      %20 = "npu.alloca"() <{numElems = 32 : i32}> : () -> !llvm.ptr<6>
      %21 = "arith.cmpi"(%arg2, %2) <{predicate = 5 : i64}> : (i32, i32) -> i1
      %22 = "arith.divsi"(%arg2, %2) : (i32, i32) -> i32
      %23 = "arith.muli"(%22, %2) : (i32, i32) -> i32
      %24 = "arith.constant"() <{value = 32 : index}> : () -> index
      %25 = "emitc.cast"(%arg2) : (i32) -> index
      %26 = "arith.subi"(%24, %18) : (index, index) -> index
      %27 = "memref.get_global"() <{name = @sdata}> : () -> memref<1xf32>
      %28 = "llvm.bitcast"(%0) : (!llvm.ptr) -> !llvm.ptr
      %29 = "llvm.bitcast"(%28) : (!llvm.ptr) -> !llvm.ptr
      %30 = "arith.addi"(%arg2, %9) : (i32, i32) -> i32
      %31 = "arith.constant"() <{value = 32 : i32}> : () -> i32
      %32 = "arith.muli"(%31, %2) : (i32, i32) -> i32
      %33 = "emitc.cast"(%30) : (i32) -> index
      %34 = "emitc.cast"(%32) : (i32) -> index
      %35 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %35) ({
      ^bb0(%arg4: index):
        %43 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %44 = "arith.constant"() <{value = 0 : i64}> : () -> i64
        %45 = "llvm.getelementptr"(%20, %43, %44) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
        %46 = "llvm.bitcast"(%45) : (!llvm.ptr<6>) -> !llvm.ptr
        %47 = "builtin.unrealized_conversion_cast"(%46) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %48 = "emitc.cast"(%43) : (i64) -> i32
        %49 = "scf.if"(%21) ({
          %56 = "arith.muli"(%48, %2) : (i32, i32) -> i32
          %57 = "arith.constant"() <{value = 0 : i64}> : () -> i64
          %58 = "llvm.getelementptr"(%20, %43, %57) <{elem_type = !llvm.array<1 x struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, rawConstantIndices = array<i32: -2147483648, -2147483648>}> : (!llvm.ptr<6>, i64, i64) -> !llvm.ptr<6>
          %59 = "llvm.bitcast"(%58) : (!llvm.ptr<6>) -> !llvm.ptr
          %60 = "llvm.bitcast"(%59) : (!llvm.ptr) -> !llvm.ptr
          %61 = "llvm.getelementptr"(%60) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
          %62 = "llvm.getelementptr"(%60) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
          %63 = "llvm.getelementptr"(%60) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
          %64 = "emitc.cast"(%56) : (i32) -> index
          %65 = "scf.for"(%64, %33, %34, %1) ({
          ^bb0(%arg5: index, %arg6: f32):
            %66 = "arith.subi"(%arg5, %64) : (index, index) -> index
            %67 = "arith.divui"(%66, %34) : (index, index) -> index
            %68 = "arith.muli"(%67, %34) : (index, index) -> index
            %69 = "arith.addi"(%64, %68) : (index, index) -> index
            %70 = "builtin.unrealized_conversion_cast"(%69) : (index) -> i64
            %71 = "emitc.cast"(%70) : (i64) -> i32
            %72 = "arith.divsi"(%71, %2) : (i32, i32) -> i32
            %73 = "emitc.cast"(%72) : (i32) -> index
            %74 = "builtin.unrealized_conversion_cast"(%73) : (index) -> i64
            %75 = "llvm.getelementptr"(%29, %74) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: -2147483648>}> : (!llvm.ptr, i64) -> !llvm.ptr
            %76 = "llvm.bitcast"(%75) : (!llvm.ptr) -> !llvm.ptr
            %77 = "builtin.unrealized_conversion_cast"(%76) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
            "func.call"(%47, %77) <{callee = @_ZN6float4C1ERKS_}> : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
            %78 = "llvm.load"(%60) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %79 = "llvm.load"(%61) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %80 = "emitc.add"(%78, %79) : (f32, f32) -> f32
            %81 = "llvm.load"(%62) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %82 = "emitc.add"(%80, %81) : (f32, f32) -> f32
            %83 = "llvm.load"(%63) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
            %84 = "emitc.add"(%82, %83) : (f32, f32) -> f32
            %85 = "emitc.add"(%arg6, %84) : (f32, f32) -> f32
            "scf.yield"(%85) : (f32) -> ()
          }) : (index, index, index, f32) -> f32
          "scf.yield"(%65) : (f32) -> ()
        }, {
          "scf.yield"(%1) : (f32) -> ()
        }) : (i1) -> f32
        %50 = "arith.addi"(%48, %23) : (i32, i32) -> i32
        %51 = "emitc.cast"(%50) : (i32) -> index
        %52 = "arith.subi"(%25, %51) : (index, index) -> index
        %53 = "arith.addi"(%26, %52) : (index, index) -> index
        %54 = "arith.divui"(%53, %24) : (index, index) -> index
        %55 = "scf.for"(%17, %54, %18, %49) ({
        ^bb0(%arg5: index, %arg6: f32):
          %56 = "arith.muli"(%arg5, %24) : (index, index) -> index
          %57 = "arith.addi"(%56, %51) : (index, index) -> index
          %58 = "memref.load"(%arg0, %57) <{nontemporal = false}> : (memref<?xf32>, index) -> f32
          %59 = "emitc.add"(%arg6, %58) : (f32, f32) -> f32
          "scf.yield"(%59) : (f32) -> ()
        }) : (index, index, index, f32) -> f32
        "memref.store"(%55, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %36 = "arith.cmpi"(%31, %3) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %37 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %37) ({
      ^bb0(%arg4: index):
        %43 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %44 = "emitc.cast"(%43) : (i64) -> i32
        %45 = "arith.cmpi"(%44, %4) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %46 = "arith.andi"(%36, %45) : (i1, i1) -> i1
        "scf.if"(%46) ({
          %47 = "arith.addi"(%arg4, %10) : (index, index) -> index
          %48 = "memref.load"(%27, %47) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %50 = "emitc.add"(%49, %48) : (f32, f32) -> f32
          "memref.store"(%50, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %38 = "arith.cmpi"(%31, %4) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %39 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %39) ({
      ^bb0(%arg4: index):
        %43 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %44 = "emitc.cast"(%43) : (i64) -> i32
        %45 = "arith.cmpi"(%44, %5) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %46 = "arith.andi"(%38, %45) : (i1, i1) -> i1
        "scf.if"(%46) ({
          %47 = "arith.addi"(%arg4, %11) : (index, index) -> index
          %48 = "memref.load"(%27, %47) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %50 = "emitc.add"(%49, %48) : (f32, f32) -> f32
          "memref.store"(%50, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %40 = "arith.cmpi"(%31, %5) <{predicate = 9 : i64}> : (i32, i32) -> i1
      %41 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %41) ({
      ^bb0(%arg4: index):
        %43 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %44 = "emitc.cast"(%43) : (i64) -> i32
        %45 = "arith.cmpi"(%44, %6) <{predicate = 6 : i64}> : (i32, i32) -> i1
        %46 = "arith.andi"(%40, %45) : (i1, i1) -> i1
        "scf.if"(%46) ({
          %47 = "arith.addi"(%arg4, %12) : (index, index) -> index
          %48 = "memref.load"(%27, %47) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %50 = "emitc.add"(%49, %48) : (f32, f32) -> f32
          "memref.store"(%50, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      %42 = "arith.constant"() <{value = 1 : index}> : () -> index
      "scf.for"(%17, %19, %42) ({
      ^bb0(%arg4: index):
        %43 = "builtin.unrealized_conversion_cast"(%arg4) : (index) -> i64
        %44 = "emitc.cast"(%43) : (i64) -> i32
        %45 = "arith.cmpi"(%44, %8) <{predicate = 0 : i64}> : (i32, i32) -> i1
        %46 = "arith.cmpi"(%44, %7) <{predicate = 6 : i64}> : (i32, i32) -> i1
        "scf.if"(%46) ({
          %47 = "arith.addi"(%arg4, %19) : (index, index) -> index
          %48 = "memref.load"(%27, %47) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %49 = "memref.load"(%27, %arg4) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %50 = "emitc.add"(%49, %48) : (f32, f32) -> f32
          "memref.store"(%50, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %51 = "arith.addi"(%arg4, %13) : (index, index) -> index
          %52 = "memref.load"(%27, %51) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %53 = "emitc.add"(%50, %52) : (f32, f32) -> f32
          "memref.store"(%53, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %54 = "arith.addi"(%arg4, %14) : (index, index) -> index
          %55 = "memref.load"(%27, %54) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %56 = "emitc.add"(%53, %55) : (f32, f32) -> f32
          "memref.store"(%56, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %57 = "arith.addi"(%arg4, %15) : (index, index) -> index
          %58 = "memref.load"(%27, %57) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %59 = "emitc.add"(%56, %58) : (f32, f32) -> f32
          "memref.store"(%59, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %60 = "arith.addi"(%arg4, %16) : (index, index) -> index
          %61 = "memref.load"(%27, %60) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %62 = "emitc.add"(%59, %61) : (f32, f32) -> f32
          "memref.store"(%62, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          %63 = "arith.addi"(%arg4, %18) : (index, index) -> index
          %64 = "memref.load"(%27, %63) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %65 = "emitc.add"(%62, %64) : (f32, f32) -> f32
          "memref.store"(%65, %27, %arg4) <{nontemporal = false}> : (f32, memref<1xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.if"(%45) ({
          %47 = "memref.load"(%27, %17) <{nontemporal = false}> : (memref<1xf32>, index) -> f32
          %48 = "emitc.mul"(%47, %arg3) : (f32, f32) -> f32
          "memref.store"(%48, %arg1, %17) <{nontemporal = false}> : (f32, memref<?xf32>, index) -> ()
          "scf.yield"() : () -> ()
        }, {
        }) : (i1) -> ()
        "scf.yield"() : () -> ()
      }) : (index, index, index) -> ()
      "gpu.return"() : () -> ()
    }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif", workgroup_attributions = 0 : i64} : () -> ()
    "memref.global"() <{sym_name = "sdata", type = memref<1xf32>}> : () -> ()
    "func.func"() <{function_type = (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> (), sym_name = "_ZN6float4C1ERKS_", sym_visibility = "private"}> ({
    ^bb0(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>):
      %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %1 = "llvm.load"(%0) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      "llvm.store"(%1, %2) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %3 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      %4 = "llvm.load"(%3) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %5 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 1>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%4, %5) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %6 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      %7 = "llvm.load"(%6) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %8 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 2>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%7, %8) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      %9 = "llvm.getelementptr"(%0) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      %10 = "llvm.load"(%9) <{ordering = 0 : i64}> : (!llvm.ptr) -> f32
      %11 = "llvm.getelementptr"(%2) <{elem_type = !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>, rawConstantIndices = array<i32: 0, 3>}> : (!llvm.ptr) -> !llvm.ptr
      "llvm.store"(%10, %11) <{ordering = 0 : i64}> : (f32, !llvm.ptr) -> ()
      "func.return"() : () -> ()
    }) {llvm.linkage = #llvm.linkage<linkonce_odr>} : () -> ()
    "gpu.module_end"() : () -> ()
  }) {sym_name = "_Z20kl_div_kernel_stage2PKfPfif_1"} : () -> ()
}) {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} : () -> ()
