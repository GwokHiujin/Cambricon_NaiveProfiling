warning: CUDA version 12.1 is only partially supported
warning: CUDA version 12.1 is only partially supported
warning: we failed to emit call to builtin function __nvvm_ldg_f4
warning: we failed to emit call to builtin function __nvvm_ldg_f
warning: we failed to emit call to builtin function __nvvm_shfl_sync_down_f32
[ict-debug] driver.cc: After return 5, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z51__device_stub__triplet_margin_loss_kernel_warp_shflPKfS0_S0_Pffii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: f32, %arg5: i32, %arg6: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    call @_Z36triplet_margin_loss_kernel_warp_shflPKfS0_S0_Pffii(%arg0, %arg1, %arg2, %arg3, %arg4, %arg5, %arg6) : (memref<?xf32>, memref<?xf32>, memref<?xf32>, memref<?xf32>, f32, i32, i32) -> ()
    return
  }
  func.func private @_Z36triplet_margin_loss_kernel_warp_shflPKfS0_S0_Pffii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: f32, %arg5: i32, %arg6: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c4 = arith.constant 4 : index
    %c2_i32 = arith.constant 2 : i32
    %c32_i32 = arith.constant 32 : i32
    %c0_i32 = arith.constant 0 : i32
    %c16_i32 = arith.constant 16 : i32
    %c-1_i32 = arith.constant -1 : i32
    %c4_i32 = arith.constant 4 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %alloca = memref.alloca() : memref<32xf32, 5>
    %alloca_0 = memref.alloca() : memref<32xf32, 5>
    %alloca_1 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_3 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.cmpi slt, %1, %arg5 : i32
    scf.if %2 {
      %3 = arith.muli %1, %arg6 : i32
      %4 = gpu.thread_id  x
      %5 = arith.index_cast %4 : index to i32
      %6 = arith.cmpi eq, %5, %c0_i32 : i32
      %7 = arith.divsi %arg6, %c4_i32 : i32
      %8 = arith.muli %7, %c4_i32 : i32
      %9 = arith.index_cast %3 : i32 to index
      %10 = arith.muli %9, %c4 : index
      %11 = arith.index_cast %10 : index to i64
      %12 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %13 = llvm.getelementptr %12[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i8
      %14 = "polygeist.pointer2memref"(%13) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %15 = arith.index_cast %3 : i32 to index
      %16 = arith.muli %15, %c4 : index
      %17 = arith.index_cast %16 : index to i64
      %18 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %19 = llvm.getelementptr %18[%17] : (!llvm.ptr, i64) -> !llvm.ptr, i8
      %20 = "polygeist.pointer2memref"(%19) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %21 = arith.index_cast %3 : i32 to index
      %22 = arith.muli %21, %c4 : index
      %23 = arith.index_cast %22 : index to i64
      %24 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %25 = llvm.getelementptr %24[%23] : (!llvm.ptr, i64) -> !llvm.ptr, i8
      %26 = "polygeist.pointer2memref"(%25) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %27 = arith.divsi %8, %c4_i32 : i32
      %28 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %29 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %30 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %31 = llvm.getelementptr %30[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %32 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %33 = llvm.getelementptr %32[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %34 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %35 = llvm.getelementptr %34[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %36 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %37 = llvm.getelementptr %36[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %38 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %39 = llvm.getelementptr %38[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %40 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %41 = llvm.getelementptr %40[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %42 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %43 = "polygeist.memref2pointer"(%alloca_1) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %44 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %45 = llvm.getelementptr %44[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %46 = "polygeist.memref2pointer"(%alloca_1) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %47 = llvm.getelementptr %46[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %48 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %49 = llvm.getelementptr %48[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %50 = "polygeist.memref2pointer"(%alloca_1) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %51 = llvm.getelementptr %50[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %52 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %53 = llvm.getelementptr %52[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %54 = "polygeist.memref2pointer"(%alloca_1) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %55 = llvm.getelementptr %54[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %56 = gpu.block_dim  x
      %57 = arith.index_cast %27 : i32 to index
      %58:2 = scf.for %arg7 = %4 to %57 step %56 iter_args(%arg8 = %cst, %arg9 = %cst) -> (f32, f32) {
        %75 = arith.subi %arg7, %4 : index
        %76 = arith.divui %75, %56 : index
        %77 = arith.muli %76, %56 : index
        %78 = arith.addi %4, %77 : index
        %79 = "polygeist.subindex"(%14, %78) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %80 = func.call @_Z5__ldgPK6float4(%79) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        affine.store %80, %alloca_3[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %81 = "polygeist.subindex"(%20, %78) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %82 = func.call @_Z5__ldgPK6float4(%81) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        affine.store %82, %alloca_2[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %83 = "polygeist.subindex"(%26, %78) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %84 = func.call @_Z5__ldgPK6float4(%83) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        affine.store %84, %alloca_1[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %85 = llvm.load %28 : !llvm.ptr -> f32
        %86 = llvm.load %29 : !llvm.ptr -> f32
        %87 = arith.subf %85, %86 : f32
        %88 = arith.mulf %87, %87 : f32
        %89 = arith.addf %arg9, %88 : f32
        %90 = llvm.load %31 : !llvm.ptr -> f32
        %91 = llvm.load %33 : !llvm.ptr -> f32
        %92 = arith.subf %90, %91 : f32
        %93 = arith.mulf %92, %92 : f32
        %94 = arith.addf %89, %93 : f32
        %95 = llvm.load %35 : !llvm.ptr -> f32
        %96 = llvm.load %37 : !llvm.ptr -> f32
        %97 = arith.subf %95, %96 : f32
        %98 = arith.mulf %97, %97 : f32
        %99 = arith.addf %94, %98 : f32
        %100 = llvm.load %39 : !llvm.ptr -> f32
        %101 = llvm.load %41 : !llvm.ptr -> f32
        %102 = arith.subf %100, %101 : f32
        %103 = arith.mulf %102, %102 : f32
        %104 = arith.addf %99, %103 : f32
        %105 = llvm.load %42 : !llvm.ptr -> f32
        %106 = llvm.load %43 : !llvm.ptr -> f32
        %107 = arith.subf %105, %106 : f32
        %108 = arith.mulf %107, %107 : f32
        %109 = arith.addf %arg8, %108 : f32
        %110 = llvm.load %45 : !llvm.ptr -> f32
        %111 = llvm.load %47 : !llvm.ptr -> f32
        %112 = arith.subf %110, %111 : f32
        %113 = arith.mulf %112, %112 : f32
        %114 = arith.addf %109, %113 : f32
        %115 = llvm.load %49 : !llvm.ptr -> f32
        %116 = llvm.load %51 : !llvm.ptr -> f32
        %117 = arith.subf %115, %116 : f32
        %118 = arith.mulf %117, %117 : f32
        %119 = arith.addf %114, %118 : f32
        %120 = llvm.load %53 : !llvm.ptr -> f32
        %121 = llvm.load %55 : !llvm.ptr -> f32
        %122 = arith.subf %120, %121 : f32
        %123 = arith.mulf %122, %122 : f32
        %124 = arith.addf %119, %123 : f32
        scf.yield %124, %104 : f32, f32
      }
      %59 = arith.addi %8, %5 : i32
      %60 = arith.index_cast %3 : i32 to index
      %61 = arith.index_cast %3 : i32 to index
      %62 = arith.index_cast %3 : i32 to index
      %63 = gpu.block_dim  x
      %64 = arith.index_cast %arg6 : i32 to index
      %65 = arith.index_cast %59 : i32 to index
      %66 = arith.index_cast %59 : i32 to index
      %67:2 = scf.for %arg7 = %65 to %64 step %63 iter_args(%arg8 = %58#0, %arg9 = %58#1) -> (f32, f32) {
        %75 = arith.subi %arg7, %65 : index
        %76 = arith.divui %75, %63 : index
        %77 = arith.muli %76, %63 : index
        %78 = arith.addi %66, %77 : index
        %79 = arith.addi %78, %60 : index
        %80 = "polygeist.subindex"(%arg0, %79) : (memref<?xf32>, index) -> memref<?xf32>
        %81 = func.call @_Z5__ldgPKf(%80) : (memref<?xf32>) -> f32
        %82 = arith.addi %78, %61 : index
        %83 = "polygeist.subindex"(%arg1, %82) : (memref<?xf32>, index) -> memref<?xf32>
        %84 = func.call @_Z5__ldgPKf(%83) : (memref<?xf32>) -> f32
        %85 = arith.addi %78, %62 : index
        %86 = "polygeist.subindex"(%arg2, %85) : (memref<?xf32>, index) -> memref<?xf32>
        %87 = func.call @_Z5__ldgPKf(%86) : (memref<?xf32>) -> f32
        %88 = arith.subf %81, %84 : f32
        %89 = arith.mulf %88, %88 : f32
        %90 = arith.addf %arg9, %89 : f32
        %91 = arith.subf %81, %87 : f32
        %92 = arith.mulf %91, %91 : f32
        %93 = arith.addf %arg8, %92 : f32
        scf.yield %93, %90 : f32, f32
      }
      %68:3 = scf.while (%arg7 = %c16_i32, %arg8 = %67#0, %arg9 = %67#1) : (i32, f32, f32) -> (f32, f32, i32) {
        %75 = arith.cmpi sgt, %arg7, %c0_i32 : i32
        scf.condition(%75) %arg8, %arg9, %arg7 : f32, f32, i32
      } do {
      ^bb0(%arg7: f32, %arg8: f32, %arg9: i32):
        %75 = func.call @_Z16__shfl_down_syncjfji(%c-1_i32, %arg8, %arg9, %c32_i32) : (i32, f32, i32, i32) -> f32
        %76 = arith.addf %arg8, %75 : f32
        %77 = func.call @_Z16__shfl_down_syncjfji(%c-1_i32, %arg7, %arg9, %c32_i32) : (i32, f32, i32, i32) -> f32
        %78 = arith.addf %arg7, %77 : f32
        %79 = arith.divsi %arg9, %c2_i32 : i32
        scf.yield %79, %78, %76 : i32, f32, f32
      }
      %69 = arith.remsi %5, %c32_i32 : i32
      %70 = arith.cmpi eq, %69, %c0_i32 : i32
      scf.if %70 {
        %75 = arith.divsi %5, %c32_i32 : i32
        %76 = arith.index_cast %75 : i32 to index
        memref.store %68#1, %alloca_0[%76] : memref<32xf32, 5>
        %77 = arith.index_cast %75 : i32 to index
        memref.store %68#0, %alloca[%77] : memref<32xf32, 5>
      }
      nvvm.barrier0
      %71 = gpu.block_dim  x
      %72 = arith.index_cast %71 : index to i32
      %73 = arith.divui %72, %c32_i32 : i32
      %74 = arith.cmpi slt, %5, %73 : i32
      scf.if %74 {
        %75 = memref.load %alloca_0[%4] : memref<32xf32, 5>
        %76 = memref.load %alloca[%4] : memref<32xf32, 5>
        %77 = arith.divsi %73, %c2_i32 : i32
        %78:3 = scf.while (%arg7 = %77, %arg8 = %76, %arg9 = %75) : (i32, f32, f32) -> (f32, f32, i32) {
          %79 = arith.cmpi sgt, %arg7, %c0_i32 : i32
          scf.condition(%79) %arg8, %arg9, %arg7 : f32, f32, i32
        } do {
        ^bb0(%arg7: f32, %arg8: f32, %arg9: i32):
          %79 = func.call @_Z16__shfl_down_syncjfji(%c-1_i32, %arg8, %arg9, %c32_i32) : (i32, f32, i32, i32) -> f32
          %80 = arith.addf %arg8, %79 : f32
          %81 = func.call @_Z16__shfl_down_syncjfji(%c-1_i32, %arg7, %arg9, %c32_i32) : (i32, f32, i32, i32) -> f32
          %82 = arith.addf %arg7, %81 : f32
          %83 = arith.divsi %arg9, %c2_i32 : i32
          scf.yield %83, %82, %80 : i32, f32, f32
        }
        scf.if %6 {
          %79 = math.sqrt %78#1 : f32
          %80 = math.sqrt %78#0 : f32
          %81 = arith.subf %79, %80 : f32
          %82 = arith.addf %81, %arg4 : f32
          %83 = arith.cmpf ogt, %82, %cst : f32
          %84 = arith.select %83, %82, %cst : f32
          affine.store %84, %arg3[symbol(%0)] : memref<?xf32>
        }
      }
    }
    return
  }
  func.func private @_Z5__ldgPK6float4(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)> attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1x4xf32>
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = "polygeist.pointer2memref"(%0) : (!llvm.ptr) -> memref<?x4xf32>
    %cast_3 = memref.cast %alloca_2 : memref<1x4xf32> to memref<?x4xf32>
    call @__nvvm_ldg_f4(%1, %cast_3) : (memref<?x4xf32>, memref<?x4xf32>) -> ()
    %2 = affine.load %alloca_2[0, 0] : memref<1x4xf32>
    %3 = affine.load %alloca_2[0, 1] : memref<1x4xf32>
    %4 = affine.load %alloca_2[0, 2] : memref<1x4xf32>
    %5 = affine.load %alloca_2[0, 3] : memref<1x4xf32>
    %6 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %2, %6 : f32, !llvm.ptr
    %7 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %8 = llvm.getelementptr %7[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %3, %8 : f32, !llvm.ptr
    %9 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %10 = llvm.getelementptr %9[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %10 : f32, !llvm.ptr
    %11 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %12 = llvm.getelementptr %11[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %5, %12 : f32, !llvm.ptr
    call @_ZN6float4C1EOS_(%cast, %cast_1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
    %13 = affine.load %alloca[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    return %13 : !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
  }
  func.func private @_Z5__ldgPKf(%arg0: memref<?xf32>) -> f32 attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    %0 = call @__nvvm_ldg_f(%arg0) : (memref<?xf32>) -> f32
    return %0 : f32
  }
  func.func private @_Z16__shfl_down_syncjfji(%arg0: i32, %arg1: f32, %arg2: i32, %arg3: i32) -> f32 attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    %c31_i32 = arith.constant 31 : i32
    %c8_i32 = arith.constant 8 : i32
    %c32_i32 = arith.constant 32 : i32
    %0 = arith.subi %c32_i32, %arg3 : i32
    %1 = arith.shli %0, %c8_i32 : i32
    %2 = arith.ori %1, %c31_i32 : i32
    %3 = call @__nvvm_shfl_sync_down_f32(%arg0, %arg1, %arg2, %2) : (i32, f32, i32, i32) -> f32
    return %3 : f32
  }
  func.func private @__nvvm_ldg_f4(memref<?x4xf32>, memref<?x4xf32>) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
  func.func private @_ZN6float4C1EOS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
  func.func private @__nvvm_ldg_f(memref<?xf32>) -> f32 attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
  func.func private @__nvvm_shfl_sync_down_f32(i32, f32, i32, i32) -> f32 attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
}
[ict-debug] driver.cc: After return 5, module: end

[ict-debug] driver.cc: After return 6, module:

module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z36triplet_margin_loss_kernel_warp_shflPKfS0_S0_Pffii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: f32, %arg5: i32, %arg6: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c31_i32 = arith.constant 31 : i32
    %c4 = arith.constant 4 : index
    %c2_i32 = arith.constant 2 : i32
    %c32_i32 = arith.constant 32 : i32
    %c0_i32 = arith.constant 0 : i32
    %c16_i32 = arith.constant 16 : i32
    %c-1_i32 = arith.constant -1 : i32
    %c4_i32 = arith.constant 4 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %alloca = memref.alloca() : memref<32xf32, 5>
    %alloca_0 = memref.alloca() : memref<32xf32, 5>
    %alloca_1 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_3 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.cmpi slt, %1, %arg5 : i32
    scf.if %2 {
      %3 = arith.muli %1, %arg6 : i32
      %4 = gpu.thread_id  x
      %5 = arith.index_cast %4 : index to i32
      %6 = arith.cmpi eq, %5, %c0_i32 : i32
      %7 = arith.divsi %arg6, %c4_i32 : i32
      %8 = arith.muli %7, %c4_i32 : i32
      %9 = arith.index_cast %3 : i32 to index
      %10 = arith.muli %9, %c4 : index
      %11 = arith.index_cast %10 : index to i64
      %12 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %13 = llvm.getelementptr %12[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i8
      %14 = "polygeist.pointer2memref"(%13) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %15 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %16 = llvm.getelementptr %15[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i8
      %17 = "polygeist.pointer2memref"(%16) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %18 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %19 = llvm.getelementptr %18[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i8
      %20 = "polygeist.pointer2memref"(%19) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %21 = arith.divsi %8, %c4_i32 : i32
      %22 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %23 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %24 = llvm.getelementptr %22[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %25 = llvm.getelementptr %23[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %26 = llvm.getelementptr %22[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %27 = llvm.getelementptr %23[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %28 = llvm.getelementptr %22[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %29 = llvm.getelementptr %23[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %30 = "polygeist.memref2pointer"(%alloca_1) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %31 = llvm.getelementptr %30[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %32 = llvm.getelementptr %30[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %33 = llvm.getelementptr %30[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %34 = gpu.block_dim  x
      %35 = arith.index_cast %21 : i32 to index
      %36:2 = scf.for %arg7 = %4 to %35 step %34 iter_args(%arg8 = %cst, %arg9 = %cst) -> (f32, f32) {
        %47 = arith.subi %arg7, %4 : index
        %48 = arith.divui %47, %34 : index
        %49 = arith.muli %48, %34 : index
        %50 = arith.addi %4, %49 : index
        %51 = "polygeist.subindex"(%14, %50) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %52 = func.call @_Z5__ldgPK6float4(%51) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        affine.store %52, %alloca_3[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %53 = "polygeist.subindex"(%17, %50) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %54 = func.call @_Z5__ldgPK6float4(%53) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        affine.store %54, %alloca_2[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %55 = "polygeist.subindex"(%20, %50) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %56 = func.call @_Z5__ldgPK6float4(%55) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        affine.store %56, %alloca_1[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %57 = llvm.load %22 : !llvm.ptr -> f32
        %58 = llvm.load %23 : !llvm.ptr -> f32
        %59 = arith.subf %57, %58 : f32
        %60 = arith.mulf %59, %59 : f32
        %61 = arith.addf %arg9, %60 : f32
        %62 = llvm.load %24 : !llvm.ptr -> f32
        %63 = llvm.load %25 : !llvm.ptr -> f32
        %64 = arith.subf %62, %63 : f32
        %65 = arith.mulf %64, %64 : f32
        %66 = arith.addf %61, %65 : f32
        %67 = llvm.load %26 : !llvm.ptr -> f32
        %68 = llvm.load %27 : !llvm.ptr -> f32
        %69 = arith.subf %67, %68 : f32
        %70 = arith.mulf %69, %69 : f32
        %71 = arith.addf %66, %70 : f32
        %72 = llvm.load %28 : !llvm.ptr -> f32
        %73 = llvm.load %29 : !llvm.ptr -> f32
        %74 = arith.subf %72, %73 : f32
        %75 = arith.mulf %74, %74 : f32
        %76 = arith.addf %71, %75 : f32
        %77 = llvm.load %30 : !llvm.ptr -> f32
        %78 = arith.subf %57, %77 : f32
        %79 = arith.mulf %78, %78 : f32
        %80 = arith.addf %arg8, %79 : f32
        %81 = llvm.load %31 : !llvm.ptr -> f32
        %82 = arith.subf %62, %81 : f32
        %83 = arith.mulf %82, %82 : f32
        %84 = arith.addf %80, %83 : f32
        %85 = llvm.load %32 : !llvm.ptr -> f32
        %86 = arith.subf %67, %85 : f32
        %87 = arith.mulf %86, %86 : f32
        %88 = arith.addf %84, %87 : f32
        %89 = llvm.load %33 : !llvm.ptr -> f32
        %90 = arith.subf %72, %89 : f32
        %91 = arith.mulf %90, %90 : f32
        %92 = arith.addf %88, %91 : f32
        scf.yield %92, %76 : f32, f32
      }
      %37 = arith.addi %8, %5 : i32
      %38 = arith.index_cast %arg6 : i32 to index
      %39 = arith.index_cast %37 : i32 to index
      %40:2 = scf.for %arg7 = %39 to %38 step %34 iter_args(%arg8 = %36#0, %arg9 = %36#1) -> (f32, f32) {
        %47 = arith.subi %arg7, %39 : index
        %48 = arith.divui %47, %34 : index
        %49 = arith.muli %48, %34 : index
        %50 = arith.addi %39, %49 : index
        %51 = arith.addi %50, %9 : index
        %52 = "polygeist.subindex"(%arg0, %51) : (memref<?xf32>, index) -> memref<?xf32>
        %53 = func.call @__nvvm_ldg_f(%52) : (memref<?xf32>) -> f32
        %54 = "polygeist.subindex"(%arg1, %51) : (memref<?xf32>, index) -> memref<?xf32>
        %55 = func.call @__nvvm_ldg_f(%54) : (memref<?xf32>) -> f32
        %56 = "polygeist.subindex"(%arg2, %51) : (memref<?xf32>, index) -> memref<?xf32>
        %57 = func.call @__nvvm_ldg_f(%56) : (memref<?xf32>) -> f32
        %58 = arith.subf %53, %55 : f32
        %59 = arith.mulf %58, %58 : f32
        %60 = arith.addf %arg9, %59 : f32
        %61 = arith.subf %53, %57 : f32
        %62 = arith.mulf %61, %61 : f32
        %63 = arith.addf %arg8, %62 : f32
        scf.yield %63, %60 : f32, f32
      }
      %41:3 = scf.while (%arg7 = %c16_i32, %arg8 = %40#0, %arg9 = %40#1) : (i32, f32, f32) -> (f32, f32, i32) {
        %47 = arith.cmpi sgt, %arg7, %c0_i32 : i32
        scf.condition(%47) %arg8, %arg9, %arg7 : f32, f32, i32
      } do {
      ^bb0(%arg7: f32, %arg8: f32, %arg9: i32):
        %47 = func.call @__nvvm_shfl_sync_down_f32(%c-1_i32, %arg8, %arg9, %c31_i32) : (i32, f32, i32, i32) -> f32
        %48 = arith.addf %arg8, %47 : f32
        %49 = func.call @__nvvm_shfl_sync_down_f32(%c-1_i32, %arg7, %arg9, %c31_i32) : (i32, f32, i32, i32) -> f32
        %50 = arith.addf %arg7, %49 : f32
        %51 = arith.divsi %arg9, %c2_i32 : i32
        scf.yield %51, %50, %48 : i32, f32, f32
      }
      %42 = arith.remsi %5, %c32_i32 : i32
      %43 = arith.cmpi eq, %42, %c0_i32 : i32
      scf.if %43 {
        %47 = arith.divsi %5, %c32_i32 : i32
        %48 = arith.index_cast %47 : i32 to index
        memref.store %41#1, %alloca_0[%48] : memref<32xf32, 5>
        memref.store %41#0, %alloca[%48] : memref<32xf32, 5>
      }
      nvvm.barrier0
      %44 = arith.index_cast %34 : index to i32
      %45 = arith.divui %44, %c32_i32 : i32
      %46 = arith.cmpi slt, %5, %45 : i32
      scf.if %46 {
        %47 = memref.load %alloca_0[%4] : memref<32xf32, 5>
        %48 = memref.load %alloca[%4] : memref<32xf32, 5>
        %49 = arith.divsi %45, %c2_i32 : i32
        %50:3 = scf.while (%arg7 = %49, %arg8 = %48, %arg9 = %47) : (i32, f32, f32) -> (f32, f32, i32) {
          %51 = arith.cmpi sgt, %arg7, %c0_i32 : i32
          scf.condition(%51) %arg8, %arg9, %arg7 : f32, f32, i32
        } do {
        ^bb0(%arg7: f32, %arg8: f32, %arg9: i32):
          %51 = func.call @__nvvm_shfl_sync_down_f32(%c-1_i32, %arg8, %arg9, %c31_i32) : (i32, f32, i32, i32) -> f32
          %52 = arith.addf %arg8, %51 : f32
          %53 = func.call @__nvvm_shfl_sync_down_f32(%c-1_i32, %arg7, %arg9, %c31_i32) : (i32, f32, i32, i32) -> f32
          %54 = arith.addf %arg7, %53 : f32
          %55 = arith.divsi %arg9, %c2_i32 : i32
          scf.yield %55, %54, %52 : i32, f32, f32
        }
        scf.if %6 {
          %51 = math.sqrt %50#1 : f32
          %52 = math.sqrt %50#0 : f32
          %53 = arith.subf %51, %52 : f32
          %54 = arith.addf %53, %arg4 : f32
          %55 = arith.cmpf ogt, %54, %cst : f32
          %56 = arith.select %55, %54, %cst : f32
          affine.store %56, %arg3[symbol(%0)] : memref<?xf32>
        }
      }
    }
    return
  }
  func.func private @_Z5__ldgPK6float4(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)> attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1x4xf32>
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = "polygeist.pointer2memref"(%0) : (!llvm.ptr) -> memref<?x4xf32>
    %cast_3 = memref.cast %alloca_2 : memref<1x4xf32> to memref<?x4xf32>
    call @__nvvm_ldg_f4(%1, %cast_3) : (memref<?x4xf32>, memref<?x4xf32>) -> ()
    %2 = affine.load %alloca_2[0, 0] : memref<1x4xf32>
    %3 = affine.load %alloca_2[0, 1] : memref<1x4xf32>
    %4 = affine.load %alloca_2[0, 2] : memref<1x4xf32>
    %5 = affine.load %alloca_2[0, 3] : memref<1x4xf32>
    %6 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %2, %6 : f32, !llvm.ptr
    %7 = llvm.getelementptr %6[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %3, %7 : f32, !llvm.ptr
    %8 = llvm.getelementptr %6[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %6[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %5, %9 : f32, !llvm.ptr
    call @_ZN6float4C1EOS_(%cast, %cast_1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
    %10 = affine.load %alloca[0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    return %10 : !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
  }
  func.func private @__nvvm_ldg_f4(memref<?x4xf32>, memref<?x4xf32>) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
  func.func private @_ZN6float4C1EOS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
  func.func private @__nvvm_ldg_f(memref<?xf32>) -> f32 attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
  func.func private @__nvvm_shfl_sync_down_f32(i32, f32, i32, i32) -> f32 attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
}
[ict-debug] driver.cc: After return 6, module: end

WrapAndReplaceBarrierPass::runOnOperation(): before execute: 
module attributes {dlti.dl_spec = #dlti.dl_spec<#dlti.dl_entry<i1, dense<8> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr, dense<64> : vector<4xi32>>, #dlti.dl_entry<i64, dense<64> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<272>, dense<64> : vector<4xi32>>, #dlti.dl_entry<f80, dense<128> : vector<2xi32>>, #dlti.dl_entry<f128, dense<128> : vector<2xi32>>, #dlti.dl_entry<f64, dense<64> : vector<2xi32>>, #dlti.dl_entry<f16, dense<16> : vector<2xi32>>, #dlti.dl_entry<!llvm.ptr<271>, dense<32> : vector<4xi32>>, #dlti.dl_entry<!llvm.ptr<270>, dense<32> : vector<4xi32>>, #dlti.dl_entry<i16, dense<16> : vector<2xi32>>, #dlti.dl_entry<i8, dense<8> : vector<2xi32>>, #dlti.dl_entry<i32, dense<32> : vector<2xi32>>, #dlti.dl_entry<"dlti.stack_alignment", 128 : i32>, #dlti.dl_entry<"dlti.endianness", "little">>, llvm.data_layout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128", llvm.target_triple = "x86_64-unknown-linux-gnu", polygeist.gpu_module.llvm.data_layout = "e-i64:64-i128:128-v16:16-v32:32-n16:32:64", polygeist.gpu_module.llvm.target_triple = "nvptx64-nvidia-cuda", "polygeist.target-cpu" = "x86-64", "polygeist.target-features" = "+cmov,+cx8,+fxsr,+mmx,+sse,+sse2,+x87", "polygeist.tune-cpu" = "generic"} {
  func.func private @_Z36triplet_margin_loss_kernel_warp_shflPKfS0_S0_Pffii(%arg0: memref<?xf32>, %arg1: memref<?xf32>, %arg2: memref<?xf32>, %arg3: memref<?xf32>, %arg4: f32, %arg5: i32, %arg6: i32) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"} {
    %c0 = arith.constant 0 : index
    %c31_i32 = arith.constant 31 : i32
    %c4 = arith.constant 4 : index
    %c2_i32 = arith.constant 2 : i32
    %c32_i32 = arith.constant 32 : i32
    %c0_i32 = arith.constant 0 : i32
    %c16_i32 = arith.constant 16 : i32
    %c-1_i32 = arith.constant -1 : i32
    %c4_i32 = arith.constant 4 : i32
    %cst = arith.constant 0.000000e+00 : f32
    %alloca = memref.alloca() : memref<32xf32, 5>
    %alloca_0 = memref.alloca() : memref<32xf32, 5>
    %alloca_1 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_3 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %0 = gpu.block_id  x
    %1 = arith.index_cast %0 : index to i32
    %2 = arith.cmpi slt, %1, %arg5 : i32
    scf.if %2 {
      %3 = arith.muli %1, %arg6 : i32
      %4 = gpu.thread_id  x
      %5 = arith.index_cast %4 : index to i32
      %6 = arith.cmpi eq, %5, %c0_i32 : i32
      %7 = arith.divsi %arg6, %c4_i32 : i32
      %8 = arith.muli %7, %c4_i32 : i32
      %9 = arith.index_cast %3 : i32 to index
      %10 = arith.muli %9, %c4 : index
      %11 = arith.index_cast %10 : index to i64
      %12 = "polygeist.memref2pointer"(%arg0) : (memref<?xf32>) -> !llvm.ptr
      %13 = llvm.getelementptr %12[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i8
      %14 = "polygeist.pointer2memref"(%13) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %15 = "polygeist.memref2pointer"(%arg1) : (memref<?xf32>) -> !llvm.ptr
      %16 = llvm.getelementptr %15[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i8
      %17 = "polygeist.pointer2memref"(%16) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %18 = "polygeist.memref2pointer"(%arg2) : (memref<?xf32>) -> !llvm.ptr
      %19 = llvm.getelementptr %18[%11] : (!llvm.ptr, i64) -> !llvm.ptr, i8
      %20 = "polygeist.pointer2memref"(%19) : (!llvm.ptr) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
      %21 = arith.divsi %8, %c4_i32 : i32
      %22 = "polygeist.memref2pointer"(%alloca_3) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %23 = "polygeist.memref2pointer"(%alloca_2) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %24 = llvm.getelementptr %22[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %25 = llvm.getelementptr %23[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %26 = llvm.getelementptr %22[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %27 = llvm.getelementptr %23[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %28 = llvm.getelementptr %22[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %29 = llvm.getelementptr %23[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %30 = "polygeist.memref2pointer"(%alloca_1) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
      %31 = llvm.getelementptr %30[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %32 = llvm.getelementptr %30[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %33 = llvm.getelementptr %30[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
      %34 = gpu.block_dim  x
      %35 = arith.index_cast %21 : i32 to index
      %36:2 = scf.for %arg7 = %4 to %35 step %34 iter_args(%arg8 = %cst, %arg9 = %cst) -> (f32, f32) {
        %47 = arith.subi %arg7, %4 : index
        %48 = arith.divui %47, %34 : index
        %49 = arith.muli %48, %34 : index
        %50 = arith.addi %4, %49 : index
        %51 = "polygeist.subindex"(%14, %50) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %52 = func.call @_Z5__ldgPK6float4(%51) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        memref.store %52, %alloca_3[%c0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %53 = "polygeist.subindex"(%17, %50) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %54 = func.call @_Z5__ldgPK6float4(%53) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        memref.store %54, %alloca_2[%c0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %55 = "polygeist.subindex"(%20, %50) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, index) -> memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %56 = func.call @_Z5__ldgPK6float4(%55) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
        memref.store %56, %alloca_1[%c0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
        %57 = llvm.load %22 : !llvm.ptr -> f32
        %58 = llvm.load %23 : !llvm.ptr -> f32
        %59 = arith.subf %57, %58 : f32
        %60 = arith.mulf %59, %59 : f32
        %61 = arith.addf %arg9, %60 : f32
        %62 = llvm.load %24 : !llvm.ptr -> f32
        %63 = llvm.load %25 : !llvm.ptr -> f32
        %64 = arith.subf %62, %63 : f32
        %65 = arith.mulf %64, %64 : f32
        %66 = arith.addf %61, %65 : f32
        %67 = llvm.load %26 : !llvm.ptr -> f32
        %68 = llvm.load %27 : !llvm.ptr -> f32
        %69 = arith.subf %67, %68 : f32
        %70 = arith.mulf %69, %69 : f32
        %71 = arith.addf %66, %70 : f32
        %72 = llvm.load %28 : !llvm.ptr -> f32
        %73 = llvm.load %29 : !llvm.ptr -> f32
        %74 = arith.subf %72, %73 : f32
        %75 = arith.mulf %74, %74 : f32
        %76 = arith.addf %71, %75 : f32
        %77 = llvm.load %30 : !llvm.ptr -> f32
        %78 = arith.subf %57, %77 : f32
        %79 = arith.mulf %78, %78 : f32
        %80 = arith.addf %arg8, %79 : f32
        %81 = llvm.load %31 : !llvm.ptr -> f32
        %82 = arith.subf %62, %81 : f32
        %83 = arith.mulf %82, %82 : f32
        %84 = arith.addf %80, %83 : f32
        %85 = llvm.load %32 : !llvm.ptr -> f32
        %86 = arith.subf %67, %85 : f32
        %87 = arith.mulf %86, %86 : f32
        %88 = arith.addf %84, %87 : f32
        %89 = llvm.load %33 : !llvm.ptr -> f32
        %90 = arith.subf %72, %89 : f32
        %91 = arith.mulf %90, %90 : f32
        %92 = arith.addf %88, %91 : f32
        scf.yield %92, %76 : f32, f32
      }
      %37 = arith.addi %8, %5 : i32
      %38 = arith.index_cast %arg6 : i32 to index
      %39 = arith.index_cast %37 : i32 to index
      %40:2 = scf.for %arg7 = %39 to %38 step %34 iter_args(%arg8 = %36#0, %arg9 = %36#1) -> (f32, f32) {
        %47 = arith.subi %arg7, %39 : index
        %48 = arith.divui %47, %34 : index
        %49 = arith.muli %48, %34 : index
        %50 = arith.addi %39, %49 : index
        %51 = arith.addi %50, %9 : index
        %52 = "polygeist.subindex"(%arg0, %51) : (memref<?xf32>, index) -> memref<?xf32>
        %53 = func.call @__nvvm_ldg_f(%52) : (memref<?xf32>) -> f32
        %54 = "polygeist.subindex"(%arg1, %51) : (memref<?xf32>, index) -> memref<?xf32>
        %55 = func.call @__nvvm_ldg_f(%54) : (memref<?xf32>) -> f32
        %56 = "polygeist.subindex"(%arg2, %51) : (memref<?xf32>, index) -> memref<?xf32>
        %57 = func.call @__nvvm_ldg_f(%56) : (memref<?xf32>) -> f32
        %58 = arith.subf %53, %55 : f32
        %59 = arith.mulf %58, %58 : f32
        %60 = arith.addf %arg9, %59 : f32
        %61 = arith.subf %53, %57 : f32
        %62 = arith.mulf %61, %61 : f32
        %63 = arith.addf %arg8, %62 : f32
        scf.yield %63, %60 : f32, f32
      }
      %41:3 = scf.while (%arg7 = %c16_i32, %arg8 = %40#0, %arg9 = %40#1) : (i32, f32, f32) -> (f32, f32, i32) {
        %47 = arith.cmpi sgt, %arg7, %c0_i32 : i32
        scf.condition(%47) %arg8, %arg9, %arg7 : f32, f32, i32
      } do {
      ^bb0(%arg7: f32, %arg8: f32, %arg9: i32):
        %47 = func.call @__nvvm_shfl_sync_down_f32(%c-1_i32, %arg8, %arg9, %c31_i32) : (i32, f32, i32, i32) -> f32
        %48 = arith.addf %arg8, %47 : f32
        %49 = func.call @__nvvm_shfl_sync_down_f32(%c-1_i32, %arg7, %arg9, %c31_i32) : (i32, f32, i32, i32) -> f32
        %50 = arith.addf %arg7, %49 : f32
        %51 = arith.divsi %arg9, %c2_i32 : i32
        scf.yield %51, %50, %48 : i32, f32, f32
      }
      %42 = arith.remsi %5, %c32_i32 : i32
      %43 = arith.cmpi eq, %42, %c0_i32 : i32
      scf.if %43 {
        %47 = arith.divsi %5, %c32_i32 : i32
        %48 = arith.index_cast %47 : i32 to index
        memref.store %41#1, %alloca_0[%48] : memref<32xf32, 5>
        memref.store %41#0, %alloca[%48] : memref<32xf32, 5>
      }
      nvvm.barrier0
      %44 = arith.index_cast %34 : index to i32
      %45 = arith.divui %44, %c32_i32 : i32
      %46 = arith.cmpi slt, %5, %45 : i32
      scf.if %46 {
        %47 = memref.load %alloca_0[%4] : memref<32xf32, 5>
        %48 = memref.load %alloca[%4] : memref<32xf32, 5>
        %49 = arith.divsi %45, %c2_i32 : i32
        %50:3 = scf.while (%arg7 = %49, %arg8 = %48, %arg9 = %47) : (i32, f32, f32) -> (f32, f32, i32) {
          %51 = arith.cmpi sgt, %arg7, %c0_i32 : i32
          scf.condition(%51) %arg8, %arg9, %arg7 : f32, f32, i32
        } do {
        ^bb0(%arg7: f32, %arg8: f32, %arg9: i32):
          %51 = func.call @__nvvm_shfl_sync_down_f32(%c-1_i32, %arg8, %arg9, %c31_i32) : (i32, f32, i32, i32) -> f32
          %52 = arith.addf %arg8, %51 : f32
          %53 = func.call @__nvvm_shfl_sync_down_f32(%c-1_i32, %arg7, %arg9, %c31_i32) : (i32, f32, i32, i32) -> f32
          %54 = arith.addf %arg7, %53 : f32
          %55 = arith.divsi %arg9, %c2_i32 : i32
          scf.yield %55, %54, %52 : i32, f32, f32
        }
        scf.if %6 {
          %51 = math.sqrt %50#1 : f32
          %52 = math.sqrt %50#0 : f32
          %53 = arith.subf %51, %52 : f32
          %54 = arith.addf %53, %arg4 : f32
          %55 = arith.cmpf ogt, %54, %cst : f32
          %56 = arith.select %55, %54, %cst : f32
          memref.store %56, %arg3[%0] : memref<?xf32>
        }
      }
    }
    return
  }
  func.func private @_Z5__ldgPK6float4(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)> attributes {llvm.linkage = #llvm.linkage<linkonce_odr>, polygeist.device_only_func = "1"} {
    %c3 = arith.constant 3 : index
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %alloca = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast = memref.cast %alloca : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_0 = memref.alloca() : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %cast_1 = memref.cast %alloca_0 : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>> to memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    %alloca_2 = memref.alloca() : memref<1x4xf32>
    %0 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = "polygeist.pointer2memref"(%0) : (!llvm.ptr) -> memref<?x4xf32>
    %cast_3 = memref.cast %alloca_2 : memref<1x4xf32> to memref<?x4xf32>
    call @__nvvm_ldg_f4(%1, %cast_3) : (memref<?x4xf32>, memref<?x4xf32>) -> ()
    %2 = memref.load %alloca_2[%c0, %c0] : memref<1x4xf32>
    %3 = memref.load %alloca_2[%c0, %c1] : memref<1x4xf32>
    %4 = memref.load %alloca_2[%c0, %c2] : memref<1x4xf32>
    %5 = memref.load %alloca_2[%c0, %c3] : memref<1x4xf32>
    %6 = "polygeist.memref2pointer"(%alloca_0) : (memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %2, %6 : f32, !llvm.ptr
    %7 = llvm.getelementptr %6[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %3, %7 : f32, !llvm.ptr
    %8 = llvm.getelementptr %6[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %6[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %5, %9 : f32, !llvm.ptr
    call @_ZN6float4C1EOS_(%cast, %cast_1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> ()
    %10 = memref.load %alloca[%c0] : memref<1x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>
    return %10 : !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
  }
  func.func private @__nvvm_ldg_f4(memref<?x4xf32>, memref<?x4xf32>) attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
  func.func private @_ZN6float4C1EOS_(%arg0: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>, %arg1: memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) attributes {llvm.linkage = #llvm.linkage<linkonce_odr>} {
    %0 = "polygeist.memref2pointer"(%arg1) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    %1 = llvm.load %0 : !llvm.ptr -> f32
    %2 = "polygeist.memref2pointer"(%arg0) : (memref<?x!llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>>) -> !llvm.ptr
    llvm.store %1, %2 : f32, !llvm.ptr
    %3 = llvm.getelementptr %0[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %4 = llvm.load %3 : !llvm.ptr -> f32
    %5 = llvm.getelementptr %2[0, 1] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %4, %5 : f32, !llvm.ptr
    %6 = llvm.getelementptr %0[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %7 = llvm.load %6 : !llvm.ptr -> f32
    %8 = llvm.getelementptr %2[0, 2] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %7, %8 : f32, !llvm.ptr
    %9 = llvm.getelementptr %0[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    %10 = llvm.load %9 : !llvm.ptr -> f32
    %11 = llvm.getelementptr %2[0, 3] : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<"opaque@polygeist@mlir@struct.float4", (f32, f32, f32, f32)>
    llvm.store %10, %11 : f32, !llvm.ptr
    return
  }
  func.func private @__nvvm_ldg_f(memref<?xf32>) -> f32 attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
  func.func private @__nvvm_shfl_sync_down_f32(i32, f32, i32, i32) -> f32 attributes {llvm.linkage = #llvm.linkage<external>, polygeist.device_only_func = "1"}
}
WrapAndReplaceBarrierPass::runOnOperation(): before execute: end
[ict-debug] WrapAndReplaceBarrierPass::runOnOperation(): Function name: __nvvm_ldg_f4. func.getBlocks().size() == 0! this function is empty, skip it.

[ict-debug] WrapAndReplaceBarrierPass::runOnOperation(): Function name: __nvvm_ldg_f. func.getBlocks().size() == 0! this function is empty, skip it.

[ict-debug] WrapAndReplaceBarrierPass::runOnOperation(): Function name: __nvvm_shfl_sync_down_f32. func.getBlocks().size() == 0! this function is empty, skip it.

WrapAndReplaceBarrierPass::runOnOperation(): after execute: 
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist --function=* -cuda-lower -output-intermediate-gpu -scal-rep=0 -raise-scf-to-affine --cuda-gpu-arch=sm_70 -parallel-licm=1 -gpu-kernel-structure-mode=block_thread_noops --enable-buffer-elim=0 -O2 -I /CUDA2BANG/cuda2bang/polygeist/mlir-build/projects/openmp/runtime/src/ -resource-dir=/CUDA2BANG/cuda2bang/polygeist/mlir-build/lib/clang/18/ -I /CUDA2BANG/cuda2bang/polygeist/mlir-build/projects/openmp/runtime/src/ -I /usr/local/cuda/include/ -use-original-gpu-block-size --emit-npu=distribute.mincut -use-my-pass -bang-dump-file=./gen_bang_results/99_TripletMarginLoss.mlu ./cuda_ops/99_TripletMarginLoss.cu -o 99_TripletMarginLoss.o
 #0 0x000056537687ab9f llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x3390b9f)
 #1 0x0000565376878384 SignalHandler(int) Signals.cpp:0:0
 #2 0x00007fc56232e420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)
 #3 0x0000565376c42978 mlir::AsmPrinter::Impl::printTypeImpl(mlir::Type) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x3758978)
 #4 0x0000565376c4363b mlir::AsmPrinter::Impl::printType(mlir::Type) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x375963b)
 #5 0x0000565376c2c68b mlir::OpAsmPrinter::printFunctionalType(mlir::Operation*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x374268b)
 #6 0x0000565376c45a0c (anonymous namespace)::OperationPrinter::printGenericOp(mlir::Operation*, bool) AsmPrinter.cpp:0:0
 #7 0x0000565376c45d32 (anonymous namespace)::OperationPrinter::printCustomOrGenericOp(mlir::Operation*) AsmPrinter.cpp:0:0
 #8 0x0000565376c46229 (anonymous namespace)::OperationPrinter::printFullOpWithIndentAndLoc(mlir::Operation*) AsmPrinter.cpp:0:0
 #9 0x0000565376c474d8 mlir::Operation::print(llvm::raw_ostream&, mlir::AsmState&) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x375d4d8)
#10 0x0000565376c48ebc mlir::Operation::print(llvm::raw_ostream&, mlir::OpPrintingFlags const&) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x375eebc)
#11 0x0000565376ca7db4 mlir::Diagnostic::appendOp(mlir::Operation&, mlir::OpPrintingFlags const&) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x37bddb4)
#12 0x0000565376cf4d05 mlir::OpState::emitError(llvm::Twine const&) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x380ad05)
#13 0x000056537a5169d1 mlir::func::ReturnOp::verify() (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x702c9d1)
#14 0x000056537a52128b mlir::Op<mlir::func::ReturnOp, mlir::OpTrait::ZeroRegions, mlir::OpTrait::ZeroResults, mlir::OpTrait::ZeroSuccessors, mlir::OpTrait::VariadicOperands, mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl, mlir::OpTrait::OpInvariants, mlir::ConditionallySpeculatable::Trait, mlir::OpTrait::AlwaysSpeculatableImplTrait, mlir::MemoryEffectOpInterface::Trait, mlir::OpTrait::MemRefsNormalizable, mlir::RegionBranchTerminatorOpInterface::Trait, mlir::OpTrait::ReturnLike, mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::Operation*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x703728b)
#15 0x0000565376ab87e6 mlir::LogicalResult llvm::detail::UniqueFunctionBase<mlir::LogicalResult, mlir::Operation*>::CallImpl<mlir::LogicalResult (* const)(mlir::Operation*)>(void*, mlir::Operation*) /CUDA2BANG/cuda2bang/polygeist/llvm-project/llvm/include/llvm/ADT/FunctionExtras.h:221:3
#16 0x000056537a520f0b mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::verifyInvariants(mlir::Operation*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x7036f0b)
#17 0x0000565376d2a1da (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) Verifier.cpp:0:0
#18 0x0000565376d29dce (anonymous namespace)::OperationVerifier::verifyOperation(mlir::Operation&) Verifier.cpp:0:0
#19 0x0000565376d2bb1a mlir::verify(mlir::Operation*, bool) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x3841b1a)
#20 0x0000565376c404a8 mlir::AsmState::AsmState(mlir::Operation*, mlir::OpPrintingFlags const&, llvm::DenseMap<mlir::Operation*, std::pair<unsigned int, unsigned int>, llvm::DenseMapInfo<mlir::Operation*, void>, llvm::detail::DenseMapPair<mlir::Operation*, std::pair<unsigned int, unsigned int>>>*, mlir::FallbackAsmResourceMap*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x37564a8)
#21 0x0000565376c49043 mlir::Operation::dump() (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x375f043)
#22 0x000056537749a182 (anonymous namespace)::WrapAndReplaceBarrierPass::runOnOperation() /CUDA2BANG/cuda2bang/polygeist/lib/polygeist/Passes/ConvertParallelToGPU.cpp:2547:16
#23 0x0000565377677881 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x418d881)
#24 0x0000565377677e01 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x418de01)
#25 0x000056537767897e mlir::PassManager::run(mlir::Operation*) (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0x418e97e)
#26 0x0000565373f47efe main /CUDA2BANG/cuda2bang/polygeist/tools/cgeist/driver.cc:882:0
#27 0x00007fc561c94083 __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:342:3
#28 0x0000565373f1784e _start (/CUDA2BANG/cuda2bang/polygeist/build/bin/cgeist+0xa2d84e)
